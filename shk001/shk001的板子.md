[TOC]

# 基础操作


## STL

### bitset

```c++
/*
C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，
它的每一个元素只能是０或１，每个元素仅用１bit空间。
*/
//-------------构造方法-------------
bitset<4> bitset1;　　//无参构造，长度为４，默认每一位为０
bitset<8> bitset2(12);　　//长度为８，二进制保存，前面用０补充
string s = "100101";
bitset<10> bitset3(s);　　//长度为10，前面用０补充
char s2[] = "10101";
bitset<13> bitset4(s2);　　//长度为13，前面用０补充
cout << bitset1 << endl;　　//0000
cout << bitset2 << endl;　　//00001100
cout << bitset3 << endl;　　//0000100101
cout << bitset4 << endl;　　//0000000010101
//--------------可用函数-------------
bitset<8> foo ("10011011");

cout << foo.count() << endl;　　//5　　count函数用来求bitset中1的位数
cout << foo.size() << endl;　　 //8　　size函数用来求bitset的大小

cout << foo.test(0) << endl;　　//true　　test函数用来查下标处的元素是０还是１
cout << foo.test(2) << endl;　　//false　

cout << foo.any() << endl;　　//true　　any函数检查bitset中是否有１
cout << foo.none() << endl;　　//false　　none函数检查bitset中是否没有１
cout << foo.all() << endl;　　//false　　all函数检查bitset中是全部为１


bitset<8> foo ("10011011");

cout << foo.flip(2) << endl;　　//10011111　　flip函数传参数时，用于将参数位取反
cout << foo.flip() << endl;　　 //01100000　　flip函数不指定参数时，将bitset每一位全部取反

cout << foo.set() << endl;　　　　//11111111　　set函数不指定参数时，将bitset的每一位全部置为１
cout << foo.set(3,0) << endl;　　//11110111　　set函数指定两位参数时，将第一参数位的元素置为第二参数的值
cout << foo.set(3) << endl;　　  //11111111　　set函数只有一个参数时，将参数下标处置为１

cout << foo.reset(4) << endl;　　//11101111　　reset函数传一个参数时将参数下标处置为０
cout << foo.reset() << endl;　　 //00000000　　reset函数不传参数时将bitset的每一位全部置为０



bitset<8> foo ("10011011");

string s = foo.to_string();　　//将bitset转换成string类型
unsigned long a = foo.to_ulong();　　//将bitset转换成unsigned long类型
unsigned long long b = foo.to_ullong();　　//将bitset转换成unsigned long long类型

cout << s << endl;　　//10011011
cout << a << endl;　　//155
cout << b << endl;　　//155
```



## 二进制枚举

```c++
for(int i=0;i<(1<<n);i++) {//n个物品取或不取
    for(int j=0;j<n;j++) {
        if( i & (1<<j) ) {//取 
            
        }
        else {//不取
              
        }
    }
 } 
```

## 高效位运算 _builtin_函数

```c++
int __builtin_ffs (unsigned int x)
//返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4。
int __builtin_clz (unsigned int x)
//返回前导的0的个数。
int __builtin_ctz (unsigned int x)
//返回后面的0个个数，和__builtin_clz相对。
int __builtin_popcount (unsigned int x)
//返回二进制表示中1的个数。
int __builtin_parity (unsigned int x)
//返回x的奇偶校验位，也就是x的1的个数模2的结果。
//
//此外，这些函数都有相应的usigned long和usigned long long版本，
//只需要在函数名后面加上l或ll就可以了，比如int __builtin_clzll。
```

## 矩阵

```c++
ll powmod(ll a, ll b) {
    ll res = 1;
    a = a % mod;
    while(b) {
        if(b & 1) {
            res = res * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return res % mod;
}
ll inv(ll p) {
    return powmod(p, mod - 2);
}
ll is[N], js[N];
class mat {
public:
    int n,m;
    ll v[N][N];
    mat(int n,int m) : n(n), m(m){memset(v, 0, sizeof(v));}
    void init() {   
        memset(v, 0, sizeof(v));
    }
    void init1() {
        for(int i = 0; i < N; i++)
            for(int j = 0; j < N; j++)
                v[i][j] = (i == j); //单位矩阵
    }
    mat operator * (const mat B) const {//矩阵乘法 A(n,k)*B(k,m)=C(n,m);
        mat C(n, B.m);
        C.init();
        for(int i = 1; i <= n; i++)
        for(int j = 1; j <= B.m; j++)
        for(int k = 1; k <= m; k++)
            C.v[i][j] = (C.v[i][j] + v[i][k] * B.v[k][j]) % mod;//Mod
        return C;
    }
    //矩阵快速幂 n=m时可用
    mat operator ^ (int t) {
        mat ans(n, n), now(n, n);
        ans.init1();
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                now.v[i][j] = v[i][j];
        while(t > 0) {
            if(t & 1) ans = ans * now;
            now = now * now;
            t >>= 1;
        }
        return ans;
    }
     // 转置
    void change() { 
    	swap(n, m);
		for(int i = 1; i <= max(n, m); i++) {
			for(int j = i + 1; j <= max(n, m); j++) {
				swap(v[i][j], v[j][i]);
			}
		} 
	} 
    // 逆矩阵 
	void Minv() {  
		for(int k = 1; k <= n; k++) {
	        for(int i = k; i <= n; i++) // 1
	            for(int j = k; j <= n; j++)
	                if(v[i][j]) {
	                    is[k] = i;
	                    js[k] = j;
	                    break;
	                }
	        for(int i = 1; i <= n; i++) // 2
	            swap(v[k][i], v[is[k]][i]);
	        for(int i = 1; i <= n; i++)
	            swap(v[i][k], v[i][js[k]]);
	        v[k][k] = inv(v[k][k]); // 3
	        for(int j = 1; j <= n; j++)
	            if(j != k) // 4
	            	v[k][j] = v[k][j] * v[k][k] % mod;
	        for(int i = 1; i <= n; i++)
	            if(i != k) // 5
	            for(int j = 1; j <= n; j++)
	                if(j != k)
	                    v[i][j] = (v[i][j] + mod - v[i][k] * v[k][j] % mod) % mod;
	        for(int i = 1; i <= n; i++)
	            if(i != k)
	            v[i][k] = (mod - v[i][k] * v[k][k] % mod) % mod;
	    }
	    for(int k = n; k; k--) { // 6
	        for(int i = 1; i <= n; i++)
	            swap(v[js[k]][i], v[k][i]);
	        for(int i = 1; i <= n; i++)
	            swap(v[i][is[k]], v[i][k]);
	    }
	}
};
```

## 状态压缩

```c++
//判断一个数字x二进制下第i位是不是等于1,反之为0
if(((1 << i) & x) > 0)

//将一个数字x二进制下第i位更改成1
x=x | (1 << i)

//将一个数字x二进制下第i位更改成0
x=x ^ i(1 << i);

//把一个数字二进制下最靠右的第一个1去掉  
x=x & (x − 1)
```

## java大数

### 开头

```java
import java.io.*;
import java.math.*;
import java.util.*;
import java.text.DecimalFormat;
public class Main {
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
      	DecimalFormat df=new DecimalFormat("0.00");//小数保留2位
      //System.out.println(df.format(a));
    	while(cin.hasNext()){
          BigDecimal a= cin.nextBigDecimal();
        }//多组输入
    }
}
```

### 四则运算

```java
/*
加		a+b: a=a.add(b);
减		a-b: a=a.subtract(b); 
乘		a*b: a=a.multiply(b);
除		a/b: a=a.divide(b);
求余	    a%b: a=a.mod(b);
绝对值		abs a=a.abs();
转换		a=b: b=BigInteger.valueOf(a);
比较		a.compareTo(b)  =-1,a<b;
				   	 	        =0,a=b;
						          =1,a>b;
a.equals(b)   a==b返回ture
a.mod(b)　　//求余数即a%b
a.gcd(b) 　　//求最大公约数
a.max(b)　　//求最大值
a.min(b) 　　//求最小值
a.pow(b)　　//求a^b的大数
*/
public class Main {
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
      	BigInteger a;
      	BigInteger b;
      	BigInteger t1=new BigInteger(1);
      	BigInteger t2=new BigInteger("12313");
      	int t=5;
      	BigInteger t3=BigInteger.valueOf(t);//t3=5;
      	BigDecimal d=new BigDecimal(5.3435345);
      	BigInteger dd=d.toBigInteger();//小数型转整形无四舍五入//d=5;
        BigInteger []s = new BigInteger[4040];//初始化一个4040的大数数组
    }
}
```

### 判大素数

```java
BigInteger x;
x=cin.nextBigInteger();
if(x.isProbablePrime(1))
    System.out.println("Yes");
else
    System.out.println("No");
```

### 大数二分

```c++
//这是将sqrt（5）精确到100位的二分			
BigDecimal d=new BigDecimal(5);
BigDecimal eps=new BigDecimal("0.00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 01");//（100个0）
BigDecimal l=new BigDecimal("2.236067977499789696");
BigDecimal r=new BigDecimal("2.236067977499789697");
BigDecimal mid;
BigDecimal t1=new BigDecimal(1);
BigDecimal t2=new BigDecimal(2);
while(l.multiply(l).subtract(d).abs().compareTo(eps)==1)
{
	mid=l.add(r).divide(t2);
	if(mid.multiply(mid).compareTo(d)<0)
	{
		l=mid;
	}
	else r=mid;
}
```

# 数论

## GCD

```c++
//最大公约      //建议直接__gcd()
ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
ll lcm(ll a, ll b) {
	return a * b / gcd(a, b);//可能会爆，快速乘
}//最大公倍

```

### 区间gcd

```c++
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
int v[N], l[N], a[N], len[N];
map<ll, ll> M;
struct point {
    int l, v;
} p[N][55];

scanf("%d", &n);
memset(v, 0, sizeof(v));
memset(len, 0, sizeof(len));
memset(l, 0, sizeof(l));
M.clear();
for (int i = 1; i <= n; i++)
	scanf("%d", &a[i]);
for (int i = 1, j; i <= n; i++) {//枚举右端点
	for (v[i] = a[i], j = l[i] = i; j; j = l[j] - 1) {
  		v[j] = gcd(v[j], a[i]);
  		while (l[j] > 1 && gcd(a[i], v[l[j] - 1]) == gcd(a[i], v[j]))
    	l[j] = l[l[j] - 1];//和自己边界l[j]-1相同,更新l[j]
		p[i][len[i]].l = l[j];
    	p[i][len[i]].v = v[j];
    	len[i]++;//边界种类++；
    	M[v[j]] += (j - l[j] + 1);//gcd为v[j]的数目++
  	}
}
int l, r, ans;
scanf("%d%d", &l, &r);
for (int i = 0; i < len[r]; i++) {
	if (l >= p[r][i].l) {
    	ans = p[r][i].v;
    	break;
  	}
}
printf("%d %lld\n", ans, M[ans]);

```

### 性质

$$
\begin{aligned}
&gcd(Fib(n),Fib(m)) = Fib(gcd(n,m))
\\&gcd(m^a,n^a) = gcd(m,n)^a 
\\&gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1
\\&gcd(a^m-b^m,a^n-b^n) = a^{gcd(m,n)} - b^{gcd(m,n)} (a,b 互质)
\\&gcd（b*t+a,b）=gcd（a,b）
//所以和b有关的gcd以phi(b)为循环节循环
\end{aligned}
$$

## 博弈论

### Bash博弈

$$
n \% (m+1)==0 ，先手输
$$

### Nim博弈

$$
算出各个sg值，全体异或=0，先手输
$$

	### 非常规（sg函数）

```c++
//f[]：可以取走的石子个数
//sg[]:0~n的SG函数值
//hash[]:mex{}
int f[N], sg[N], hash[N];     
void getSG(int n) {
    int i, j;
    memset(sg, 0, sizeof(sg));
    for(i = 1; i <= n; i++) {
        memset(hash, 0, sizeof(hash));
        for(j = 1; f[j] <= i; j++)
            hash[sg[i - f[j]]]=1;
        for(j = 0; j <= n; j++) {   //求mes{}中未出现的最小的非负整数
            if(hash[j] == 0) {
                sg[i] = j;
                break;
            }
        }
    }
}
```

### 威佐夫博弈

$$
(a1-a2)*\frac{\sqrt5+1}{2}==a2，先手输//a1>a2
\\第k个奇异局势为（\frac{(\sqrt5+1)*k}{2}，\frac{(\sqrt5+3) * k}{2}
$$

### 威佐夫博弈扩展

按照上面在棋盘上移动棋子的方式，每次向左下移动可以看作是向左移动$dx$,向下移动$dy$， 要求$|dx-dy|<1$。那么如果将这个要求扩展到$|dx-dy|<d$呢？我们同样可以得出第k个奇异局势$(x,y)$，x为前$0～k-1$个奇异局势中没有出现过的最小自然数，$y=x+d*k$。根据Betty定理同样能得出第k个奇异局势为
$$
(2 - d + \frac{\sqrt{d ^ 2 + 4}*k}{2},2 + d + \frac{\sqrt{d ^ 2 + 4}*k}{2})
$$

## 素数

### 素数线性筛

```c++
bool notp[N];
int prime[N], pnum;//prime里存素数
void sieve() {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for(int i = 2; i < N; i++) {
        if(!(notp[i])) prime[++pnum] = i;
        for(int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}

```

### 素数检测

```c++
bool is_prime(ll x) {//大素数检测，可用米勒罗宾代替 
    if(x == 1)
        return false;
    if(x == 2 || x == 3)
        return true;
    if(x % 6 != 1 && x % 6 != 5)
        return false;
    int s = sqrt(x);
    for(int i = 5; i <= s; i += 6)
        if(x % i == 0 || x % (i + 2) == 0)
            return false;
    return true;
}
```



### 米勒罗宾素数检测

```c++
// 18位素数：154590409516822759
// 19位素数：2305843009213693951 (梅森素数)
// 19位素数：4384957924686954497
ll prime[6] = {2, 3, 5, 233, 331};
ll qmul(ll x, ll y, ll mod) { // 乘法防止溢出， 如果p * p不爆ll的话可以直接乘； O(1)乘法或者转化成二进制加法
    return (x * y - (long long)(x / (long double)mod * y + 1e-3) *mod + mod) % mod;
    /*
    ll ret = 0;
    while(y) {
        if(y & 1)
            ret = (ret + x) % mod;
        x = x * 2 % mod;
        y >>= 1;
    }
    return ret;
    */
}
ll qpow(ll a, ll n, ll mod) {
    ll ret = 1;
    while(n) {
        if(n & 1) ret = qmul(ret, a, mod);
        a = qmul(a, a, mod);
        n >>= 1;
    }
    return ret;
}
bool Miller_Rabin(ll p) {
    if(p < 2) return 0;
    if(p != 2 && p % 2 == 0) return 0;
    ll s = p - 1;
    while(! (s & 1)) s >>= 1;
    for(int i = 0; i < 5; ++i) {
        if(p == prime[i]) return 1;
        ll t = s, m = qpow(prime[i], s, p);
        while(t != p - 1 && m != 1 && m != p - 1) {
            m = qmul(m, m, p);
            t <<= 1;
        }
        if(m != p - 1 && !(t & 1)) return 0;
    }
    return 1;
}

```

### 区间筛

```c++
//找L~R之间的质数
ll L,R;
int k;
bool notp[N];
int prime[N],pnum;
void sieve() {
    memset(notp,0,sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for(int i = 2;i < sqrt(R); i++) {
        if(!(notp[i])) prime[++pnum] = i;
        for(int j = 1; j <= pnum && prime[j] * i < sqrt(R); j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
bool v[1000010];//v中存L开始的数是否为素数
void interval_sieve() {
    memset(v, 1, sizeof(v));
    if(L == 1) v[0] = 0;
    for(int i = 1; i <= pnum; i++) {
        for(int j = (L + prime[i] - 1) / prime[i]; j <= R / prime[i]; j++) {
            if(j > 1) v[prime[i] * j - L] = 0;
        }//用prime中的素数筛L~R的素数
    }
}
```

## 合数

### 合数分解

```c++
pair<int,int> d[N];
int dnum;
void prime_div(ll n) {
    dnum = 0;
    if(n == 0) return;
    int num;
    for(int i = 1; i <= pnum; i++) {
        if(n % prime[i] == 0) {
            num = 0;
            while(n % prime[i] == 0) {
                num++;
                n /= prime[i];
            }
            d[++dnum]=make_pair(prime[i], num);
        }
        if(prime[i] > pnum) break;
    }
    if(n != 1) d[++dnum]=make_pair(n, 1);
}
```

### 区间合数分解

$$
区间合数分解（d(x^k) ）//有几个因数

\\若 x 分解成质因子乘积的形式为 x = p_1^{a_1} *p_2^{a_2}* ... *p_3^{a_3}，
\\那么 d(x) = (a_1 + 1) * (a_2 + 1) * ... * (a_n + 1) .
\\显然 d(x^k) = (a_1 * k + 1) * (a_2 * k + 1) * ... * (a_n * k + 1)
$$



```c++
//先来发区间素数筛 2~sqrt(R)
ll num[1000010];L~R
ll d[1000010];//L~R的分解数 
int main() {
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld%lld%d",&L,&R,&k);
        sieve();
        for(int i = 0; i <= R - L; i++) d[i]  = 1,num[i] = i + L;
        for(int i = 1; i <= pnum; i++) {
            ll st = (L + prime[i] - 1) / prime[i] * prime[i];//st:L开始的第一个能整除prime[i]的数 
            for(ll j = st; j <= R; j += prime[i]) {
                int cnt = 0;
                while(num[j - L] % prime[i] == 0) {
                    num[j - L] /= prime[i];
                    cnt++;
                }
                d[j - L] = d[j - L] * (k * cnt % mod + 1) % mod;//cn*k+1
            }
        }
        ll ans = 0;
        for(int i = 0; i <= R - L; i++) {
            if(num[i] != 1) d[i] = d[i] * (k + 1) % mod;//未分解完，有大素数 
            ans = (ans + d[i]) % mod;
        }
        printf("%lld\n", ans);
    }
}
```

### 阶乘因数个数

$$
阶乘 N！中包含质因子 x 的个数为 N/x + N/x^2 + N/x^3 +…
$$

### 约数之和

$$
N 的约数之和 =(1+p_1+p_1^2 +……+p_1^{c_1})*(1 +p_2 + p_2^2 +……+p_2^{c_2})*…*(1+p_n+p_n^2 +……+p_n^{c_n})
$$



```c++
ll psum(ll p,int c) {//psum 可求(1+pn+pn^2 +……+pn^cn)
    if(c == 0) return 1;
    if(c & 1)
    {
        return (1 + powmod(p , (c + 1) / 2) ) % mod * psum( p , (c - 1) / 2) % mod;
    }
    else
    {
		return ((1 + powmod(p , c / 2)) % mod * psum(p , c / 2 - 1) % mod 
                + powmod(p , c)) % mod;
    }
}
```

### 组合数的质因数个数

$$
C_m^n=\frac{n!}{(n - m)! * m!}
$$



```c++
//素数筛 
//分别计算分子和分母中不同质因子的个数，相减大于 0 则对答案贡献 1
	int ans = 0;
    for(int i = 1; i <= pnum; i++) {
        int tnum = 0;
        int ch = prime[i];
        for(; ch <= n||ch <= m||ch <= n - m; ch *= prime[i]) {
            if(n >= ch) tnum += n / ch;
            if(m >= ch) tnum -= m / ch;
            if(n - m >= ch) tnum -= (n - m) / ch;
        }
//      cout<<tnum<<endl;
        if(tnum > 0) ans++;
    }
    printf("%d\n", ans);
```

## 欧拉函数

### 单个值欧拉

```c++
ll phi(ll n) {
    ll ans = n;
    for (ll i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            ans -= ans / i;         //这一步就是对应欧拉函数的通式  
            while (n % i == 0)  //为了保证完全消除我们刚才得到的那个i因子。
                n /= i;            //确保我们下一个得到的i是n的素因子。
        }
    }
    if (n > 1)              //如果还有素因子没有除
        ans -= ans / n;
    return ans;
}

```

### 欧拉筛

``` c++
bool notp[N];
int prime[N], pnum; //prime里存素数
int phi[N];
void sieve() {
    memset(notp, 0, sizeof(notp));
    phi[1] = notp[0] = notp[1] = 1;
    pnum = 0;
    for (int i = 2; i < N; i++) {
        if (!(notp[i]))
            prime[++pnum] = i, phi[i] = i - 1;
        for (int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}

```

### 欧拉降幂

$$
\\当带模求幂过程中指数非常大时可以通过欧拉定理降幂 
\\a^b\%p = a^{b\%phi(p)+phi(p)} \% p  \ \ \ \ (phi(p) ≤b)
$$

### 性质

$$
\\对欧拉函数求前缀和可得<=n的质数
\\质数N的欧拉函数是N-1 ，N^k 的欧拉函数是(N-1)*(N)^{k-1};
\\欧拉定理 a,n互质时，a^{phi[n]}=1(mod \  n)
\\当n为素数时 a^{n-1}=1\  mod\  n 此公式即 费马小定理
\\=>a^{n-2} 为在mod数为n下的逆元
\\phi[x] 一定是偶数 x>2
\\小于或等于n的数中，与n互质的数的总和为：phi[x] * x / 2  \ \ (n>1)
\\欧拉函数是积性函数――若m,n互质，phi(m*n)=phi(n)*phi(m)，
\\当n为奇数的时候，phi(2*n)=phi(n)，由上可得 
\\因为2必定和所有的奇数都是互质的，所以而phi(2)=1。所以得出这个结果
\\若正整数 a,p 互质，则对于正整数 b,
\\a^b\ \% \ p = a^{b \ \%\  phi(p)}\  \%\  p
$$

## 扩展欧几里得

```c++
void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {//ax+by=gcd(a,b)=g
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
//ax + by = c; g;
//c%g==0时有解
//x=x*c/g,y=y*c/g;
//得到特解 :(x,y)
//dx=b/g,dy=-a/g;
//得到通解 :(x+dx*n,y+dy*n);
//得到x最小正整数解 :(x%dx+dx)%dx; 

```



## 逆元

### 模数为质数

```c++
inva = powmod(a, mod - 2, mod);//快速幂
```

### 模数不为质数

```c++
void exgcd(ll a,ll b,ll &g,ll &x, ll &y) {
	if(!b) {
		g=a; x=1; y=0;
		return ;
	}
	exgcd(b, a % b, g , y, x);
	y -= (a / b) * x;
}
//a = 1( %mod )
//ax + mod * y = 1;
//x为逆元
int main() {
	ll a, mod, x, y, g;
	cin>>a; //a为要求的逆元 
	mod = 998244352; 
	exgcd(a, mod, g, x, y);
	//g = 1; 
	x=(x % mod + mod) % mod;
	cout << x << '\n';//x为逆元 
}
```

### 线性逆元

```c++
ll inv[N];
inv[1]=1;
for(int i = 2; i < mod; i++)
  inv[i] = (mod - mod / i) * inv[mod % i] % mod;

```

### 阶乘逆元

```c++
//先求n！逆元
inv[n] = powmod(fac[n], mod - 2);
for(int i = n - 1; i >= 1; i--) {
 	inv[i] = inv[i + 1] * (i + 1) % mod;
}

```

## 中国剩余定理

### 模数互质

```c++
void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
ll n;
ll as[100005];//n  
ll ms[100005];
ll china() {
    ll ans = 0, lcm = 1, x, y, g;
    for(int i = 0;i < n; i++) lcm *= as[i];
    for(int i = 0; i < n; i++) {
        ll tp = lcm / as[i];
        exgcd(tp, as[i], g, x, y);
        x=(x % as[i] + as[i]) % as[i];
        ans=(ans + tp * x * ms[i]) % lcm;
    }
    return (ans % lcm + lcm) % lcm;
}

```

### 模数不互质

```c++
typedef __int128 ll;
void exgcd(ll a, ll b, ll &g, ll &x, ll &y) {
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
bool china_flag = false;
ll a1, a2, m1, m2;
ll abs(ll x) { return x > 0 ? x : -x; }
void china() {
    ll d = a2 - a1;
    ll g, x, y;
    exgcd(m1, m2, g, x, y);
    if (d % g == 0) {
        x = ((x * d / g) % (m2 / g) + (m2 / g)) % (m2 / g);
        a1 = x * m1 + a1;
        m1 = (m1 * m2) / g;
    }
    else china_flag = true;
}
int n;
long long as[111];
long long ms[111];//mod m =a;
ll realchina() {
    a1 = as[0];
    m1 = ms[0];
    for (ll i = 1; i < n; i++) {
        a2 = as[i];//输入太多可依次输入
        m2 = ms[i];
        china();
        if (china_flag) return -1;
    }
    return a1;
}

```

## 高斯消元

### 高斯消元解同余

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
const int MAXN=310;
int aug[MAXN][MAXN];<span style="background-color: rgb(255, 255, 255);">
//增广矩阵行数为m,分别为0到m-1,列数为n+1,分别为0到n.</span>
int x[MAXN];//解集
int free_num;
int m,n;//m个方程，n个变元
int gcd(int a,int b) {
    int r;
    while(b!=0) {
        r=b;
        b=a%b;
        a=r;
    }
    return a;
}
int lcm(int a,int b) {
    return a/gcd(a,b)*b;
}
/*void Debug(void)
{
    puts("");
    int i,j;
    for(i=0;i<m;i++){
        for(j=0;j<n+1;j++){
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}*/
int trans(char *str) {
    if(strcmp(str,"MON")==0) return 1;
    else if(strcmp(str,"TUE")==0) return 2;
    else if(strcmp(str,"WED")==0) return 3;
    else if(strcmp(str,"THU")==0) return 4;
    else if(strcmp(str,"FRI")==0) return 5;
    else if(strcmp(str,"SAT")==0) return 6;
    else if(strcmp(str,"SUN")==0) return 7;
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(-1表示无解，
//0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
int Gauss() {
    int i,j;
    int row,col,max_r;// 当前这列绝对值最大的行;
    int LCM;
    int ta,tb;
    int tmp;
    for(row=0,col=0; row<m&&col<n; row++,col++) {
        // 枚举当前处理的行.
        // 找到该col列元素绝对值最大的那行与第row行交换.(为了在除法时减小误差)
        max_r=row;
        for(i=row+1; i<m; i++) {
            if(abs(aug[i][col])>abs(aug[max_r][col]))
                max_r=i;
        }
        if(max_r!=row) {
            // 与第row行交换
            for(j=row; j<n+1; j++)
                swap(aug[row][j],aug[max_r][j]);
        }
        if(aug[row][col]==0) {
            // 说明该col列第row行以下全是0了，则处理当前行的下一列.
            row--;
            continue;
        }
        for(i=row+1; i<m; i++) {
            // 枚举要删去的行.
            if(aug[i][col]!=0) {
                LCM=lcm(abs(aug[i][col]),abs(aug[row][col]));
                ta=LCM/abs(aug[i][col]);
                tb=LCM/abs(aug[row][col]);
                if(aug[i][col]*aug[row][col]<0) tb=-tb;//异号的情况是相加
                for(j=col; j<n+1; j++) {
                    aug[i][j]=(((aug[i][j]*ta-aug[row][j]*tb)%7+7)%7);
                }
            }
        }
    }
    //Debug();
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for(i=row; i<m; i++) {
        if(aug[i][col]!=0)  return -1;
    }
    // 2. 无穷解的情况: 在n * (n + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if(row<n){
        return n-row;
    }
     // 3. 唯一解的情况: 在n * (n + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for(i=n-1; i>=0; i--) {
        tmp=aug[i][n];//等式右边的数
        for(j=i+1; j<n; j++) {
            if(aug[i][j]!=0) tmp-=aug[i][j]*x[j];//把已知的解带入，减去，只剩下，一个未知的解
            tmp=(tmp%7+7)%7;
        }
        while(tmp%aug[i][i]!=0)//外层每次循环都是为了求 a[i][i],因为它是每个方程中唯一一个未知的变量（求该方程时）
            tmp+=7;//因为天数不确定，而aug[i][i]必须得为整数才可以，周期为7
        x[i]=(tmp/aug[i][i])%7;
    }
    return 0;
}
int main(void) {
    int nn,mm,i,j,k;
    int num;
    char Start[5],End[5];
    while(~scanf("%d %d",&nn,&mm)) {
        if(nn==0&&mm==0) break;
        n=m=0;
        memset(aug,0,sizeof(aug));
        for(i=0; i<mm; i++) {
            scanf("%d",&k);
            scanf("%s %s",Start,End);
            aug[i][nn]=((trans(End)-trans(Start)+1)%7+7)%7;
            for(j=1; j<=k; j++) {
                scanf("%d",&num);
                num--;
                aug[i][num]++;
                aug[i][num]%=7;//有重复的
            }
        }
        m=mm;
        n=nn;
        free_num = Gauss();
        if(free_num==0) {
            for(i=0; i<n; i++)
                if(x[i]<3)//根据题意，每个零件的加工时间在3-9天.
                    x[i]+=7;
            for(i=0; i<n-1; i++)
                printf("%d ",x[i]);
            printf("%d\n",x[i]);
        } else if(free_num==-1)
            puts("Inconsistent data.");
        else
            puts("Multiple solutions.");
    }
    return 0;
}

```

### 高斯消元double版

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 105
double a[N][N];
int n;
void gauss() {
    for (int i = 1; i <= n; i++) {//枚举列（项）
        int maxn = i;
        for (int j = i + 1; j <= n; j++) {//选出该列最大系数
            if (fabs(a[j][i]) > fabs(a[max][i])) {
                maxn = j;
            }
        }
        for (int j = 1; j <= n + 1; j++) {//交换
            swap(a[i][j], a[maxn][j]);
        }
        if (!a[i][i]) {//最大值等于0则说明该列都为0，肯定无解
            printf("No Solution\n");
            return;
        }
        for (int j = 1; j <= n; j++) {//每一项都减去一个数（就是小学加减消元） 
            if (j != i) {
                double temp = a[j][i] / a[i][i];
                for (int k = i + 1; k <= n + 1; k++) {
                    a[j][k] -= a[i][k] * temp;
                    //a[j][k]-=a[j][i]*a[i][k]/a[i][i];
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            printf("%.2lf\n", a[i][n + 1] / a[i][i]);
        }
    }
    //上述操作结束后，矩阵会变成这样
    /*
    k1*a=e1
    k2*b=e2
    k3*c=e3
    k4*d=e4
    */
    //所以输出的结果要记得除以该项系数，消去常数
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n + 1; j++) {
            scanf("%lf", &a[i][j]);//tmd卡精度直接java,
        }
    }
    gauss();
    return 0;
}

```

### 高精度高斯消元

```java
import java.util.*;
import java.math.*;
import java.io.*;
 
public class Main {
	public static void main(String[] args) {
		new Task().main();
	}
}
class fraction {
	BigInteger a, b;
 
	fraction() {
		a = BigInteger.ZERO;
		b = BigInteger.ONE;
	}
 
	fraction(BigInteger a, BigInteger b) {
		this.a = a;
		this.b = b;
	}
 
	fraction add(fraction t) {
		BigInteger d, p, q;
		p = a.multiply(t.b);
		p = p.add(t.a.multiply(b));
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction substract(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.b);
		p = p.subtract(t.a.multiply(b));
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction multiply(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.a);
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction divide(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.b);
		q = b.multiply(t.a);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction abs() {
		return new fraction(a.abs(), b.abs());
	}
 
	int compareTo(fraction t) {
		t = this.substract(t);
		return t.a.compareTo(BigInteger.ZERO);
	}
 
	boolean zero() {
		return a.equals(BigInteger.ZERO);
	}
}
 
class Task {
	Scanner cin = new Scanner(System.in);
	PrintStream cout = System.out;
	fraction[][] f = new fraction[211][211];
	fraction[] x = new fraction[211];
	fraction tmp;
	BigInteger ONE = BigInteger.ONE;
	BigInteger ZERO = BigInteger.ZERO;
	fraction zero = new fraction(ZERO, ONE);
	fraction r, one = new fraction(ONE, ONE);
 
	boolean gauss(int n) {
		int i, j, k, row;
		for (i = 1; i <= n; ++i) {
			row = i;
			for (j = i + 1; j <= n; ++j) {
				if (f[row][i].abs().compareTo(f[j][i].abs()) < 0) {
					row = j;
				}
			}
			if (f[row][i].compareTo(zero) == 0) {
				return false;
			}
			if (row != i) {
				for (k = i; k <= n; ++k) {
					tmp = f[row][k];
					f[row][k] = f[i][k];
					f[i][k] = tmp;
				}
				tmp = x[row];
				x[row] = x[i];
				x[i] = tmp;
			}
			for (j = i + 1; j <= n; ++j) {
				r = f[j][i].divide(f[i][i]);
				f[j][i] = zero;
				for (k = i + 1; k <= n; ++k) {
					f[j][k] = f[j][k].substract(r.multiply(f[i][k]));
				}
				x[j] = x[j].substract(r.multiply(x[i]));
			}
		}
		for (i = n; i >= 1; --i) {
			for (j = i - 1; j >= 1; --j) {
				r = f[j][i].divide(f[i][i]);
				f[j][i] = zero;
				x[j] = x[j].substract(r.multiply(x[i]));
			}
		}
		for (i = 1; i <= n; ++i) {
			x[i] = x[i].divide(f[i][i]);
		}
		return true;
	}
 
	void main() {
		int n, i, j;
		while (cin.hasNext()) {
			n = cin.nextInt();
			for (i = 1; i <= n; ++i) {
				for (j = 1; j <= n; ++j) {
					f[i][j] = new fraction(cin.nextBigInteger(), ONE);
				}
				x[i] = new fraction(cin.nextBigInteger(), ONE);
			}
			boolean ok = gauss(n);
			if (!ok) {
				cout.println("No solution.");
			} else {
				for (i = 1; i <= n; ++i) {
					if (x[i].b.compareTo(ZERO) < 0) {
						x[i].a = x[i].a.negate();//返回负值
						x[i].b = x[i].b.negate();
					}
				}
				for (i = 1; i <= n; ++i) {
					cout.print(x[i].a);
					if (x[i].b.compareTo(ONE) != 0) {
						cout.print("/" + x[i].b);
					}
					cout.println();
				}
			}
			cout.println();
		}
	}
}
```

## 多项式

### 快速傅里叶变换（FFT）

luogu P1919

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4000005;
const double pi = acos(-1);
struct cp {
	double x, y;
	cp(double _x = 0.0, double _y = 0.0) : x(_x), y(_y){}
	cp operator * (const cp &t) const {
		return cp(x * t.x - y * t.y, x * t.y + y * t.x);
	}
	cp operator + (const cp &t) const {
		return cp(x + t.x, y + t.y);
	}
	cp operator - (const cp &t) const {
		return cp(x - t.x, y - t.y);
	}
};
char sa[N], sb[N];
int n = 1, lim = 1, lena, lenb, res[N];
cp a[N], b[N];
int L, R[N];

void fft(cp *a, double f) {
	for(int i = 0; i < lim; i++) {
		if(i < R[i]) swap(a[i], a[R[i]]);
	}
	for(int j = 1; j < lim; j <<= 1) {
		cp T(cos(pi / j), f * sin(pi / j));
		for(int k = 0; k < lim; k += (j << 1)) {
			cp t(1, 0);
			for(int l = 0; l < j; l++, t = t * T) {
				cp Nx = a[k + l], Ny = t * a[k + j + l];
				a[k + l] = Nx + Ny;
				a[k + j + l] = Nx - Ny;
			}
		}
	}
}

int main() {
	scanf("%s%s", sa, sb);
	lena = strlen(sa), lenb = strlen(sb);
	int aa = 0, bb = 0;
	for(int i = lena - 1; i >= 0; i--) {
		a[aa++].x = sa[i] - '0';
	}
	for(int i = lenb - 1; i >= 0; i--) {
		b[bb++].x = sb[i] - '0';
	}
	while(lim < lena + lenb) lim <<= 1, L++;
    for(int i = 0; i <= lim; i++) {
    	R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
	}
    fft(a, 1);
    fft(b, 1);
    for(int i = 0; i <= lim; i++)
        a[i] = a[i] * b[i];
    fft(a, -1);
    for(int i = 0; i <= lim; i++) {
    	res[i] += floor(a[i].x / lim + 0.5);
    	if(res[i] >= 10) {
    		res[i + 1] += res[i] / 10;
    		res[i] %= 10;
    		lim += (i == lim);
		}
	}
	while(!res[lim] && lim >= 1) lim--;
	for(int i = lim; i >= 0; i--) {
		printf("%d", res[i]);
	}
}
```

### 快速数论变换（NTT）待做



## 二次剩余

```c++
ll w;
ll mod;
struct num {
    ll x, y;
};
num mul(num a, num b) {
    num ans = {0, 0};
    ans.x = ((a.x * b.x % mod + a.y * b.y % mod * w % mod) % mod + mod) % mod;
    ans.y = ((a.x * b.y % mod + a.y * b.x % mod) % mod + mod) % mod;
    return ans;
}
ll powwi(num a, ll k) {
    num ans = {1, 0};
    while(k) {
        if(k & 1) ans = mul(ans, a);
        a = mul(a, a);
        k >>= 1;
    }
    return ans.x % mod;
}
ll powmod(ll a, ll b) {
    ll res = 1;
    a = a % mod;
    while(b) {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
ll solve(ll n) { 
    n %= mod;
    if(mod == 2) return n;
    if(powmod(n, (mod - 1) / 2) == mod - 1) return -1;
    ll a;
    while(1) {
        a = rand() % mod;
        w = ((a * a % mod - n) % mod + mod) % mod;
        if(powmod(w, (mod - 1) / 2) == mod - 1) break;
    }
    num x = {a, 1};
    return powwi(x, (mod + 1) / 2);
}
int main() {
	srand(time(0));
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld%lld", &n, &mod);
        if(!n) {
        	printf("0\n");
			continue;
		}
        ll ans1 = solve(n), ans2;
        if(ans1 == -1) printf("不存在\n");
        else {
            ans2=mod - ans1;
            if(ans1 > ans2) swap(ans1,ans2);
            if(ans1 == ans2) printf("%lld\n",ans1);//解相等 
            else 
				printf("%lld %lld\n",ans1, ans2);
        }
    }
}

```

## 高次同余方程



```c++
//给定y,z,p，计算满足Y^x = Z(mod P)的最小非负整数
ll bsgs(ll a, ll b, ll p) {
    map<int, int> H;
    H.clear();
    b %= p;
    int t = (int)sqrt(p) + 1;
    for (int i = 0; i < t; i++) {
        int val = (ll)b * powmod(a, i, p) % p;
        H[val] = i;
    }
    a = powmod(a, t, p);
    if (!a) return b ? -1 : 1;
    for (int i = 0; i <= t; i++) {
        int val = powmod(a, i, p);
        int j = H.find(val) == H.end() ? -1 : H[val];
        if(j >= 0 && i * t >= j)
            return i * t - j;
    }
    return -1;
}

```

## 同余不等式

$$
L\leqslant Dx\ \% \ mod \leqslant R
\\L\leqslant Dx-My \leqslant R
\\y == 0 时直接求解
\\y\ !=0时有 : Dx-R<= My <= Dx-L ,y 越小则 x 越小 
\\不等式同模 D 
\\得 (-R)\%D \leqslant (M\%D)*y\%D \leqslant (-L)\%D
\\ 递归求解
$$



```c++
ll find(ll m, ll d, ll l, ll r) {
    if (!d || l > r)
        return -1;
    if (r / d * d >= l)
        return (l - 1) / d + 1;
    ll x = find(d, m % d, ((-r) % d + d) % d, ((-l) % d + d) % d);
    if (x == -1)
        return -1;
    return (l - 1 + x * m) / d + 1;
}
int main() {
    int n;
    ll x, y, m, d, l, r;
    scanf("%d", &n);
    while (n--) {
        scanf("%lld%lld%lld%lld", &m, &d, &l, &r);
        r = min(m - 1, r);
        printf("%lld\n", find(m, d, l, r));
    }
}
```

## 数论分块

对于式子$\displaystyle\sum_{i=1}^{min(n,m)}\lfloor n/i \rfloor\lfloor m/i \rfloor$,有如下解法

```c++
	int r, res = 0;
	for(int l = 1; l <= min(n, m); l = r + 1) {
        r = min(n / (n / l), m / (m / l));
    	res += (n / l) * (m / l);
    }
```

如果式子带了某些参数，计算前缀和或者2累加公式等等。

## 莫比乌斯反演

$$
\begin{aligned}
\\&单位函数：\epsilon(n)=\displaystyle\sum_{d|n}\mu(d)=[n=1] 
\\&恒等函数：id_k(n)=n^k
，id_1(n)记作id(n)
\\&除数函数：\sigma_k(n)=\displaystyle\sum_{d|n}d^k,\sigma_0(n)简写为d(n)。\sigma(n)=\displaystyle\sum_{d|n}d,d(n)=\displaystyle\sum_{d|n}1
\\&常数函数：1(n)=1
\\&欧拉函数：\varphi(n)=\displaystyle\sum_{i=1}^n[gcd(i,n)=1]=\displaystyle\sum_{d|n}d·\mu(\frac{n}{d})
\\&莫比乌斯函数：\mu(n)=
	\begin{cases}
	1& \text{$n=1$}\\
	0& \text{$d^2|n, d > 1$,即没有一个因数有两个以上}\\
	(-1)^x& \text{$x=\displaystyle\sum_{d|n}1$，即为所有不同质因子数}
	\end{cases}
	\\ &[gcd(i,j)=1]->\displaystyle\sum_{d|gcd(i,j)}\mu(d)
\end{aligned}
$$
卷积：
$$
\begin{aligned}
\\&f(n)=\sum_{d|n}g(d) ->g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})     
\\&f(n)=\sum_{n|d}g(d) ->g(n)=\sum_{n|d}\mu(\frac{n}{d})f(d)      \\&(f=g*1 ->g = f * \mu)
\end{aligned}
$$

常用式子：
$$
\begin{aligned}
 \\ \varepsilon=\mu \ast 1&\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)
 \\ d=1 \ast 1&\iff d(n)=\sum_{d\mid n}1
 \\ \sigma=\operatorname{id} \ast 1&\iff\sigma(n)=\sum_{d\mid n}d
 \\ \varphi=\mu \ast \operatorname{id}&\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d})
\\ \varphi*1&=id（1+4得到）
 \end{aligned}
$$


一些公式：
$$
\begin{aligned}
\\&d(n)为约数个数，d(ij)=\displaystyle\sum_{x|i}\displaystyle\sum_{y|j}[gcd(x,y)=1]
\\
\end{aligned}
$$


$\mu(n)$的筛法：

```c++
bool notp[N];
int prime[N], pnum;
int mu[N];
void sieve() {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    mu[1] = 1;
    pnum = 0;
    for(int i = 2; i < N; i++) {
        if(!(notp[i])) prime[++pnum] = i, mu[i] = -1;
        for(int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                mu[prime[j] * i] = 0;
                break;
            }
            else {
                 mu[prime[j] * i] = -mu[i];
            }
        }
    }
    for(int i = 1; i < N; i++) mu[i] += mu[i - 1];//前缀
}
```

## 杜教筛

$$
\begin{aligned}
\\&\sum_{i=1}^{n}\sum_{d \mid i}f(d)g\left(\frac{i}{d}\right)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
\\& \Leftrightarrow \sum_{i=1}^{n}(f\ast g)(i)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right) (★)
\\&S(n)=\displaystyle\sum_{i=1}^nf(i)
\\&g(1)S(n)=\displaystyle\sum_{i=1}^{n}(f*g)(i)-\displaystyle\sum_{i=2}^{n}g(i)*S(\lfloor\frac{n}{i}\rfloor)(★)

\end{aligned}
$$

做题时，将$\displaystyle\sum_{i=1}^{n}(f*g)(i)$尽可能化为常数，对后面先线性筛预处理，再进行分块和记忆化。



# 数学

## 蔡勒公式（1582以后）

```c++
int WhatDay(int year, int month, int dday) {//0是周日，1是周一，6是周六
    if(month < 3) {
        year -= 1; month += 12;
    }
    int c=int(year / 100), y = year - 100 * c;
    int w=int(c / 4) - 2 * c + y + int(y / 4) + (26 * (month + 1) / 10) + dday - 1;
    w = (w % 7 + 7) % 7;
    return w;
}
```

## 逆波兰

```c++
/**
样例输入
2
1.000+2/4=
((1+2)*5+1)/4=
样例输出
1.50
4.00
*/
#include <bits/stdc++.h>
using namespace std;
int Judge(char ch) {
    //运算符进行优先级划分
    if(ch == '+') return 1;
    if(ch == '-') return 1;
    if(ch == '*') return 2;
    if(ch == '/') return 2;
    if(ch == '(') return 0;
    if(ch == ')') return 0;
}
int main() {
    string str;
    string s;
    int count ;
    cin>>count;
    while(count--) {
        int i=0 ;
        str.clear();
        s.clear() ;
        cin>>str;
        stack<char>mid; //字符串栈 ，用于中缀表达式转后缀表达式
        stack<double>ans;//数字栈 ，用于后缀表达式求值
        while(str[i] != '=') {
            if(str[i] == '(') {//判断，左括号进栈
                mid.push(str[i]);
                i++;
            }
            else if( str[i] == ')') {//遇右括号则将左括号及左括号以上标识符出栈
                while(mid.top()!='(') {
                    s = s + mid.top() ;
                    s += ' ';
                    mid.pop() ;
                }
                mid.pop() ;
                i++;
            }
            else if(isdigit(str[i])) {//数字或小数点则直接转入后缀表达式
                while(str[i]<='9'&&str[i]>='0' || str[i] =='.') {
                    s = s + str[i];
                    i++;
                }
                s += ' ';
            }
            else if(str[i] == '+'||str[i] == '-'||str[i] == '*'||str[i] == '/') {
                while(!mid.empty() && Judge(mid.top()) >= Judge(str[i])) {
                //当前运算标识符优先级低于栈顶元素，进行出栈操作
                    s = s + mid.top();
                    s = s + ' ';
                    mid.pop();
                }
                mid.push(str[i]);//将当前运算符进栈
                i++;
            }
        }
        while(!mid.empty()) {//将最后剩余运算符出栈
            s = s + mid.top() ;
            s = s + ' ';
            mid.pop() ;
        }
        string temp;
        stringstream ss(s);
        char a[1000];
        double num;
        while(ss>>temp) {
            if(isdigit(temp[0])) {
                for(i = 0; i < temp.length(); i++)
                    a[i] = temp[i];
                a[i] ='\0';//最后必须赋 '\0' 否则报错
                num = atof(a);
                //将数字字符串转为数字
                //注意atof()函数不支持string类型，支持char()
                ans.push(num);//将数字进栈
            }
            else {// 运算符操作
                double x,y;
                x = ans.top();
                ans.pop();
                y = ans.top();
                ans.pop();
                //取出栈顶两位元素 ，进行相应操作
                if(temp == "+") num = x + y;
                if(temp == "-") num = y - x;
                if(temp == "*") num = x * y;
                if(temp == "/") num = y / x;
                ans.push(num);//得到元素进栈
            }
        }
        cout<< fixed <<setprecision(2)<<ans.top()<<endl;//输出两位小数；
    }
}
```

## 求和公式

$$
\\平方和公式 n * (n + 1) * (2n + 1) / 6
\\立方和公式 (1 + 2 + 3 + .. + n)^2 
\\四次方 (n^8 - 1) / 15
$$

## 组合数学

### 递推式$C_n^m=C_{n-1}^{m-1}+C_{n-1}^{m}$

```c++
//递推式
int c[N][N];
void init() {
	for(int i = 0; i < N; i++) {
		c[i][0] = c[i][1] = 1;
		for(int j = 1; j < i; j++) {
			c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
		}
	}
} 
```

### 公式法$C_n^m=\frac{n!}{(n-m)!m!}$

```c++
ll powmod(ll a, ll b){
	ll res = 1;
	a %= mod;
	while(b) {
		if(b & 1) {
			res = res * a % mod;
		}
		b >>= 1;
		a = a * a % mod;
	}
	return res % mod;
}
ll fac[N], inv[N];
void init() {
	fac[0] = 1;
	for(int i = 1; i < N; i++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	inv[N - 1] = powmod(fac[N - 1], mod - 2);
	for(int i = N - 2; i >= 0; i--) {
		inv[i] = inv[i + 1] * (i + 1) % mod;
	}
}
ll c(ll n, ll m) { // 数据范围很大不够 
	if(m > n) {
		return 0;
	}
	if(m == 0) return 1;
	if(n < N) return fac[n] * inv[m] % mod * inv[n - m] % mod;
	//c(m,k) = m!/(k! * (m - k))= m-k+1~m/(k!)
	ll res = inv[m];
	for(int i = n - m + 1; i <= n; i++) {
		res = res * i % mod;
	}
	return res;
} 
```

### Lucas(n, m 较大， mod较小且为素数 )

```c++
ll lucas(ll n, ll m) {
	if(m == 0) {
		return 1;
	}
	else {
		return c(n % mod, m % mod) * lucas(n / mod, m / mod) % mod;
	}
}
```

### 母函数

$$
\begin{aligned}
&母函数公式:
\\&组合问题:G(x)=\sum a_ix^i
\\&排列问腿:G(x)=\sum a_i\frac{x^i}{i!}

\\&G(x)=\frac{1}{1-x}=1+x+x^2+x^3+x^4+…
\\&G^n(x)=\displaystyle\sum_{k=0}^{\infty}C_{n+k-1}^k*x^k
\\&排列问题的第n项再乘上n！
\end{aligned}
$$

排列代码如下（需求解方程）：

```c++
		vector<double> res(m + 1);//res
		vector<int> h(n + 1);//shuju
		vector<double> tmp(m + 1);
		vector<double> st(m + 1);
		for(int i = 1; i <= n; i++) {
			scanf("%d", &h[i]);
			if(i == 1) {
				for(int j = 0;j <= min(h[i], m); j++) {
					res[j] = 1.0 / fac[j];
				}
				continue;
			}
			for(int j = 0; j <= m; j++) {
				for(int k = 0; k <= h[i] && j + k <= m; k++) {
					tmp[j + k] += res[j] / fac[k];
				}
			}
			res = tmp;
			tmp.clear();
			tmp = st; 
		}
		printf("%.0f\n", res[m] * fac[m]);
```

### 二项式反演

$$
f(n)=\sum(-1)^{i}*C_n^i*g(i)
\\g(n)=\sum(-1)^{i}*C_n^i*f(i)
\\常用：f(n)=\sum C_n^i*g(i)
\\	->g(n)=\sum(-1)^{n-i}*C_n^i*f(i)
$$

### 各种数

#### 卡特兰数

$$
\\卡特兰数前n项 :1\ 1\ 2\ 5\ 14\ 42\ 132\ 429\ 1430\ 4862
\\f(n)=f(0)*f(n-1)+...+f(n-1)*f(0) \ \ n \geqslant2
\\f(n)=\frac{4n-2}{n+1} f(n-1)
\\f(n)=\frac{1}{n+1} * C(2n,n)
\\f(n)=C(2n,n)-C(2n,n-1)
$$

#### 待续

# 几何

## 运算重载

```c++
struct point {
    double x, y;
    point(double x = 0, double y = 0) : x(x), y(y) {}
    point operator + (const point &t) const {
        return point(x + t.x, y + t.y);
    } //a + b
    point operator - (const point &t) const {
        return point(x - t.x, y - t.y);
    } //a - b
    double operator * (const point &t) const {
        return x * t.x + y * t.y;
    } //a * b
    double operator ^ (const point &t) const {
        return x * t.y - y * t.x;
    } //a X b
    double dis(const point &t) {
        return sqrt((x - t.x) * (x - t.x) + 
					(y - t.y) * (y - t.y));
    }
	point eotate(const point &o, double angle) {//绕p点逆时针转angle角度 
		return point(o.x + (x - o.x) * cos(angle) - (y - o.y) * sin(angle),
					o.y + (x - o.x) * sin(angle) + (y - o.y) * cos(angle));
	}
};
```
## 基本公式

### 外心

```c++
inline point waixin(const point& a, const point& b, const point& c) {
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) * 0.5;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) * 0.5;
    double d = a1 * b2 - a2 * b1;
    point ans;
    ans.x = a.x + (c1 * b2 - c2 * b1) / d;
    ans.y = a.y + (a1 * c2 - a2 * c1) / d;
    return ans;
}

```

### 将a,b两个点向内移动距离d 

```c++
void reset(point a,point b,point &t1,point &t2,double d) {
	double db = a.dis(b); 
	double dx = (a.y - b.y) * d / db;
	t1.x = a.x + dx, t2.x = b.x + dx;
	double dy = (b.x - a.x) * d / db;
	t1.y = a.y + dy, t2.y = b.y + dy;
}
```

## 叉积

```c++
double cross(point a, point b, point c) {
	return (b - a) ^ (c - a);//ab X ac  >0逆时针, <0 顺时针 
}
```
### 多边形面积计算

```c++
double getarea(int n) {
    if (n < 3)
        return 0;
    int i;
    double res = 0;
    for (i = 2; i < n; i++) {
        res += fabs(cross(xp[s[0]], xp[s[i - 1]], xp[s[i]]) / 2.0);
    }
    return res;
}//小于0说明c在ab右侧
```

## 极角排序

### atan2函数计算（时间短，精度低） 

```c++
struct point {
    double x, y;
    double angle;
    bool operator < (const point &t) {
        return angle < t.angle;
    }
} p[N];
bool cmp(point a, point b) {
    if (a.angle == b.angle)
        return a.x < b.x;
    else {
        return a.angle < b.angle;
    }
}
for (int i = 1; i <= n; i++) {
    cin >> p[i].x >> p[i].y;
    p[i].angle = atan2(p[i].y, p[i].x);
}
sort(a + 1, a + 1 + n, cmp);

```

### 叉积计算极角（精度高，时间长）

```c++
 double cross(point a, point b, point c) {//计算极角 ab × ac
    return (b - a) ^ (c - a);
}
bool cmp(point a, point b) {
    double f = cross(p[pos], a, b);
    if (f == 0)
        return a.x - p[pos].x < b.x - p[pos].x;
    else if (f > 0)
        return true;
    else
        return false;
}
//如果取的点不是边角要先按照象限排序 
int Quadrant(point a) //象限排序，注意包含四个坐标轴
{
    if (a.x > 0 && a.y >= 0)
        return 1;
    if (a.x <= 0 && a.y > 0)
        return 2;
    if (a.x < 0 && a.y <= 0)
        return 3;
    if (a.x >= 0 && a.y < 0)
        return 4;
}
bool cmp2(point a, point b) //先象限后极角
{
    if (Quadrant(a) == Quadrant(b)) //返回值就是象限
        return cmp(a, b);
    else
        Quadrant(a) < Quadrant(b);
}
```

## 凸包

### 一般凸包

```c++
bool cmp(point a, point b) {
    double f = (a - xp[0]) ^ (b - xp[0]); //与左下边界点的极角
    if (fabs(f) < eps)
        return a.x - xp[0].x < b.x - xp[0].x; //相等按距离排序
    else if (f > 0)
        return true;
    else
        return false;
}
void graham() {
    for (int i = 0; i < pnum; i++) {//pnum为内部点的数目
        if (xp[i].y < xp[0].y || (xp[i].y == xp[0].y && xp[i].x < xp[0].x)) //找到左下方点
            swap(xp[0], xp[i]);
    }
    sort(xp + 1, xp + pnum, cmp);
    if (pnum == 1)
        stack[0] = 0, top = 0; //建栈 找凸包
    else if (pnum == 2)
        stack[0] = 0, stack[1] = 1, top = 1;
    else {//内树大于三个
        stack[0] = 0, stack[1] = 1;
        top = 1;
        for (int i = 2; i < pnum; i++) {
            while (top > 0 && ((xp[stack[top]] - xp[stack[top - 1]]) ^ (xp[i] - xp[stack[top - 1]])) <= 0) {//栈顶的点在当前点和前一个点的连线左侧
                top--;
            }
            stack[++top] = i;
        }
    }
} ///栈里为从左下开始的组成凸包的点

```

### 最大空凸包

```c++
#define N 105
struct point{
   
} p[N], xp[N], O;
int n, pnum;
double dp[N][N], ans;
bool cmp(const point &a, const point &b) {
    double f = (a - O) ^ (b - O); //与左下边界点的极角
    if (f == 0)
        return O.dis(a) < O.dis(b); //相等按距离排序
    else if (f > 0)
        return true;
    else
        return false;
}
void solve() {
    memset(dp, 0, sizeof(dp));
    sort(xp + 1, xp + pnum + 1, cmp);
    for (int i = 1; i <= pnum; i++) {
        int j = i - 1;
        while (j && !((xp[i] - O) ^ (xp[j] - O)))
            j--;
        bool bz = (j == i - 1); //bz==0 为当前为边，==1为当前为顶点
        while (j) {
            int k = j - 1;
            while (k && ((xp[i] - xp[k]) ^ (xp[j] - xp[k])) > 0)
                k--;
            double area = fabs((xp[i] - O) ^ (xp[j] - O)) / 2.0;
            if (k)
                area += dp[j][k];
            if (bz)
                dp[i][j] = area;
            ans = max(ans, area), j = k;
        }
        if (bz) {
            for(int j = 1; j < i; j++)
                dp[i][j] = max(dp[i][j], dp[i][j - 1]);
        }
    }
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        ans = 0;
        for (int i = 1; i <= n; i++) {
            scanf("%lf %lf", &p[i].x, &p[i].y);
        }
        for(int i = 1; i <= n; i++) {
            O = p[i], pnum = 0;
            for (int j = 1; j <= n; j++) {
                if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {
                    xp[++pnum] = p[j];
                }
            }
            solve();
        }
        printf("%0.1f\n", ans);
    }
}

```

## 半平面交

### 存点

```c++
//可求最大内接圆，最大半平面交面积
struct point {
    
} p[N], xp[N];
struct line {
    point s, e;
    double k;
    line() {}
    line(point a, point b) { s = a, e = b, k = atan2(b.y - a.y, b.x - a.x); }
    point operator & (const line &b) const { //求两直线交点 
        point res = s;
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));
        res.x += (e.x - s.x) * t;
        res.y += (e.y - s.y) * t;
        return res;
    }
};
int n;
int ans_s; //相交点数
line L[N], q[N];
point ans[N]; //存点
bool cmp(line a, line b) {
    if (fabs(a.k - b.k) <= eps)
        return ((a.s - b.s) ^ (b.e - b.s)) < 0; //平行取下
    return a.k < b.k;
}
void Hpi() {//保证多边形逆时针建边
    int tot = 1;
    sort(L, L + n, cmp);
    for (int i = 1; i < n; i++) {
        if (fabs(L[i].k - L[i - 1].k) > eps) {
            L[tot++] = L[i];
        } //因为平行的时候，左边的线段先判断，所以可以去除无效判定
    }
    int l = 0, r = 1;
    q[0] = L[0];
    q[1] = L[1]; //模拟双端 ，每条线取左删右（顺时针建边取右删左）
    for (int i = 2; i < tot; i++) {
        if (fabs((q[r].e - q[r].s) ^ (q[r - 1].e - q[r - 1].s)) <= eps ||
            fabs((q[l].e - q[l].s) ^ (q[l + 1].e - q[l + 1].s)) <= eps)
            return;               //半平面交不存在
        while (l < r && (((q[r] & q[r - 1]) - L[i].s) ^ (L[i].e - L[i].s)) > eps) 
            //上一个交点在下一条线的右侧，不在半平面交上
            r--;
        while (l < r && (((q[l] & q[l + 1]) - L[i].s) ^ (L[i].e - L[i].s)) > eps) // 同上
            l++;
        q[++r] = L[i]; //加入新边
    }
    while (l < r && (((q[r] & q[r - 1]) - L[l].s) ^ (L[l].e - L[l].s)) > eps)
        r--;
    while (l < r && (((q[l] & q[l - 1]) - L[r].s) ^ (L[r].e - L[r].s)) > eps)
        l++;
    if (r <= l + 1)
        return; //如果只有2个或以下的点，构不成平面
    for (int i = l; i < r; i++) {
        ans[ans_s++] = q[i] & q[i + 1];
    } //ans里存交点
    ans[ans_s++] = q[l] & q[r];
}

```

### 判是否有解

```c++
#define N 110
#define eps 1e-8
#define inf 0x3f3f3f3f3f3f
struct node {
    double u, v, w;
} k[N];
struct point {
    
} p[N];
double dist(point a, point b) {
    return sqrt((a - b) * (a - b));
}
int n, pnum;
point q[N];
int top = 0;
point cross_p(point x, point y, double a, double b, double c) {
//求两个点x,y和该线的交点
    point ans;
    double a2 = y.y - x.y;
    double b2 = x.x - y.x;
    double c2 = x.y * y.x - y.y * x.x; //连接x,y的线段的a,b,c
    ans.y = (a * c2 - a2 * c) / (a2 * b - a * b2);
    ans.x = (b * c2 - b2 * c) / (b2 * a - b * a2);
    return ans;
}
void Hpi(double a, double b, double c) {
    top = 0;
    for (int i = 1; i <= pnum; i++) {
        if (a * p[i].x + b * p[i].y + c <= eps) {//如果上一个边界点满足，则记录
            q[++top] = p[i];
        }
        else {
            if (a * p[i - 1].x + b * p[i - 1].y + c <= eps) {
                //该节点不满足，但上一节点满足
                q[++top] = cross_p(p[i - 1], p[i], a, b, c); 
                //加入两个节点的连线与该线的交点
            }
            if (a * p[i + 1].x + b * p[i + 1].y + c <= eps) {
                //该节点不满足，但下一节点满足    
                q[++top] = cross_p(p[i], p[i + 1], a, b, c);
            }
        }
    }
    for (int i = 1; i <= top; i++)
        p[i] = q[i]; //将更新好的点集返回p
    p[top + 1] = p[1], p[0] = p[top];
    pnum = top;
}
bool solve(int id) {
    p[1] = point(0, 0);
    p[2] = point(inf, 0);
    p[3] = point(inf, inf);
    p[4] = point(0, inf);
    p[0] = p[4], p[5] = p[1];
    pnum = 4; //初始边界为第一象限四个边界点，所以起始点为4个
    double a, b, c;
    for (int i = 1; i <= n; i++) {
        if (i != id && k[id].u <= k[i].u && k[id].v <= k[i].v && k[id].w <= k[i].w)
            return 0; //如果有人3项多比他强，肯定达不到
        if (i == id)
            continue;
        a = (k[i].u - k[id].u) / (k[id].u * k[i].u);
        b = (k[i].v - k[id].v) / (k[id].v * k[i].v);
        c = (k[i].w - k[id].w) / (k[id].w * k[i].w); //得出ax+by=c
        Hpi(a, b, c);
        if (pnum < 3)
            return 0; //如果最后交点数<3，即无法构成平面
    }
    return pnum >= 3;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf%lf%lf", &k[i].u, &k[i].v, &k[i].w);
    for (int i = 1; i <= n; i++) {
        if (solve(i))
            printf("Yes\n");
        else
            printf("No\n");
    }
}
```

# 数据结构（一丢丢）

## 分块

```c++
int block, belong[N], num, l[N], r[N], n, q;
ll a[N], lazy[N];
ll v[N];
/*
block:块的大小
belong ： 属于哪一块
num：块的数量
l，r 左右边界 
*/
void build() {
	memset(lazy, 0, sizeof(lazy));
	memset(belong, 0, sizeof(belong));
	block = sqrt(n);
	num = (n + block - 1) / block;
	for(int i = 1; i <= num ; i++) {
		l[i] = (i - 1) * block + 1;
		r[i] = i * block;
	}
	r[num] = n;
	for(int i = 1; i <= n; i++) {
		belong[i] = (i - 1) / block + 1;
		v[belong[i]] += a[i];
	}
}
void update(int x, int y, ll c) {
	if(belong[x] == belong[y]) {
		for(int i = x; i <= y; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
	}
	else {
		for(int i = x; i <= r[belong[x]]; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
		for(int i = belong[x] + 1; i < belong[y]; i++) {
			lazy[i] += c;
		}
		for(int i = l[belong[y]]; i <= y; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
	}
}
ll ask(int x, int y, ll c) {
	int res = 0;
	if(belong[x] == belong[y]) {
		for(int i = x; i <= y; i++) {
			res = (res + a[i] + lazy[belong[x]]) % (c + 1);
		}
		return res % (c + 1);
	}
	else {
		for(int i = x; i <= r[belong[x]]; i++) {
			res = (res + a[i] + lazy[belong[i]]) % (c + 1);
		}
		for(int i = belong[x] + 1; i < belong[y]; i++) {
			res = (res + v[i] + lazy[i] * block % (c + 1)) % (c + 1);
		}
		for(int i = l[belong[y]]; i <= y; i++) {
			res = (res + a[i] + lazy[belong[i]]) % (c + 1);
		}
		return res;
	}
}
```