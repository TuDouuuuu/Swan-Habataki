[TOC]

# 基础操作

## fread快读

```c++
char buf[100000],*p1=buf,*p2=buf;
inline char nc(){
    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;
}
inline bool read(int & x){
    char c=nc();x=0;
    if(c==EOF) return false;
    for(;!isdigit(c);c=nc());
    for(;isdigit(c);x=x*10+c-'0',c=nc());
    return true;
}
inline bool read(ll & x){
    char c=nc();x=0;
    if(c==EOF) return false;
    for(;!isdigit(c);c=nc());
    for(;isdigit(c);x=x*10+c-'0',c=nc());
    return true;
}
```




## STL

### bitset

```c++
/*
C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，
它的每一个元素只能是０或１，每个元素仅用１bit空间。
*/
//-------------构造方法-------------
bitset<4> bitset1;　　//无参构造，长度为４，默认每一位为０
bitset<8> bitset2(12);　　//长度为８，二进制保存，前面用０补充
string s = "100101";
bitset<10> bitset3(s);　　//长度为10，前面用０补充
char s2[] = "10101";
bitset<13> bitset4(s2);　　//长度为13，前面用０补充
cout << bitset1 << endl;　　//0000
cout << bitset2 << endl;　　//00001100
cout << bitset3 << endl;　　//0000100101
cout << bitset4 << endl;　　//0000000010101
//--------------可用函数-------------
bitset<8> foo ("10011011");

cout << foo.count() << endl;　　//5　　count函数用来求bitset中1的位数
cout << foo.size() << endl;　　 //8　　size函数用来求bitset的大小

cout << foo.test(0) << endl;　　//true　　test函数用来查下标处的元素是０还是１
cout << foo.test(2) << endl;　　//false　

cout << foo.any() << endl;　　//true　　any函数检查bitset中是否有１
cout << foo.none() << endl;　　//false　　none函数检查bitset中是否没有１
cout << foo.all() << endl;　　//false　　all函数检查bitset中是全部为１


bitset<8> foo ("10011011");

cout << foo.flip(2) << endl;　　//10011111　　flip函数传参数时，用于将参数位取反
cout << foo.flip() << endl;　　 //01100000　　flip函数不指定参数时，将bitset每一位全部取反

cout << foo.set() << endl;　　　　//11111111　　set函数不指定参数时，将bitset的每一位全部置为１
cout << foo.set(3,0) << endl;　　//11110111　　set函数指定两位参数时，将第一参数位的元素置为第二参数的值
cout << foo.set(3) << endl;　　  //11111111　　set函数只有一个参数时，将参数下标处置为１

cout << foo.reset(4) << endl;　　//11101111　　reset函数传一个参数时将参数下标处置为０
cout << foo.reset() << endl;　　 //00000000　　reset函数不传参数时将bitset的每一位全部置为０



bitset<8> foo ("10011011");

string s = foo.to_string();　　//将bitset转换成string类型
unsigned long a = foo.to_ulong();　　//将bitset转换成unsigned long类型
unsigned long long b = foo.to_ullong();　　//将bitset转换成unsigned long long类型

cout << s << endl;　　//10011011
cout << a << endl;　　//155
cout << b << endl;　　//155
```



## 二进制枚举

```c++
for(int i=0;i<(1<<n);i++) {//n个物品取或不取
    for(int j=0;j<n;j++) {
        if( i & (1<<j) ) {//取 
            
        }
        else {//不取
              
        }
    }
 } 
```

## 高效位运算 _builtin_函数

```c++
int __builtin_ffs (unsigned int x)
//返回x的最后一位1的是从后向前第几位，比如7368（1110011001000）返回4。
int __builtin_clz (unsigned int x)
//返回前导的0的个数。
int __builtin_ctz (unsigned int x)
//返回后面的0个个数，和__builtin_clz相对。
int __builtin_popcount (unsigned int x)
//返回二进制表示中1的个数。
int __builtin_parity (unsigned int x)
//返回x的奇偶校验位，也就是x的1的个数模2的结果。
//
//此外，这些函数都有相应的usigned long和usigned long long版本，
//只需要在函数名后面加上l或ll就可以了，比如int __builtin_clzll。
```

## 矩阵

```c++
ll powmod(ll a, ll b) {
    ll res = 1;
    a = a % mod;
    while(b) {
        if(b & 1) {
            res = res * a % mod;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return res % mod;
}
ll inv(ll p) {
    return powmod(p, mod - 2);
}
ll is[N], js[N];
class mat {
public:
    int n,m;
    ll v[N][N];
    mat(int n,int m) : n(n), m(m){memset(v, 0, sizeof(v));}
    void init() {   
        memset(v, 0, sizeof(v));
    }
    void init1() {
        for(int i = 0; i < N; i++)
            for(int j = 0; j < N; j++)
                v[i][j] = (i == j); //单位矩阵
    }
    mat operator * (const mat B) const {//矩阵乘法 A(n,k)*B(k,m)=C(n,m);
        mat C(n, B.m);
        C.init();
        for(int i = 1; i <= n; i++)
        for(int j = 1; j <= B.m; j++)
        for(int k = 1; k <= m; k++)
            C.v[i][j] = (C.v[i][j] + v[i][k] * B.v[k][j]) % mod;//Mod
        return C;
    }
    //矩阵快速幂 n=m时可用
    mat operator ^ (int t) {
        mat ans(n, n), now(n, n);
        ans.init1();
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                now.v[i][j] = v[i][j];
        while(t > 0) {
            if(t & 1) ans = ans * now;
            now = now * now;
            t >>= 1;
        }
        return ans;
    }
     // 转置
    void change() { 
    	swap(n, m);
		for(int i = 1; i <= max(n, m); i++) {
			for(int j = i + 1; j <= max(n, m); j++) {
				swap(v[i][j], v[j][i]);
			}
		} 
	} 
    // 逆矩阵 
	void Minv() {  
		for(int k = 1; k <= n; k++) {
	        for(int i = k; i <= n; i++) // 1
	            for(int j = k; j <= n; j++)
	                if(v[i][j]) {
	                    is[k] = i;
	                    js[k] = j;
	                    break;
	                }
	        for(int i = 1; i <= n; i++) // 2
	            swap(v[k][i], v[is[k]][i]);
	        for(int i = 1; i <= n; i++)
	            swap(v[i][k], v[i][js[k]]);
	        v[k][k] = inv(v[k][k]); // 3
	        for(int j = 1; j <= n; j++)
	            if(j != k) // 4
	            	v[k][j] = v[k][j] * v[k][k] % mod;
	        for(int i = 1; i <= n; i++)
	            if(i != k) // 5
	            for(int j = 1; j <= n; j++)
	                if(j != k)
	                    v[i][j] = (v[i][j] + mod - v[i][k] * v[k][j] % mod) % mod;
	        for(int i = 1; i <= n; i++)
	            if(i != k)
	            v[i][k] = (mod - v[i][k] * v[k][k] % mod) % mod;
	    }
	    for(int k = n; k; k--) { // 6
	        for(int i = 1; i <= n; i++)
	            swap(v[js[k]][i], v[k][i]);
	        for(int i = 1; i <= n; i++)
	            swap(v[i][is[k]], v[i][k]);
	    }
	}
};
```

## 状态压缩

```c++
//判断一个数字x二进制下第i位是不是等于1,反之为0
if(((1 << i) & x) > 0)

//将一个数字x二进制下第i位更改成1
x=x | (1 << i)

//将一个数字x二进制下第i位更改成0
x=x ^ i(1 << i);

//把一个数字二进制下最靠右的第一个1去掉  
x=x & (x − 1)
```

## java大数

### 开头

```java
import java.io.*;
import java.math.*;
import java.util.*;
import java.text.DecimalFormat;
public class Main {
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
      	DecimalFormat df=new DecimalFormat("0.00");//小数保留2位
      //System.out.println(df.format(a));
    	while(cin.hasNext()){
          BigDecimal a= cin.nextBigDecimal();
        }//多组输入
    }
}
```

### 四则运算

```java
/*
加		a+b: a=a.add(b);
减		a-b: a=a.subtract(b); 
乘		a*b: a=a.multiply(b);
除		a/b: a=a.divide(b);
求余	    a%b: a=a.mod(b);
绝对值		abs a=a.abs();
转换		a=b: b=BigInteger.valueOf(a);
比较		a.compareTo(b)  =-1,a<b;
				   	 	        =0,a=b;
						          =1,a>b;
a.equals(b)   a==b返回ture
a.mod(b)　　//求余数即a%b
a.gcd(b) 　　//求最大公约数
a.max(b)　　//求最大值
a.min(b) 　　//求最小值
a.pow(b)　　//求a^b的大数
*/
public class Main {
	public static void main(String[] args) {
		Scanner cin = new Scanner(System.in);
      	BigInteger a;
      	BigInteger b;
      	BigInteger t1=new BigInteger(1);
      	BigInteger t2=new BigInteger("12313");
      	int t=5;
      	BigInteger t3=BigInteger.valueOf(t);//t3=5;
      	BigDecimal d=new BigDecimal(5.3435345);
      	BigInteger dd=d.toBigInteger();//小数型转整形无四舍五入//d=5;
        BigInteger []s = new BigInteger[4040];//初始化一个4040的大数数组
    }
}
```

### 判大素数

```java
BigInteger x;
x=cin.nextBigInteger();
if(x.isProbablePrime(1))
    System.out.println("Yes");
else
    System.out.println("No");
```

### 大数二分

```c++
//这是将sqrt（5）精确到100位的二分			
BigDecimal d=new BigDecimal(5);
BigDecimal eps=new BigDecimal("0.00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 00000 01");//（100个0）
BigDecimal l=new BigDecimal("2.236067977499789696");
BigDecimal r=new BigDecimal("2.236067977499789697");
BigDecimal mid;
BigDecimal t1=new BigDecimal(1);
BigDecimal t2=new BigDecimal(2);
while(l.multiply(l).subtract(d).abs().compareTo(eps)==1)
{
	mid=l.add(r).divide(t2);
	if(mid.multiply(mid).compareTo(d)<0)
	{
		l=mid;
	}
	else r=mid;
}
```

# 数论

## 数论四大定理

### 威尔逊定理

​								当$p$质数的时：$(p-1)!\equiv(p-1)(mod \  p)$

### 费马小定理

假如p是质数，若p不能整除a，则 $a^{p-1}\equiv1(mod\ p)$，若p能整除a，则$a^{p-1}\equiv0(mod\ p)$。

或者说，若p是质数，且a, p互质，那么 a的(p-1)次方除以p的余 数恒等于 1

### 欧拉定理

​								当$gcd(a,n)=1$,有$a^{phi(n)}\equiv1(mod\ n)$



#### 单个值欧拉

```c++
ll phi(ll n) {
    ll ans = n;
    for (ll i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            ans -= ans / i;         //这一步就是对应欧拉函数的通式  
            while (n % i == 0)  //为了保证完全消除我们刚才得到的那个i因子。
                n /= i;            //确保我们下一个得到的i是n的素因子。
        }
    }
    if (n > 1)              //如果还有素因子没有除
        ans -= ans / n;
    return ans;
}

```

#### 欧拉筛

``` c++
bool notp[N];
int prime[N], pnum; //prime里存素数
int phi[N];
void sieve() {
    memset(notp, 0, sizeof(notp));
    phi[1] = notp[0] = notp[1] = 1;
    pnum = 0;
    for (int i = 2; i < N; i++) {
        if (!(notp[i]))
            prime[++pnum] = i, phi[i] = i - 1;
        for (int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}

```

#### 欧拉降幂

$$
\\当带模求幂过程中指数非常大时可以通过欧拉定理降幂 
\\a^b\%p = a^{b\%phi(p)+phi(p)} \% p  \ \ \ \ (phi(p) ≤b)
$$

#### 性质

$$
\\对欧拉函数求前缀和可得<=n的质数
\\质数N的欧拉函数是N-1 ，N^k 的欧拉函数是(N-1)*(N)^{k-1};
\\欧拉定理 a,n互质时，a^{phi[n]}=1(mod \  n)
\\当n为素数时 a^{n-1}=1\  mod\  n 此公式即 费马小定理
\\=>a^{n-2} 为在mod数为n下的逆元
\\phi[x] 一定是偶数 x>2
\\小于或等于n的数中，与n互质的数的总和为：phi[x] * x / 2  \ \ (n>1)
\\欧拉函数是积性函数――若m,n互质，phi(m*n)=phi(n)*phi(m)，
\\当n为奇数的时候，phi(2*n)=phi(n)，由上可得 
\\因为2必定和所有的奇数都是互质的，所以而phi(2)=1。所以得出这个结果
\\若正整数 a,p 互质，则对于正整数 b,
\\a^b\ \% \ p = a^{b \ \%\  phi(p)}\  \%\  p
$$


### 中国剩余定理

$$
\begin{cases} x &\equiv a_1 \pmod {n_1} \\ x &\equiv a_2 \pmod {n_2} \\ &\vdots \\ x &\equiv a_k \pmod {n_k} \\ \end{cases}
$$

#### 模数互质

```c++
void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
ll n;
ll as[100005];//n (余数)
ll ms[100005];
ll china() {
    ll ans = 0, lcm = 1, x, y, g;
    for(int i = 0;i < n; i++) lcm *= as[i];
    for(int i = 0; i < n; i++) {
        ll tp = lcm / as[i];
        exgcd(tp, as[i], g, x, y);
        x=(x % as[i] + as[i]) % as[i];
        ans=(ans + tp * x * ms[i]) % lcm;
    }
    return (ans % lcm + lcm) % lcm;
}

```

#### 模数不互质

```c++
typedef __int128 ll;
void exgcd(ll a, ll b, ll &g, ll &x, ll &y) {
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
bool china_flag = false;
ll a1, a2, m1, m2;
ll abs(ll x) { return x > 0 ? x : -x; }
void china() {
    ll d = a2 - a1;
    ll g, x, y;
    exgcd(m1, m2, g, x, y);
    if (d % g == 0) {
        x = ((x * d / g) % (m2 / g) + (m2 / g)) % (m2 / g);
        a1 = x * m1 + a1;
        m1 = (m1 * m2) / g;
    }
    else china_flag = true;
}
int n;
long long as[111];
long long ms[111];//mod m =a;
ll realchina() {
    a1 = as[0];
    m1 = ms[0];
    for (ll i = 1; i < n; i++) {
        a2 = as[i];//输入太多可依次输入
        m2 = ms[i];
        china();
        if (china_flag) return -1;
    }
    return a1;
}
//注意__int128的输出格式

```

## GCD

```c++
//最大公约      //建议直接__gcd()
ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
ll lcm(ll a, ll b) {
	return a * b / gcd(a, b);//可能会爆，快速乘
}//最大公倍

```

### 区间gcd

```c++
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
int v[N], l[N], a[N], len[N];
map<ll, ll> M;
struct point {
    int l, v;
} p[N][55];

scanf("%d", &n);
memset(v, 0, sizeof(v));
memset(len, 0, sizeof(len));
memset(l, 0, sizeof(l));
M.clear();
for (int i = 1; i <= n; i++)
	scanf("%d", &a[i]);
for (int i = 1, j; i <= n; i++) {//枚举右端点
	for (v[i] = a[i], j = l[i] = i; j; j = l[j] - 1) {
  		v[j] = gcd(v[j], a[i]);
  		while (l[j] > 1 && gcd(a[i], v[l[j] - 1]) == gcd(a[i], v[j]))
    	l[j] = l[l[j] - 1];//和自己边界l[j]-1相同,更新l[j]
		p[i][len[i]].l = l[j];
    	p[i][len[i]].v = v[j];
    	len[i]++;//边界种类++；
    	M[v[j]] += (j - l[j] + 1);//gcd为v[j]的数目++
  	}
}
int l, r, ans;
scanf("%d%d", &l, &r);
for (int i = 0; i < len[r]; i++) {
	if (l >= p[r][i].l) {
    	ans = p[r][i].v;
    	break;
  	}
}
printf("%d %lld\n", ans, M[ans]);

```

### 性质

$$
\begin{aligned}
&gcd(Fib(n),Fib(m)) = Fib(gcd(n,m))
\\&gcd(m^a,n^a) = gcd(m,n)^a 
\\&gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1
\\&gcd(a^m-b^m,a^n-b^n) = a^{gcd(m,n)} - b^{gcd(m,n)} (a,b 互质)
\\&gcd（b*t+a,b）=gcd（a,b）
//所以和b有关的gcd以phi(b)为循环节循环
\\&数列的gcd可以排序后用相邻两数的差值的gcd求得，适合集体加法的时候求gcd
\end{aligned}
$$

## 博弈论

### Bash博弈

$$
n \% (m+1)==0 ，先手输
$$

### Nim博弈

$$
算出各个sg值，全体异或=0，先手输
$$

### 非常规（sg函数）

```c++
//f[]：可以取走的石子个数
//sg[]:0~n的SG函数值
//hash[]:mex{}
int f[N], sg[N], hash[N];     
void getSG(int n) {
    int i, j;
    memset(sg, 0, sizeof(sg));
    for(i = 1; i <= n; i++) {
        memset(hash, 0, sizeof(hash));
        for(j = 1; f[j] <= i; j++)
            hash[sg[i - f[j]]]=1;
        for(j = 0; j <= n; j++) {   //求mes{}中未出现的最小的非负整数
            if(hash[j] == 0) {
                sg[i] = j;
                break;
            }
        }
    }
}
```

### 威佐夫博弈

$$
(a1-a2)*\frac{\sqrt5+1}{2}==a2，先手输//a1>a2
\\第k个奇异局势为（\frac{(\sqrt5+1)*k}{2}，\frac{(\sqrt5+3) * k}{2}
$$

### 威佐夫博弈扩展

按照上面在棋盘上移动棋子的方式，每次向左下移动可以看作是向左移动$dx$,向下移动$dy$， 要求$|dx-dy|<1$。那么如果将这个要求扩展到$|dx-dy|<d$呢？我们同样可以得出第k个奇异局势$(x,y)$，x为前$0～k-1$个奇异局势中没有出现过的最小自然数，$y=x+d*k$。根据Betty定理同样能得出第k个奇异局势为
$$
(\frac{2 - d + \sqrt{d ^ 2 + 4}}{2}*k,\frac{2 + d + \sqrt{d ^ 2 + 4}}{2}*k)
$$

## 素数

### 素数线性筛

```c++
bool notp[N];
int prime[N], pnum;//prime里存素数
void sieve() {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for(int i = 2; i < N; i++) {
        if(!(notp[i])) prime[++pnum] = i;
        for(int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}

```

### 素数检测

```c++
bool is_prime(ll x) {//大素数检测，可用米勒罗宾代替 
    if(x == 1)
        return false;
    if(x == 2 || x == 3)
        return true;
    if(x % 6 != 1 && x % 6 != 5)
        return false;
    int s = sqrt(x);
    for(int i = 5; i <= s; i += 6)
        if(x % i == 0 || x % (i + 2) == 0)
            return false;
    return true;
}
```



### 米勒罗宾素数检测

```c++
// 18位素数：154590409516822759
// 19位素数：2305843009213693951 (梅森素数)
// 19位素数：4384957924686954497
ll prime[6] = {2, 3, 5, 233, 331};
ll qmul(ll x, ll y, ll mod) { // 乘法防止溢出， 如果p * p不爆ll的话可以直接乘； O(1)乘法或者转化成二进制加法
    return (x * y - (long long)(x / (long double)mod * y + 1e-3) *mod + mod) % mod;
    /*
    ll ret = 0;
    while(y) {
        if(y & 1)
            ret = (ret + x) % mod;
        x = x * 2 % mod;
        y >>= 1;
    }
    return ret;
    */
}
ll qpow(ll a, ll n, ll mod) {
    ll ret = 1;
    while(n) {
        if(n & 1) ret = qmul(ret, a, mod);
        a = qmul(a, a, mod);
        n >>= 1;
    }
    return ret;
}
bool Miller_Rabin(ll p) {
    if(p < 2) return 0;
    if(p != 2 && p % 2 == 0) return 0;
    ll s = p - 1;
    while(! (s & 1)) s >>= 1;
    for(int i = 0; i < 5; ++i) {
        if(p == prime[i]) return 1;
        ll t = s, m = qpow(prime[i], s, p);
        while(t != p - 1 && m != 1 && m != p - 1) {
            m = qmul(m, m, p);
            t <<= 1;
        }
        if(m != p - 1 && !(t & 1)) return 0;
    }
    return 1;
}

```

### 区间筛

```c++
//找L~R之间的质数
ll L,R;
int k;
bool notp[N];
int prime[N],pnum;
void sieve() {
    memset(notp,0,sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for(int i = 2;i < sqrt(R); i++) {
        if(!(notp[i])) prime[++pnum] = i;
        for(int j = 1; j <= pnum && prime[j] * i < sqrt(R); j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) break;
        }
    }
}
bool v[1000010];//v中存L开始的数是否为素数
void interval_sieve() {
    memset(v, 1, sizeof(v));
    if(L == 1) v[0] = 0;
    for(int i = 1; i <= pnum; i++) {
        for(int j = (L + prime[i] - 1) / prime[i]; j <= R / prime[i]; j++) {
            if(j > 1) v[prime[i] * j - L] = 0;
        }//用prime中的素数筛L~R的素数
    }
}
```

## 合数

### 合数分解

```c++
pair<int,int> d[N];
int dnum;
void prime_div(ll n) {
    dnum = 0;
    if(n == 0) return;
    int num;
    for(int i = 1; i <= pnum; i++) {
        if(n % prime[i] == 0) {
            num = 0;
            while(n % prime[i] == 0) {
                num++;
                n /= prime[i];
            }
            d[++dnum]=make_pair(prime[i], num);
        }
        if(prime[i] > pnum) break;
    }
    if(n != 1) d[++dnum]=make_pair(n, 1);
}
```

### Pollard-Rho

```c++
pair<ll, ll> fa[22000];
ll as[22000];
ll anum = 0, fnum = 0;

bool Miller_Rabin(ll p);

ll f(ll x, ll c, ll n) { return ((lll)x * x + c) % n; }

ll Pollard_Rho(ll x) {
  ll s = 0, t = 0;
  ll c = (ll)rand() % (x - 1) + 1;
  int step = 0, goal = 1;
  ll val = 1;
  for (goal = 1;; goal <<= 1, s = t, val = 1) {
    for (step = 1; step <= goal; ++step) {
      t = f(t, c, x);
      val = (lll)val * abs(t - s) % x;
      if ((step % 127) == 0) {
        ll d = __gcd(val, x);
        if (d > 1) return d;
      }
    }
    ll d = __gcd(val, x);
    if (d > 1) return d;
  }
}

void fac(ll x) {
	if (x < 2) return;
	if (Miller_Rabin(x)) {
		
		as[++anum] = x;//这里是找所有的因子，如果找最大质因子取max
		return;
	}
	ll p = x;
	while (p == x) p = Pollard_Rho(x);
	//找最大质因子可以如下
    //while ((x % p) == 0) x /= p;fac(x), fac(p);
    fac(x / p);
	fac(p);
}
void init(ll x) {
	ll n = x;
	anum = 0;
	fac(n);
	sort(as + 1, as + 1 + anum);
	fnum = 0;
	fa[++fnum] = {as[1], 1};
	for(int i = 2; i <= anum; i++) {
		if(as[i] == as[i - 1]) {
			fa[fnum].se++;
		}
		else {
			fa[++fnum] = {as[i], 1};
		}
	}
}
```



### 区间合数分解

$$
区间合数分解（d(x^k) ）//有几个因数

\\若 x 分解成质因子乘积的形式为 x = p_1^{a_1} *p_2^{a_2}* ... *p_3^{a_3}，
\\那么 d(x) = (a_1 + 1) * (a_2 + 1) * ... * (a_n + 1) .
\\显然 d(x^k) = (a_1 * k + 1) * (a_2 * k + 1) * ... * (a_n * k + 1)
$$



```c++
//先来发区间素数筛 2~sqrt(R)
ll num[1000010];L~R
ll d[1000010];//L~R的分解数 
int main() {
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%lld%lld%d",&L,&R,&k);
        sieve();
        for(int i = 0; i <= R - L; i++) d[i]  = 1,num[i] = i + L;
        for(int i = 1; i <= pnum; i++) {
            ll st = (L + prime[i] - 1) / prime[i] * prime[i];//st:L开始的第一个能整除prime[i]的数 
            for(ll j = st; j <= R; j += prime[i]) {
                int cnt = 0;
                while(num[j - L] % prime[i] == 0) {
                    num[j - L] /= prime[i];
                    cnt++;
                }
                d[j - L] = d[j - L] * (k * cnt % mod + 1) % mod;//cn*k+1
            }
        }
        ll ans = 0;
        for(int i = 0; i <= R - L; i++) {
            if(num[i] != 1) d[i] = d[i] * (k + 1) % mod;//未分解完，有大素数 
            ans = (ans + d[i]) % mod;
        }
        printf("%lld\n", ans);
    }
}
```

### 阶乘因数个数

$$
阶乘 N！中包含质因子 x 的个数为 N/x + N/x^2 + N/x^3 +…
$$

### 约数之和

$$
N 的约数之和 =(1+p_1+p_1^2 +……+p_1^{c_1})*\\(1 +p_2 + p_2^2 +……+p_2^{c_2})*…*(1+p_n+p_n^2 +……+p_n^{c_n})
$$



```c++
ll psum(ll p,int c) {//psum 可求(1+pn+pn^2 +……+pn^cn)
    if(c == 0) return 1;
    if(c & 1)
    {
        return (1 + powmod(p , (c + 1) / 2) ) % mod * psum( p , (c - 1) / 2) % mod;
    }
    else
    {
		return ((1 + powmod(p , c / 2)) % mod * psum(p , c / 2 - 1) % mod 
                + powmod(p , c)) % mod;
    }
}
```

### 组合数的质因数个数

$$
C_m^n=\frac{n!}{(n - m)! * m!}
$$



```c++
//素数筛 
//分别计算分子和分母中不同质因子的个数，相减大于 0 则对答案贡献 1
	int ans = 0;
    for(int i = 1; i <= pnum; i++) {
        int tnum = 0;
        int ch = prime[i];
        for(; ch <= n||ch <= m||ch <= n - m; ch *= prime[i]) {
            if(n >= ch) tnum += n / ch;
            if(m >= ch) tnum -= m / ch;
            if(n - m >= ch) tnum -= (n - m) / ch;
        }
//      cout<<tnum<<endl;
        if(tnum > 0) ans++;
    }
    printf("%d\n", ans);
```



## 扩展欧几里得

```c++
void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {//ax+by=gcd(a,b)=g
    if (b == 0) {
        g = a; x = 1; y = 0;
        return;
    }
    exgcd(b, a % b, g, y, x);
    y -= (a / b) * x;
}
//ax + by = c; g;
//c%g==0时有解
//x=x*c/g,y=y*c/g;
//得到特解 :(x,y)
//dx=b/g,dy=-a/g;
//得到通解 :(x+dx*n,y+dy*n);
//得到x最小正整数解 :(x%dx+dx)%dx; 

```



## 逆元

### 模数为质数

```c++
inva = powmod(a, mod - 2, mod);//快速幂
```

### 模数不为质数

```c++
void exgcd(ll a,ll b,ll &g,ll &x, ll &y) {
	if(!b) {
		g=a; x=1; y=0;
		return ;
	}
	exgcd(b, a % b, g , y, x);
	y -= (a / b) * x;
}
//a = 1( %mod )
//ax + mod * y = 1;
//x为逆元
int main() {
	ll a, mod, x, y, g;
	cin>>a; //a为要求的逆元 
	mod = 998244352; 
	exgcd(a, mod, g, x, y);
	//g = 1; 
	x=(x % mod + mod) % mod;
	cout << x << '\n';//x为逆元 
}
```

### 线性逆元

```c++
ll inv[N];
inv[1]=1;
for(int i = 2; i < mod; i++)
  inv[i] = (mod - mod / i) * inv[mod % i] % mod;

```

### 阶乘逆元

```c++
//先求n！逆元
inv[n] = powmod(fac[n], mod - 2);
for(int i = n - 1; i >= 1; i--) {
 	inv[i] = inv[i + 1] * (i + 1) % mod;
}

```


## 高斯消元

### 高斯消元解同余

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int inf=0x3f3f3f3f;
const double pi= acos(-1.0);
const double esp=1e-6;
const int MAXN=310;
int aug[MAXN][MAXN];<span style="background-color: rgb(255, 255, 255);">
//增广矩阵行数为m,分别为0到m-1,列数为n+1,分别为0到n.</span>
int x[MAXN];//解集
int free_num;
int m,n;//m个方程，n个变元
int gcd(int a,int b) {
    int r;
    while(b!=0) {
        r=b;
        b=a%b;
        a=r;
    }
    return a;
}
int lcm(int a,int b) {
    return a/gcd(a,b)*b;
}
/*void Debug(void)
{
    puts("");
    int i,j;
    for(i=0;i<m;i++){
        for(j=0;j<n+1;j++){
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}*/
int trans(char *str) {
    if(strcmp(str,"MON")==0) return 1;
    else if(strcmp(str,"TUE")==0) return 2;
    else if(strcmp(str,"WED")==0) return 3;
    else if(strcmp(str,"THU")==0) return 4;
    else if(strcmp(str,"FRI")==0) return 5;
    else if(strcmp(str,"SAT")==0) return 6;
    else if(strcmp(str,"SUN")==0) return 7;
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(-1表示无解，
//0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
int Gauss() {
    int i,j;
    int row,col,max_r;// 当前这列绝对值最大的行;
    int LCM;
    int ta,tb;
    int tmp;
    for(row=0,col=0; row<m&&col<n; row++,col++) {
        // 枚举当前处理的行.
        // 找到该col列元素绝对值最大的那行与第row行交换.(为了在除法时减小误差)
        max_r=row;
        for(i=row+1; i<m; i++) {
            if(abs(aug[i][col])>abs(aug[max_r][col]))
                max_r=i;
        }
        if(max_r!=row) {
            // 与第row行交换
            for(j=row; j<n+1; j++)
                swap(aug[row][j],aug[max_r][j]);
        }
        if(aug[row][col]==0) {
            // 说明该col列第row行以下全是0了，则处理当前行的下一列.
            row--;
            continue;
        }
        for(i=row+1; i<m; i++) {
            // 枚举要删去的行.
            if(aug[i][col]!=0) {
                LCM=lcm(abs(aug[i][col]),abs(aug[row][col]));
                ta=LCM/abs(aug[i][col]);
                tb=LCM/abs(aug[row][col]);
                if(aug[i][col]*aug[row][col]<0) tb=-tb;//异号的情况是相加
                for(j=col; j<n+1; j++) {
                    aug[i][j]=(((aug[i][j]*ta-aug[row][j]*tb)%7+7)%7);
                }
            }
        }
    }
    //Debug();
    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for(i=row; i<m; i++) {
        if(aug[i][col]!=0)  return -1;
    }
    // 2. 无穷解的情况: 在n * (n + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if(row<n){
        return n-row;
    }
     // 3. 唯一解的情况: 在n * (n + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for(i=n-1; i>=0; i--) {
        tmp=aug[i][n];//等式右边的数
        for(j=i+1; j<n; j++) {
            if(aug[i][j]!=0) tmp-=aug[i][j]*x[j];//把已知的解带入，减去，只剩下，一个未知的解
            tmp=(tmp%7+7)%7;
        }
        while(tmp%aug[i][i]!=0)//外层每次循环都是为了求 a[i][i],因为它是每个方程中唯一一个未知的变量（求该方程时）
            tmp+=7;//因为天数不确定，而aug[i][i]必须得为整数才可以，周期为7
        x[i]=(tmp/aug[i][i])%7;
    }
    return 0;
}
int main(void) {
    int nn,mm,i,j,k;
    int num;
    char Start[5],End[5];
    while(~scanf("%d %d",&nn,&mm)) {
        if(nn==0&&mm==0) break;
        n=m=0;
        memset(aug,0,sizeof(aug));
        for(i=0; i<mm; i++) {
            scanf("%d",&k);
            scanf("%s %s",Start,End);
            aug[i][nn]=((trans(End)-trans(Start)+1)%7+7)%7;
            for(j=1; j<=k; j++) {
                scanf("%d",&num);
                num--;
                aug[i][num]++;
                aug[i][num]%=7;//有重复的
            }
        }
        m=mm;
        n=nn;
        free_num = Gauss();
        if(free_num==0) {
            for(i=0; i<n; i++)
                if(x[i]<3)//根据题意，每个零件的加工时间在3-9天.
                    x[i]+=7;
            for(i=0; i<n-1; i++)
                printf("%d ",x[i]);
            printf("%d\n",x[i]);
        } else if(free_num==-1)
            puts("Inconsistent data.");
        else
            puts("Multiple solutions.");
    }
    return 0;
}

```

### 高斯消元double版

```c++
#include <bits/stdc++.h>
using namespace std;
#define N 105
double a[N][N];
int n;
void gauss() {
    for (int i = 1; i <= n; i++) {//枚举列（项）
        int maxn = i;
        for (int j = i + 1; j <= n; j++) {//选出该列最大系数
            if (fabs(a[j][i]) > fabs(a[max][i])) {
                maxn = j;
            }
        }
        for (int j = 1; j <= n + 1; j++) {//交换
            swap(a[i][j], a[maxn][j]);
        }
        if (!a[i][i]) {//最大值等于0则说明该列都为0，肯定无解
            printf("No Solution\n");
            return;
        }
        for (int j = 1; j <= n; j++) {//每一项都减去一个数（就是小学加减消元） 
            if (j != i) {
                double temp = a[j][i] / a[i][i];
                for (int k = i + 1; k <= n + 1; k++) {
                    a[j][k] -= a[i][k] * temp;
                    //a[j][k]-=a[j][i]*a[i][k]/a[i][i];
                }
            }
        }
        for (int i = 1; i <= n; i++) {
            printf("%.2lf\n", a[i][n + 1] / a[i][i]);
        }
    }
    //上述操作结束后，矩阵会变成这样
    /*
    k1*a=e1
    k2*b=e2
    k3*c=e3
    k4*d=e4
    */
    //所以输出的结果要记得除以该项系数，消去常数
}
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n + 1; j++) {
            scanf("%lf", &a[i][j]);//tmd卡精度直接java,
        }
    }
    gauss();
    return 0;
}

```

### 高精度高斯消元

```java
import java.util.*;
import java.math.*;
import java.io.*;
 
public class Main {
	public static void main(String[] args) {
		new Task().main();
	}
}
class fraction {
	BigInteger a, b;
 
	fraction() {
		a = BigInteger.ZERO;
		b = BigInteger.ONE;
	}
 
	fraction(BigInteger a, BigInteger b) {
		this.a = a;
		this.b = b;
	}
 
	fraction add(fraction t) {
		BigInteger d, p, q;
		p = a.multiply(t.b);
		p = p.add(t.a.multiply(b));
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction substract(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.b);
		p = p.subtract(t.a.multiply(b));
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction multiply(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.a);
		q = b.multiply(t.b);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction divide(fraction t) {
		BigInteger p, q, d;
		p = a.multiply(t.b);
		q = b.multiply(t.a);
		d = p.gcd(q);
		p = p.divide(d);
		q = q.divide(d);
		return new fraction(p, q);
	}
 
	fraction abs() {
		return new fraction(a.abs(), b.abs());
	}
 
	int compareTo(fraction t) {
		t = this.substract(t);
		return t.a.compareTo(BigInteger.ZERO);
	}
 
	boolean zero() {
		return a.equals(BigInteger.ZERO);
	}
}
 
class Task {
	Scanner cin = new Scanner(System.in);
	PrintStream cout = System.out;
	fraction[][] f = new fraction[211][211];
	fraction[] x = new fraction[211];
	fraction tmp;
	BigInteger ONE = BigInteger.ONE;
	BigInteger ZERO = BigInteger.ZERO;
	fraction zero = new fraction(ZERO, ONE);
	fraction r, one = new fraction(ONE, ONE);
 
	boolean gauss(int n) {
		int i, j, k, row;
		for (i = 1; i <= n; ++i) {
			row = i;
			for (j = i + 1; j <= n; ++j) {
				if (f[row][i].abs().compareTo(f[j][i].abs()) < 0) {
					row = j;
				}
			}
			if (f[row][i].compareTo(zero) == 0) {
				return false;
			}
			if (row != i) {
				for (k = i; k <= n; ++k) {
					tmp = f[row][k];
					f[row][k] = f[i][k];
					f[i][k] = tmp;
				}
				tmp = x[row];
				x[row] = x[i];
				x[i] = tmp;
			}
			for (j = i + 1; j <= n; ++j) {
				r = f[j][i].divide(f[i][i]);
				f[j][i] = zero;
				for (k = i + 1; k <= n; ++k) {
					f[j][k] = f[j][k].substract(r.multiply(f[i][k]));
				}
				x[j] = x[j].substract(r.multiply(x[i]));
			}
		}
		for (i = n; i >= 1; --i) {
			for (j = i - 1; j >= 1; --j) {
				r = f[j][i].divide(f[i][i]);
				f[j][i] = zero;
				x[j] = x[j].substract(r.multiply(x[i]));
			}
		}
		for (i = 1; i <= n; ++i) {
			x[i] = x[i].divide(f[i][i]);
		}
		return true;
	}
 
	void main() {
		int n, i, j;
		while (cin.hasNext()) {
			n = cin.nextInt();
			for (i = 1; i <= n; ++i) {
				for (j = 1; j <= n; ++j) {
					f[i][j] = new fraction(cin.nextBigInteger(), ONE);
				}
				x[i] = new fraction(cin.nextBigInteger(), ONE);
			}
			boolean ok = gauss(n);
			if (!ok) {
				cout.println("No solution.");
			} else {
				for (i = 1; i <= n; ++i) {
					if (x[i].b.compareTo(ZERO) < 0) {
						x[i].a = x[i].a.negate();//返回负值
						x[i].b = x[i].b.negate();
					}
				}
				for (i = 1; i <= n; ++i) {
					cout.print(x[i].a);
					if (x[i].b.compareTo(ONE) != 0) {
						cout.print("/" + x[i].b);
					}
					cout.println();
				}
			}
			cout.println();
		}
	}
}
```

## 线性基

```c++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
#define N 10004
const int MAXL = 63;
ll a[N];
int n;
struct LineB {
	ll p[MAXL + 2];
	ll d[MAXL + 2];
	ll t[MAXL + 2];
	int cnt, zero;
	void init() {
		for(int i = MAXL; i >= 0; i--) {
			p[i] = d[i] = 0;
		}
		cnt = zero = 0;
	}
	void insert(ll x) {
		for(int i = MAXL; i >= 0; i--) {
			if(!((1ll << i) & x)) {
				continue;
			}
			if(!p[i]) {
				for(int j = 0; j < i; j++) {
					if(x & (1ll << j)) x ^= p[j];
				}
				for(int j = i + 1; j <= MAXL; j++) {
					if(p[j] & (1ll << i)) p[j] ^= x;
				}
				cnt++;
				p[i] = x;
				return;
			}
			x ^= p[i];
		}
		zero = 1;
	} 
	ll getMax() {//查询原集合内任意几个元素 xor 的最大值
		ll res = 0; 
		for(int i = MAXL; i >= 0; i--) {
			if((res ^ p[i]) > res) {
				res = res ^ p[i];
			}
		}
		return res;
	}
	ll getMin() {//查询原集合内任意几个元素 xor 的最小值
		for(int i = 0; i <= MAXL; i++) {
			if(p[i]) return p[i];
		}
		return 0;
	}
	
	void merge(const LineB &other) {
    	for (int i = 0; i <= MAXL; i++)
			insert(other.p[i]);
	}
	void bulid(ll *x, int n) {
		init();
		for(int i = 1; i <= n; i++) {
			insert(x[i]);
		}
	}
	void rebuild() {
		cnt = 0;
		for(int i = 0; i <= MAXL; i++) {
			if(p[i]) d[cnt++] = p[i];
		}
	}
	ll kth(ll k) { //求第k小之前需要rebuild
		ll res = 0;
		if (k >= (1ll << cnt)) return -1;
		for (int i = MAXL; i >= 0; i--) {
			if (k & (1ll << i)) res ^= d[i];
		}
		return res;
	}
    int rank(ll x) { //x第一次出现的排名
        int res = 0, bit = 0;
        for(int i = 0; i <= MAXL; i++) {
            if(p[i]) {
                if((1ll << i) & x) {
                    res += 1ll << bit;
                }
                bit++;
            }
        }
        return res;
    }
};

//求第k小
int main() {
	int t;
	scanf("%d", &t);
	int casei =0;
	while(t--) {
		printf("Case #%d:\n", ++casei);
		scanf("%d", &n);
		LineB res;
		res.init();
		for(int i = 1; i <= n; i++) {
			scanf("%lld", &a[i]);
			res.insert(a[i]);
		}
		int m;
		res.rebuild();
		scanf("%d", &m);
		while(m--) {
			ll k;
			scanf("%lld", &k);
			if(res.zero) k--;
			printf("%lld\n", res.kth(k));
		}	
	}
}

```



## Polya定理

### 前置 置换群

一个集合有以下置换关系

$ (a_1,a_2,\dots,a_m)=\begin{pmatrix}a_1,a_2,\dots,a_{m-1},a_m\\ a_2,a_3,\dots,a_m,a_1\end{pmatrix} $

若两个循环置换不含有相同的元素，则称它们是 **不相交** 的。有如下定理：

任意一个置换都可以分解为若干不相交的循环置换的乘积，例如

$ \begin{pmatrix}a_1,a_2,a_3,a_4,a_5,a_6\\ a_3,a_1,a_2,a_5,a_4,a_6\end{pmatrix}=(a_1,a_3,a_2)\circ(a_4,a_5)\circ(a_6) $

则$|G|++$,该轮换个数为$3$。

### Polya定理

设$N=\{1,2,3,……,n\}$是被染色物体的集合，$G=\{\sigma_1,\sigma_2,\sigma_3,……,\sigma_n\}$是n上的置换群。设$c(\sigma_k)$为置换表达式$\sigma_k$中的轮换个数。用m种颜色染色，不同的着色方案是：
$$
M=\frac{1}{|G|}\displaystyle\sum_{k=1}^{g}m^{c(\sigma_k)}
$$

### 举例

以染立方体为例
$$
\begin{aligned}
\\&A:立方体 6 个面的集合
\\&B:3 种颜色的集合
\\&X:直接给每个面染色，不考虑本质不同的方案的集合，共有  种
\\&G:各种翻转操作构成的置换群
\\&X/G:本质不同的染色方案的集合
\\&X^g:对于某一种翻转操作g,所有直接染色方案中，经过g这种翻转后保持不变的染色方案的集合
\end{aligned}
$$
![img](https://oi-wiki.org/math/images/cube.png)

接下来我们需要对$G$中的所有置换进行分析，它们可以分为以下几类（方便起见，将立方体的 6 个面分别称为前、后、上、下、左、右）：

- 不动：即恒等变换，因为所有直接染色方案经过恒等变换都不变，因此它对应的$|X^g|=3^6$ 
- 以两个相对面的中心连线为轴的$90^°$旋转：相对面有 3 种选择，旋转的方向有两种选择，因此这类共有 6 个置换。假设选择了前、后两个面中心的连线为轴，则必须要满足上、下、左、右 4 个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^3$
- 以两个相对面的中心连线为轴的$180°$旋转：相对面有 3 种选择，旋转方向的选择对置换不再有影响，因此这类共有 3 个置换。假设选择了前、后两个面中心的连线为轴，则必须要满足上、下两个面的颜色一样，左、右两个面的颜色一样，才能使旋转后不变，因此它对应的 $|X^g|=3^4$
- 以两条相对棱的中点连线为轴的$180°$旋转：相对棱有 6 种选择，旋转方向对置换依然没有影响，因此这类共有 6 个置换。假设选择了前、上两个面的边界和下、后两个面的边界作为相对棱，则必须要满足前、上两个面的颜色一样，下、后两个面的颜色一样，左、右两个面的颜色一样，才能使旋转后不变，因此它对应的$|X^g|=3^3$ 
- 以两个相对顶点的连线为轴的$120°$旋转：相对顶点有 4 种选择，旋转的方向有两种选择，因此这类共有 8 个置换。假设选择了前面的右上角和后面的左下角作为相对顶点，则必须满足前、上、右三个面的颜色一样，后、下、左三个面的颜色一样，才能使旋转后不变，因此它对应的$|X^g|=3^2$ 

因此，所有本质不同的方案数为
$$
 \frac{1}{1+6+3+6+8}(3^6+6\times3^3+3\times3^4+6\times3^3+8\times3^2)=57 
$$

### 特殊情况 m颜色染n元环

简单想一想，转几下都可以,转完后置换群应该是转的度数和n的最大公因数。所以列出如下方程
$$
M=\frac{1}{n}\displaystyle\sum_{k=1}^{n}m^{gcd(k,n)}
$$
化简得
$$
\begin{aligned}
M&=\frac{1}{n}\displaystyle\sum_{d|n}m^d\displaystyle\sum_{k=1}^{n/d}[gcd(k,\frac{n}{d})=1]
\\&=\frac{1}{n}\displaystyle\sum_{d|n}m^d\varphi(\frac{n}{d})
\end{aligned}
$$


## 多项式

### 快速傅里叶变换（FFT）

luogu P1919

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4000005;
const double pi = acos(-1);
struct cp {
	double x, y;
	cp(double _x = 0.0, double _y = 0.0) : x(_x), y(_y){}
	cp operator * (const cp &t) const {
		return cp(x * t.x - y * t.y, x * t.y + y * t.x);
	}
	cp operator + (const cp &t) const {
		return cp(x + t.x, y + t.y);
	}
	cp operator - (const cp &t) const {
		return cp(x - t.x, y - t.y);
	}
};
char sa[N], sb[N];
int n = 1, lim = 1, lena, lenb, res[N];
cp a[N], b[N];
int L, R[N];

void fft(cp *a, double f) {
	for(int i = 0; i < lim; i++) {
		if(i < R[i]) swap(a[i], a[R[i]]);
	}
	for(int j = 1; j < lim; j <<= 1) {
		cp T(cos(pi / j), f * sin(pi / j));
		for(int k = 0; k < lim; k += (j << 1)) {
			cp t(1, 0);
			for(int l = 0; l < j; l++, t = t * T) {
				cp Nx = a[k + l], Ny = t * a[k + j + l];
				a[k + l] = Nx + Ny;
				a[k + j + l] = Nx - Ny;
			}
		}
	}
}

int main() {
	scanf("%s%s", sa, sb);
	lena = strlen(sa), lenb = strlen(sb);
	int aa = 0, bb = 0;
	for(int i = lena - 1; i >= 0; i--) {
		a[aa++].x = sa[i] - '0';
	}
	for(int i = lenb - 1; i >= 0; i--) {
		b[bb++].x = sb[i] - '0';
	}
	while(lim < lena + lenb) lim <<= 1, L++;
    for(int i = 0; i <= lim; i++) {
    	R[i] = (R[i >> 1] >> 1) | ((i & 1) << (L - 1));
	}
    fft(a, 1);
    fft(b, 1);
    for(int i = 0; i <= lim; i++)
        a[i] = a[i] * b[i];
    fft(a, -1);
    for(int i = 0; i <= lim; i++) {
    	res[i] += floor(a[i].x / lim + 0.5);
    	if(res[i] >= 10) {
    		res[i + 1] += res[i] / 10;
    		res[i] %= 10;
    		lim += (i == lim);
		}
	}
	while(!res[lim] && lim >= 1) lim--;
	for(int i = lim; i >= 0; i--) {
		printf("%d", res[i]);
	}
}
```



### 快速数论变换（NTT）



```c++
#define G 3
int powmod(int a, int b){
	int res = 1;
	while(b) {
		if(b & 1) res = res * a % mod;
     	a = a * a % mod;
    	b >>= 1;
    }
    return res;
}
int rev[N], GG_inv, len_inv;
void ntt(int *a, int len, int o){//NTT板子
	len_inv = powmod(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);
	for(int i = 0; i <= len; i ++) if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(int i = 2; i <= len; i <<= 1){
		int wn = powmod((o == 1)? GG:GG_inv, (mod - 1) / i);
		for(int j = 0, p = i / 2; j + i - 1<= len; j += i){
			int w0 = 1;
			for(int k = j; k < j + p; k ++, w0 = w0 * wn % mod){
				int X = a[k], Y = w0 * a[k + p] % mod;
				a[k] = (X + Y) % mod;
				a[k + p] = (X - Y + mod) % mod;
			}
		}
	}
	if(o == -1) 
		for(int i = 0; i <= len; i ++) a[i] = a[i] * len_inv % mod;
}
void mul(int *a, int *b, int n, int m){//多项式乘法板子
	int len = 1;
	for(; len <= n + m; len <<= 1);
	ntt(a, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) a[i] = a[i] * b[i] % mod;
	ntt(a, len, -1);
}
```



### 多项式求逆

```c++
#define G 3
#define N 8000005
using namespace std;
int qpow(int x, int y){
	int ret = 1;
	for(; y; y >>= 1, x = x * x % mod) if(y & 1) ret = ret * x % mod;
	return ret;
}
int rev[N], G_inv, len_inv;
void ntt(int *a, int len, int o){//NTT板子
	len_inv = qpow(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);
	for(int i = 0; i <= len; i ++) if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(int i = 2; i <= len; i <<= 1){
		int wn = qpow((o == 1)? G:G_inv, (mod - 1) / i);
		for(int j = 0, p = i / 2; j + i - 1 <= len; j += i){
			int w0 = 1;
			for(int k = j; k < j + p; k ++, w0 = w0 * wn % mod){
				int X = a[k], Y = w0 * a[k + p] % mod;
				a[k] = (X + Y) % mod;
				a[k + p] = (X - Y + mod) % mod;
			}
		}
	}
	if(o == -1) 
		for(int i = 0; i <= len; i ++) a[i] = a[i] * len_inv % mod;
}
int c[N];
void inv(int *a, int *b, int sz){
	if(sz == 1) {b[0] = qpow(a[0], mod - 2); return;}//常数直接求逆元
	inv(a, b, (sz + 1) / 2);//把小的先求出来
	int len = 1;
	for(; len <= sz + sz; len <<= 1);
	for(int i = 0; i < sz; i ++) c[i] = a[i];//注意要用c替换一下，不然a会做很多次NTT
	for(int i = sz; i <= len; i ++) c[i] = 0;
	ntt(c, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) b[i] = (b[i] * 2 % mod - b[i] * b[i] % mod * c[i] % mod + mod) % mod;//直接算
	ntt(b, len, -1);
	for(int i = sz; i <= len; i ++) b[i] = 0;//注意，b要用很多次，所以要把后面的清空一下
}
int a[N], b[N], n, m;
signed main(){
	G_inv = qpow(G, mod - 2);
	scanf("%lld", &n);
	for(int i = 0; i < n; i ++) scanf("%lld", &a[i]);
	inv(a, b, n);
	for(int i = 0; i < n; i ++) printf("%lld ", b[i]);
	return 0;
}
```



### 多项式除法

```c++
#include<bits/stdc++.h>
#define int long long
#define mod 998244353	
#define GG 3
#define N 8000005
using namespace std;
int qpow(int x, int y){
	int ret = 1;
	for(; y; y >>= 1, x = x * x % mod) if(y & 1) ret = ret * x % mod;
	return ret;
}
int rev[N], GG_inv, len_inv;
void ntt(int *a, int len, int o){//NTT板子
	len_inv = qpow(len, mod - 2);
	for(int i = 0; i <= len; i ++) rev[i] = (rev[i >> 1] >> 1) | ((i&1) * len >> 1);
	for(int i = 0; i <= len; i ++) if(i < rev[i]) swap(a[i], a[rev[i]]);
	for(int i = 2; i <= len; i <<= 1){
		int wn = qpow((o == 1)? GG:GG_inv, (mod - 1) / i);
		for(int j = 0, p = i / 2; j + i - 1<= len; j += i){
			int w0 = 1;
			for(int k = j; k < j + p; k ++, w0 = w0 * wn % mod){
				int X = a[k], Y = w0 * a[k + p] % mod;
				a[k] = (X + Y) % mod;
				a[k + p] = (X - Y + mod) % mod;
			}
		}
	}
	if(o == -1) 
		for(int i = 0; i <= len; i ++) a[i] = a[i] * len_inv % mod;
}
int c[N];
void inv(int *a, int *b, int sz){//多项式求逆板子
	if(sz == 0) {b[0] = qpow(a[0], mod - 2); return;}
	inv(a, b, sz / 2);
	int len = 1;
	for(; len <= sz + sz; len <<= 1);
	for(int i = 0; i <= sz; i ++) c[i] = a[i];
	for(int i = sz + 1; i <= len; i ++) c[i] = 0;
	ntt(c, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) b[i] = (b[i] * 2 % mod - b[i] * b[i] % mod * c[i] % mod + mod) % mod;
	ntt(b, len, -1);
	for(int i = sz + 1; i <= len; i ++) b[i] = 0;
}
void mul(int *a, int *b, int n, int m){//多项式乘法板子
	int len = 1;
	for(; len <= n + m; len <<= 1);
	ntt(a, len, 1), ntt(b, len, 1);
	for(int i = 0; i <= len; i ++) a[i] = a[i] * b[i] % mod;
	ntt(a, len, -1);
}
int a[N], b[N], F[N], G[N], Q[N], GR[N], FR[N], GR_inv[N], R[N], n, m;
signed main(){
	GG_inv = qpow(GG, mod - 2);
	scanf("%lld%lld", &n, &m);
	for(int i = 0; i <= n; i ++) scanf("%lld", &F[i]), FR[n - i] = F[i];
	for(int i = 0; i <= m; i ++) scanf("%lld", &G[i]), GR[m - i] = G[i];
	for(int i = n - m + 1; i <= m; i ++) GR[i] = 0;// mod n - m + 1, 即把后面的全部清0
	inv(GR, GR_inv, n - m);//注意长度是 n - m, 要补齐
	mul(FR, GR_inv, n, n - m);	//长度要补齐
	for(int i = 0; i <= n - m; i ++) Q[i] = FR[n - m - i];//翻转
	for(int i = 0; i <=  n - m; i ++) printf("%lld ", Q[i]); printf("\n");//输出
	mul(G, Q, m, n - m);//直接算余数R
	for(int i = 0; i < m; i ++) R[i] = (F[i] - G[i] + mod) % mod;
	for(int i = 0; i <  m; i ++) printf("%lld ", R[i]); printf("\n");
	return 0;
}
```



## 二次剩余

```c++
ll w;
ll mod;
struct num {
    ll x, y;
};
num mul(num a, num b) {
    num ans = {0, 0};
    ans.x = ((a.x * b.x % mod + a.y * b.y % mod * w % mod) % mod + mod) % mod;
    ans.y = ((a.x * b.y % mod + a.y * b.x % mod) % mod + mod) % mod;
    return ans;
}
ll powwi(num a, ll k) {
    num ans = {1, 0};
    while(k) {
        if(k & 1) ans = mul(ans, a);
        a = mul(a, a);
        k >>= 1;
    }
    return ans.x % mod;
}
ll powmod(ll a, ll b) {
    ll res = 1;
    a = a % mod;
    while(b) {
        if(b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}
ll solve(ll n) { 
    n %= mod;
    if(mod == 2) return n;
    if(powmod(n, (mod - 1) / 2) == mod - 1) return -1;
    ll a;
    while(1) {
        a = rand() % mod;
        w = ((a * a % mod - n) % mod + mod) % mod;
        if(powmod(w, (mod - 1) / 2) == mod - 1) break;
    }
    num x = {a, 1};
    return powwi(x, (mod + 1) / 2);
}
int main() {
	srand(time(0));
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld%lld", &n, &mod);
        if(!n) {
        	printf("0\n");
			continue;
		}
        ll ans1 = solve(n), ans2;
        if(ans1 == -1) printf("不存在\n");
        else {
            ans2=mod - ans1;
            if(ans1 > ans2) swap(ans1,ans2);
            if(ans1 == ans2) printf("%lld\n",ans1);//解相等 
            else 
				printf("%lld %lld\n",ans1, ans2);
        }
    }
}

```

## n次剩余

```c++
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;
int A, B, mod;
int pow(int x, int y, int mod = 0, int ans = 1) {
	if (mod) {
		for (; y; y >>= 1, x = (ll) x * x % mod)
			if (y & 1) ans = (ll) ans * x % mod;
	} else {
		for (; y; y >>= 1, x = x * x)
			if (y & 1) ans = ans * x;
	}
	return ans;
}

struct factor {
	int prime[20], expo[20], pk[20], tot;
	void factor_integer(int n) {
		tot = 0;
		for (int i = 2; i * i <= n; ++i) if (n % i == 0) {
			prime[tot] = i, expo[tot] = 0, pk[tot] = 1;
			do ++expo[tot], pk[tot] *= i; while ((n /= i) % i == 0);
			++tot;
		}
		if (n > 1) prime[tot] = n, expo[tot] = 1, pk[tot++] = n;
	}
	int phi(int id) const {
		return pk[id] / prime[id] * (prime[id] - 1);
	}
} mods, _p;

int p_inverse(int x, int id) {
	assert(x % mods.prime[id] != 0);
	return pow(x, mods.phi(id) - 1, mods.pk[id]);
}

void exgcd(int a, int b, int &x, int &y) {
	if (!b) x = 1, y = 0;
	else exgcd(b, a % b, y, x), y -= a / b * x;
}
int inverse(int x, int mod) {
	assert(__gcd(x, mod) == 1);
	int ret, tmp;
	exgcd(x, mod, ret, tmp);
	ret %= mod;
	return ret + (ret >> 31 & mod);
}

vector<int> sol[20];

void solve_2(int id, int k) {
	int mod = 1 << k;
	if (k == 0) { sol[id].emplace_back(0); return; }
	else {
		solve_2(id, k - 1); vector<int> t;
		for (int s : sol[id]) {
			if (!((pow(s, A) ^ B) & mod - 1))
				t.emplace_back(s);
			if (!((pow(s | 1 << k - 1, A) ^ B) & mod - 1))
				t.emplace_back(s | 1 << k - 1);
		}
		swap(sol[id], t);
	}
}

int BSGS(int B, int g, int mod) { // g^x = B (mod M) => g^iL = B*g^j (mod M) : iL - j
	unordered_map<int, int> map;
	int L = ceil(sqrt(mod)), t = 1;
	for (int i = 1; i <= L; ++i) {
		t = (ll) t * g % mod;
		map[(ll) B * t % mod] = i;
	}
	int now = 1;
	for (int i = 1; i <= L; ++i) {
		now = (ll) now * t % mod;
		if (map.count(now)) return i * L - map[now];
	}
	assert(0);
}

int find_primitive_root(int id) {
	int phi = mods.phi(id); _p.factor_integer(phi);
	auto check = [&] (int g) {
		for (int i = 0; i < _p.tot; ++i)
			if (pow(g, phi / _p.prime[i], mods.pk[id]) == 1)
				return 0;
		return 1;
	}; 
	for (int g = 2; g < mods.pk[id]; ++g) if (check(g)) return g;
	assert(0);
}

void division(int id, int a, int b, int mod) { //  ax = b (mod M)
	int M = mod, g = __gcd(__gcd(a, b), mod);
	a /= g, b /= g, mod /= g;
	if (__gcd(a, mod) > 1) return;
	int t = (ll) b * inverse(a, mod) % mod;
	for (; t < M; t += mod) sol[id].emplace_back(t);
}

void solve_p(int id, int B = ::B) {
	int p = mods.prime[id], e = mods.expo[id], mod = mods.pk[id];
	if (B % mod == 0) {
		int q = pow(p, (e + A - 1) / A);
		for (int t = 0; t < mods.pk[id]; t += q)
			sol[id].emplace_back(t);
	} else if (B % p != 0) {
		int phi = mods.phi(id);
		int g = find_primitive_root(id), z = BSGS(B, g, mod);
		division(id, A, z, phi);
		for (int &x : sol[id]) x = pow(g, x, mod);
	} else {
		int q = 0; while (B % p == 0) B /= p, ++q;
		int pq = pow(p, q);
		if (q % A != 0) return;
		mods.expo[id] -= q, mods.pk[id] /= pq;
		solve_p(id, B);
		mods.expo[id] += q, mods.pk[id] *= pq;
		if (!sol[id].size()) return;
		
		int s = pow(p, q - q / A);
		int t = pow(p, q / A);
		int u = pow(p, e - q);

		vector<int> res;		
		for (int y : sol[id]) {
			for (int i = 0; i < s; ++i)
				res.emplace_back((i * u + y) * t);
		}
		swap(sol[id], res);
	}
}

vector<int> allans;
void dfs(int dep, int ans, int mod) {
	if (dep == mods.tot) {allans.emplace_back(ans); return;}
	int p = mods.pk[dep], k = p_inverse(mod % p, dep);
	for (int a : sol[dep]) {
		int nxt = (ll) (a - ans % p + p) * k % p * mod + ans;
		dfs(dep + 1, nxt, mod * p);
	}
}

void solve() {
	//x^A = B (% mod)
	scanf("%d%d%d", &A, &mod, &B);
	mods.factor_integer(mod);
	allans.clear();
	for (int i = mods.tot - 1; ~i; --i) {
		sol[i].clear();
		mods.prime[i] == 2 ? solve_2(i, mods.expo[i]) : solve_p(i);
		if (!sol[i].size()) {
			printf("0\n");
			return;
		}
	}
	dfs(0, 0, 1), sort(allans.begin(), allans.end());
	printf("%d\n", allans.size()); //解的集合 
	for (int i : allans) {
		printf("%d ", i); 
	} 
	printf("\n");
}

int main() {
	int t;
	scanf("%d", &t); 
	while(t--) {
		solve();
	}
	return 0;
}
```



## 高次同余方程



```c++
//给定y,z,p，计算满足Y^x = Z(mod P)的最小非负整数
ll bsgs(ll a, ll b, ll p) {
    map<int, int> H;
    H.clear();
    b %= p;
    int t = (int)sqrt(p) + 1;
    for (int i = 0; i < t; i++) {
        int val = (ll)b * powmod(a, i, p) % p;
        H[val] = i;
    }
    a = powmod(a, t, p);
    if (!a) return b ? -1 : 1;
    for (int i = 0; i <= t; i++) {
        int val = powmod(a, i, p);
        int j = H.find(val) == H.end() ? -1 : H[val];
        if(j >= 0 && i * t >= j)
            return i * t - j;
    }
    return -1;
}

```

## 同余不等式

$$
L\leqslant Dx\ \% \ mod \leqslant R
\\L\leqslant Dx-My \leqslant R
\\y == 0 时直接求解
\\y\ !=0时有 : Dx-R<= My <= Dx-L ,y 越小则 x 越小 
\\不等式同模 D 
\\得 (-R)\%D \leqslant (M\%D)*y\%D \leqslant (-L)\%D
\\ 递归求解
$$

```c++
ll find(ll m, ll d, ll l, ll r) {
    if (!d || l > r)
        return -1;
    if (r / d * d >= l)
        return (l - 1) / d + 1;
    ll x = find(d, m % d, ((-r) % d + d) % d, ((-l) % d + d) % d);
    if (x == -1)
        return -1;
    return (l - 1 + x * m) / d + 1;
}
int main() {
    int n;
    ll x, y, m, d, l, r;
    scanf("%d", &n);
    while (n--) {
        scanf("%lld%lld%lld%lld", &m, &d, &l, &r);
        r = min(m - 1, r);
        printf("%lld\n", find(m, d, l, r));
    }
}
```

## 类欧几里得算法

$$
f(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor
$$

已知$a,b,c,n,log(n)$的复杂度求函数的值。

代码如下：

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int P = 998244353;
int i2 = 499122177, i6 = 166374059;
struct data {
  data() { f = g = h = 0; }
  int f, g, h;
};  // 三个函数打包
data calc(int n, int a, int b, int c) {
  int ac = a / c, bc = b / c, m = (a * n + b) / c, n1 = n + 1, n21 = n * 2 + 1;
  data d;
  if (a == 0) {  // 迭代到最底层
    d.f = bc * n1 % P;
    d.g = bc * n % P * n1 % P * i2 % P;
    d.h = bc * bc % P * n1 % P;
    return d;
  }
  if (a >= c || b >= c) {  // 取模
    d.f = n * n1 % P * i2 % P * ac % P + bc * n1 % P;
    d.g = ac * n % P * n1 % P * n21 % P * i6 % P + bc * n % P * n1 % P * i2 % P;
    d.h = ac * ac % P * n % P * n1 % P * n21 % P * i6 % P +
          bc * bc % P * n1 % P + ac * bc % P * n % P * n1 % P;
    d.f %= P, d.g %= P, d.h %= P;

    data e = calc(n, a % c, b % c, c);  // 迭代

    d.h += e.h + 2 * bc % P * e.f % P + 2 * ac % P * e.g % P;
    d.g += e.g, d.f += e.f;
    d.f %= P, d.g %= P, d.h %= P;
    return d;
  }
  data e = calc(m - 1, c, c - b - 1, a);
  d.f = n * m % P - e.f, d.f = (d.f % P + P) % P;
  d.g = m * n % P * n1 % P - e.h - e.f, d.g = (d.g * i2 % P + P) % P;
  d.h = n * m % P * (m + 1) % P - 2 * e.g - 2 * e.f - d.f;
  d.h = (d.h % P + P) % P;
  return d;
}
int T, n, a, b, c;
signed main() {
  scanf("%lld", &T);
  while (T--) {
    scanf("%lld%lld%lld%lld", &n, &a, &b, &c);
    data ans = calc(n, a, b, c);
    printf("%lld %lld %lld\n", ans.f, ans.h, ans.g);
  }
  return 0;
}
```

### $g(a,b,c,n)=\sum_{i=0}^ni\left\lfloor \frac{ai+b}{c} \right\rfloor$

$$
\begin{split} 
\\&设m=\left\lfloor\frac{an+b}{c}\right\rfloor
\\&=\sum_{j=0}^{m-1}\sum_{i=0}^n[i>t]\cdot i=\sum_{j=0}^{m-1}\frac{1}{2}(t+n+1)(n-t)\\ &=\frac{1}{2}\left[mn(n+1)-\sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t\right]\\ &=\frac{1}{2}[mn(n+1)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)] \end{split}
$$

### $h(a,b,c,n)=\sum_{i=0}^n\left\lfloor \frac{ai+b}{c} \right\rfloor^2$


$$
h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)
$$


## 数论分块

对于式子$\displaystyle\sum_{i=1}^{min(n,m)}\lfloor n/i \rfloor\lfloor m/i \rfloor$,有如下解法

```c++
	int r, res = 0;
	for(int l = 1; l <= min(n, m); l = r + 1) {
        r = min(n / (n / l), m / (m / l));
    	res += (n / l) * (m / l);
    }
```

如果式子带了某些参数，计算前缀和或者2累加公式等等。

## 莫比乌斯反演

$$
\begin{aligned}
\\&单位函数：\epsilon(n)=\displaystyle\sum_{d|n}\mu(d)=[n=1] 
\\&恒等函数：id_k(n)=n^k
，id_1(n)记作id(n)
\\&除数函数：\sigma_k(n)=\displaystyle\sum_{d|n}d^k,\sigma_0(n)简写为d(n)。\sigma(n)=\displaystyle\sum_{d|n}d,d(n)=\displaystyle\sum_{d|n}1
\\&常数函数：1(n)=1
\\&欧拉函数：\varphi(n)=\displaystyle\sum_{i=1}^n[gcd(i,n)=1]=\displaystyle\sum_{d|n}d·\mu(\frac{n}{d})
\\&莫比乌斯函数：\mu(n)=
	\begin{cases}
	1& \text{$n=1$}\\
	0& \text{$d^2|n, d > 1$,即没有一个因数有两个以上}\\
	(-1)^x& \text{$x=\displaystyle\sum_{d|n}1$，即为所有不同质因子数}
	\end{cases}
	\\ &[gcd(i,j)=1]->\displaystyle\sum_{d|gcd(i,j)}\mu(d)
\end{aligned}
$$
卷积：
$$
\begin{aligned}
\\&f(n)=\sum_{d|n}g(d) ->g(n)=\sum_{d|n}\mu(d)f(\frac{n}{d})     
\\&f(n)=\sum_{n|d}g(d) ->g(n)=\sum_{n|d}\mu(\frac{n}{d})f(d)      \\&(f=g*1 ->g = f * \mu)
\end{aligned}
$$

常用式子：
$$
\begin{aligned}
 \\ \varepsilon=\mu \ast 1&\iff\varepsilon(n)=\sum_{d\mid n}\mu(d)
 \\ d=1 \ast 1&\iff d(n)=\sum_{d\mid n}1
 \\ \sigma=\operatorname{id} \ast 1&\iff\sigma(n)=\sum_{d\mid n}d
 \\ \varphi=\mu \ast \operatorname{id}&\iff\varphi(n)=\sum_{d\mid n}d\cdot\mu(\frac{n}{d})
\\ \varphi*1&=id（1+4得到）
 \end{aligned}
$$


一些公式：
$$
\begin{aligned}
\\&d(n)为约数个数，d(ij)=\displaystyle\sum_{x|i}\displaystyle\sum_{y|j}[gcd(x,y)=1]
\\
\end{aligned}
$$


$\mu(n)$的筛法：

```c++
bool notp[N];
int prime[N], pnum;
int mu[N];
void sieve() {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    mu[1] = 1;
    pnum = 0;
    for(int i = 2; i < N; i++) {
        if(!(notp[i])) prime[++pnum] = i, mu[i] = -1;
        for(int j = 1; j <= pnum && prime[j] * i < N; j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                mu[prime[j] * i] = 0;
                break;
            }
            else {
                 mu[prime[j] * i] = -mu[i];
            }
        }
    }
    for(int i = 1; i < N; i++) mu[i] += mu[i - 1];//前缀
}
```

## 杜教筛

$$
\begin{aligned}
\\&\sum_{i=1}^{n}\sum_{d \mid i}f(d)g\left(\frac{i}{d}\right)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right)
\\& \Leftrightarrow \sum_{i=1}^{n}(f\ast g)(i)=\sum_{i=1}^{n}g(i)S\left(\left\lfloor\frac{n}{i}\right\rfloor\right) (★)
\\&S(n)=\displaystyle\sum_{i=1}^nf(i)
\\&g(1)S(n)=\displaystyle\sum_{i=1}^{n}(f*g)(i)-\displaystyle\sum_{i=2}^{n}g(i)*S(\lfloor\frac{n}{i}\rfloor)(★)

\end{aligned}
$$

做题时，将$\displaystyle\sum_{i=1}^{n}(f*g)(i)$尽可能化为常数，对后面先线性筛预处理，再进行分块和记忆化。

```c++
#include<bits/stdc++.h>
typedef long long ll;
using namespace std;
const int N = 5e6 + 5;
ll mod, n;
int pn;
ll inv2, inv6;
ll powmod(ll a, ll b) {
	ll res = 1;
	a = a % mod;
	while(b) {
		if(b & 1) res = res * a % mod;
		a = a * a % mod;
		b >>= 1;
	}
	return res;   
}
bool notp[N];
int prime[N], pnum;
int phi[N];
ll s[N];
void sieve(int n) {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    phi[1] = 1;
    pnum = 0;
    for(int i = 2; i <= n; i++) {
        if(!(notp[i])) prime[++pnum] = i, phi[i] = i - 1;
        for(int j = 1; j <= pnum && prime[j] * i <= n; j++) {
            notp[prime[j] * i] = 1;
            if(i % prime[j] == 0) {
                phi[prime[j] * i] = phi[i] * prime[j];
                break;
            }
            else {
                 phi[prime[j] * i] = phi[i] * phi[prime[j]];
            }
        }
    }
    for(int i = 1; i <= n; i++) {
    	s[i] = (1ll * i * i % mod * phi[i] % mod + s[i - 1]) % mod;
	}
}
ll s2(ll x) {
	return x * (x + 1) % mod * inv2 % mod;
}
ll s22(ll x) {
	x %= mod;
	return s2(x) * s2(x) % mod;
}
ll s3(ll x) {
	x %= mod;
	return x * (x + 1) % mod * (2 * x + 1) % mod * inv6 % mod;
}
map<ll, ll> m; 
ll S(ll x) {
	if(x <= pn) return s[x];
	if(m[x]) return m[x];
	ll res = s22(x), now = 0, last = 1;
	for(ll l = 2, r; l <= x; l = r + 1) {
		r = x / (x / l);
		now = s3(r);
		res = (res - S(x / l) * (now - last + mod) % mod + mod) % mod;
		last = now;
	}
	res = (res % mod + mod) % mod;
	return m[x] = res;
}                           
int main() {
	scanf("%lld%lld", &mod, &n);
	inv2 = powmod(2, mod - 2);
	inv6 = powmod(6, mod - 2);
	pn = (ll)pow(n, 0.666667);  // n^(2/3)
	sieve(pn);
	ll res = 0, last = 0, now = 0;
	for(ll l = 1, r; l <= n; l = r + 1) {
		r = n / (n / l);
		now = S(r);
		res = (res + (now - last + mod) % mod * s22(n / l) % mod) % mod;
		last = now;	
	}
	res = (res % mod + mod) % mod;
	printf("%lld\n", res);
}

```



## Min25筛

$$
\\S(x,y): F(i)[i<=x and i的最小质因子不小于P_y]
\\pi>n时S(n,i)=0
\\pi<=n时\\S(n,i)=\sum_{j>=i}^{(p_j)^2<=n}\sum_{c=1}^{(p_j)^{c+1}}S(n/p_i,j+1)*F(p_i^c)+F(p_i^{c+1})
+\sum_{x是质数且x<=n}F(x)-\sum_{j=1}^{i-1}F(p_i)
\\F(i)的前缀和答案为S(n,1)+F(1)
$$

```c++
/*
Example1:
欧拉函数前缀和&&莫比乌斯函数前缀和
*/
#include <bits/stdc++.h>

typedef long long ll;
const int N = 500000 << 1; // sqrt(n)*2
int n, m, Sqr, cnt, P[N >> 2], h[N], w[N];
ll sp[N], g[N];

inline int ID(int x) { return x <= Sqr ? x : m - n / x + 1; }

// g:前缀质数和
// h:前缀质数个数
void Init(int n) {
    Sqr = sqrt(n);
    cnt = m = 0;
    for (ll i = 1; i <= n; i = w[m] + 1ll)
        w[++m] = n / (n / i), g[m] = (1ll * w[m] * ((ll) w[m] + 1) >> 1) - 1,
        h[m] = w[m] - 1;
    for (int i = 2; i <= Sqr; ++i)
        if (h[i] != h[i - 1]) {
            459
            Algorithm
            Library
            by forever97
            P[++cnt] = i, sp[cnt] = sp[cnt - 1] + i;
            int lim = i * i;
            for (int j = m; lim <= w[j]; --j) {
                int k = ID(w[j] / i);
                g[j] -= 1ll * i * (g[k] - sp[cnt - 1]);
                h[j] -= h[k] - cnt + 1;
            }
        }
}

// 欧拉函数前缀和
ll S_Phi(int x, int y) {
    if (x <= 1 || P[y] > x) return 0;
    ll res = g[ID(x)] - h[ID(x)] - sp[y - 1] + y - 1; // g-h
    for (int i = y; i <= cnt && P[i] * P[i] <= x; ++i)
        for (ll p = P[i], p1 = p, t = p - 1; 1ll * p1 * p <= x; p1 *= p, t *= p)
            res += 1ll * (S_Phi(x / p1, i + 1) + p) * t;
    return res;
}

// 莫比乌斯函数前缀和
int S_Mu(int x, int y) {
    if (x <= 1 || P[y] > x) return 0;
    int res = -h[ID(x)] + y - 1; // h
    for (int i = y; i <= cnt && P[i] * P[i] <= x; ++i)
        res -= S_Mu(x / P[i], i + 1);
    return res;
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        if (!n)
            puts("0 0");
        else {
            Init(n);
            printf("%lld %d\n", S_Phi(n, 1) + 1, S_Mu(n, 1) + 1);
        }
    }
    return 0;
}
/*
Example2:
F(1)=1
F(p^c)=p xor c(p的c次的函数值为p和c的异或值)
F(ab)=F(a)F(b) gcd(a,b)==1
求F前缀和(n<=10^10)
460
Algorithm Library by forever97
Solution:
除了2之外，p xor 1等于p-1，
因此我们可以用质数常函数前缀g和质数前缀个数函数h
来计算 _{x是质数且x<=n}F(x)
*/
#include <bits/stdc++.h>

typedef long long ll;
const int N = 100000 << 1 | 1; // sqrt(n)*2
const int P = 1e9 + 7;
int m, cnt, pri[N >> 2], h[N];
ll n, Sqr, sp[N], g[N], w[N];

inline int ID(ll x) { return x <= Sqr ? x : m - n / x + 1; }

// g:前缀质数和
// h:前缀质数个数
void Init(ll n) {
    Sqr = sqrt(n);
    cnt = m = 0;
    for (ll i = 1; i <= n; i = w[m] + 1) {
        w[++m] = n / (n / i);
        ll t = w[m] % P;
        g[m] = (t * (t + 1) >> 1) % P - 1;
        h[m] = w[m] - 1;
    }
    for (int i = 2; i <= Sqr; ++i) {
        if (h[i] != h[i - 1]) {
            pri[++cnt] = i, sp[cnt] = sp[cnt - 1] + i;
            ll lim = 1ll * i * i;
            for (int j = m; lim <= w[j]; --j) {
                int k = ID(w[j] / i);
                g[j] -= i * (g[k] - sp[cnt - 1]);
                h[j] -= h[k] - cnt + 1;
            }
        }
        g[i] %= P;
    }
}

ll S(ll x, int y) {
    if (x <= 1 || pri[y] > x) return 0;
    ll res = g[ID(x)] - g[ID(pri[y - 1])] + P;
    for (int i = y; i <= cnt && 1ll * pri[i] * pri[i] <= x; ++i) {
        for (ll p = pri[i], p1 = p, j = 1; p1 * p <= x; p1 *= p, ++j)
            res += S(x / p1, i + 1) * (pri[i] ^ j) + (pri[i] ^ (j + 1));
    }
    return res % P;
}

int main() {
    461
    Algorithm
    Library
    by forever97
    scanf("%lld", &n);
    Init(n);
    for (int i = 1; i <= m; ++i) g[i] = (g[i] - h[i] + (i > 1) * 2 + P) % P;
    printf("%lld\n", (S(n, 1) + 1) % P);
    return 0;
}
/*
Example3:
对任意p为素数，
p%4==1时有f(p^c)=3*c+1
p%4!=1时f(p^c)=1
对于非质数有
f(a*b)=f(a)*f(b) gcd(a,b)==1
Solution:
处理g[n][r]表示前缀%4==r的质数个数，可以通过Min25预处理
设G[n]等于4*g[n][1]+g[n][3]，对于唯一素数2特殊处理，n>1时G[n]++
G[n]=F(x)_x为小于n的质数，G[pri[i-1]]=_{j=1}^{i-1}F(p_i)
套Min25得到f前缀和即可
*/
#include <bits/stdc++.h>

typedef long long ll;
const int N = 50000 << 1 | 1; // sqrt(n)*2
int n, m, Sqr, pnum, pri[N >> 2], w[N];
ll g[N][4], sp[N][4], G[N];

inline int ID(int x) { return x <= Sqr ? x : m - n / x + 1; }

int F(int p, int k) {
    if (p % 4 == 1) return 3 * k + 1;
    return 1;
}

bool notp[N];

void sieve() {
    memset(notp, 0, sizeof(notp));
    notp[0] = notp[1] = 1;
    pnum = 0;
    for (int i = 2; i < N; i++) {
        if (!notp[i]) {
            pri[++pnum] = i;
            for (int r = 0; r < 4; ++r)
                sp[pnum][r] = sp[pnum - 1][r] + (i % 4 == r);
        }
        for (int j = 1; j <= pnum && pri[j] * i < N; j++) {
            notp[pri[j] * i] = 1;
            if (i % pri[j] == 0) break;
        }
    }
}
void Init(int n) {
    Sqr = sqrt(n);
    m = 0;
    ll j;
    for (ll i = 1; i <= n; i = w[m] + 1ll) {
        w[++m] = n / (n / i);
        for (int r = 0; r < 4; r++) {
            if (r == 0)
                g[m][r] = w[m] / 4;
            else
                g[m][r] = w[m] / 4 + (w[m] % 4 >= r);
            if (r == 1) g[m][r]--;
        }
    }
    for (int i = 1; i <= pnum; ++i) {
        ll lim = 1ll * pri[i] * pri[i];
        for (int j = m; lim <= w[j]; --j) {
            int k = ID(w[j] / pri[i]);
            for (int r = 0; r < 4; ++r) {
                g[j][r * pri[i] % 4] -= g[k][r] - sp[i - 1][r];
            }
        }
    }
    for (int i = 1; i <= m; i++) G[i] = g[i][1] * 4 + g[i][3] + (i > 1);
}

ll S(ll x, int y) {
    if (x <= 1 || pri[y] > x) return 0;
    ll res = G[ID(x)] - G[pri[y - 1]];
    for (int i = y; i <= pnum && 1ll * pri[i] * pri[i] <= x; ++i) {
        for (ll p = pri[i], p1 = p, j = 1; p1 * p <= x; p1 *= p, ++j)
            res += S(x / p1, i + 1) * F(pri[i], j) + F(pri[i], j + 1);
    }
    return res;
}

int T;

int main() {
    sieve();
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &n);
        Init(n);
        printf("%lld\n", S(n, 1) + 1);
    }
    return 0;
}
```



# 数学

## 蔡勒公式（1582以后）

```c++
int WhatDay(int year, int month, int dday) {//0是周日，1是周一，6是周六
    if(month < 3) {
        year -= 1; month += 12;
    }
    int c=int(year / 100), y = year - 100 * c;
    int w=int(c / 4) - 2 * c + y + int(y / 4) + (26 * (month + 1) / 10) + dday - 1;
    w = (w % 7 + 7) % 7;
    return w;
}
```

## 逆波兰

```c++
/**
样例输入
2
1.000+2/4=
((1+2)*5+1)/4=
样例输出
1.50
4.00
*/
#include <bits/stdc++.h>
using namespace std;
int Judge(char ch) {
    //运算符进行优先级划分
    if(ch == '+') return 1;
    if(ch == '-') return 1;
    if(ch == '*') return 2;
    if(ch == '/') return 2;
    if(ch == '(') return 0;
    if(ch == ')') return 0;
}
int main() {
    string str;
    string s;
    int count ;
    cin>>count;
    while(count--) {
        int i=0 ;
        str.clear();
        s.clear() ;
        cin>>str;
        stack<char>mid; //字符串栈 ，用于中缀表达式转后缀表达式
        stack<double>ans;//数字栈 ，用于后缀表达式求值
        while(str[i] != '=') {
            if(str[i] == '(') {//判断，左括号进栈
                mid.push(str[i]);
                i++;
            }
            else if( str[i] == ')') {//遇右括号则将左括号及左括号以上标识符出栈
                while(mid.top()!='(') {
                    s = s + mid.top() ;
                    s += ' ';
                    mid.pop() ;
                }
                mid.pop() ;
                i++;
            }
            else if(isdigit(str[i])) {//数字或小数点则直接转入后缀表达式
                while(str[i]<='9'&&str[i]>='0' || str[i] =='.') {
                    s = s + str[i];
                    i++;
                }
                s += ' ';
            }
            else if(str[i] == '+'||str[i] == '-'||str[i] == '*'||str[i] == '/') {
                while(!mid.empty() && Judge(mid.top()) >= Judge(str[i])) {
                //当前运算标识符优先级低于栈顶元素，进行出栈操作
                    s = s + mid.top();
                    s = s + ' ';
                    mid.pop();
                }
                mid.push(str[i]);//将当前运算符进栈
                i++;
            }
        }
        while(!mid.empty()) {//将最后剩余运算符出栈
            s = s + mid.top() ;
            s = s + ' ';
            mid.pop() ;
        }
        string temp;
        stringstream ss(s);
        char a[1000];
        double num;
        while(ss>>temp) {
            if(isdigit(temp[0])) {
                for(i = 0; i < temp.length(); i++)
                    a[i] = temp[i];
                a[i] ='\0';//最后必须赋 '\0' 否则报错
                num = atof(a);
                //将数字字符串转为数字
                //注意atof()函数不支持string类型，支持char()
                ans.push(num);//将数字进栈
            }
            else {// 运算符操作
                double x,y;
                x = ans.top();
                ans.pop();
                y = ans.top();
                ans.pop();
                //取出栈顶两位元素 ，进行相应操作
                if(temp == "+") num = x + y;
                if(temp == "-") num = y - x;
                if(temp == "*") num = x * y;
                if(temp == "/") num = y / x;
                ans.push(num);//得到元素进栈
            }
        }
        cout<< fixed <<setprecision(2)<<ans.top()<<endl;//输出两位小数；
    }
}
```

## 斐波那契

斐波那契数列拥有许多有趣的性质，这里列举出一部分简单的性质：

1、卡西尼性质（Cassini's identity）：  $F_{2n} = F_n (F_{n+1} + F_{n-1})$

2、附加性质： $F_{n+k} = F_k F_{n+1} + F_{k-1} F_n$

3、取上一条性质中 $k=n$，我们得到 $F_{2n} = F_n (F_{n+1} + F_{n-1})$

4、由上一条性质可以归纳证明， $\forall k\in \mathbb{N},F_n|F_{nk}$

5、上述性质可逆，即 $\forall F_a|F_b,a|b$

6、GCD 性质： $(F_m, F_n) = F_{(m, n)}$

7、以斐波那契数列相邻两项作为输入会使欧几里德算法达到最坏复杂度

8、斐波那契数列的通项公式（Binet's Formula）：
$$
 F_n = \frac{\left(\frac{1 + \sqrt{5}}{2}\right)^n - \left(\frac{1 - \sqrt{5}}{2}\right)^n}{\sqrt{5}} 
$$
9、快速倍增求解（常数比矩乘小）。代码如下，返回值是一个二元组$(F_n,F_{n+1})$ 。

```c++

pair<int, int> fib(int n) {
  if (n == 0) return {0, 1};
  auto p = fib(n >> 1);
  int c = p.first * (2 * p.second - p.first);
  int d = p.first * p.first + p.second * p.second;
  if (n & 1)
    return {d, c + d};
  else
    return {c, d};
}
```

10、在模数下，斐波那契有周期性，至多不超过$6n$。$n=2*5^{k}$时，取周期为$6n$。

## 求和公式

$$
\\平方和公式 n * (n + 1) * (2n + 1) / 6
\\立方和公式 (1 + 2 + 3 + .. + n)^2 
\\四次方 (n^8 - 1) / 15
$$

## 组合数学

### 递推式$C_n^m=C_{n-1}^{m-1}+C_{n-1}^{m}$

```c++
//递推式
int c[N][N];
void init() {
	for(int i = 0; i < N; i++) {
		c[i][0] = c[i][i] = 1;
		for(int j = 1; j < i; j++) {
			c[i][j] = c[i - 1][j - 1] + c[i - 1][j];
		}
	}
} 
```

###  公式法$C_n^m=\frac{n!}{(n-m)!m!}$

```c++
ll powmod(ll a, ll b){
	ll res = 1;
	a %= mod;
	while(b) {
		if(b & 1) {
			res = res * a % mod;
		}
		b >>= 1;
		a = a * a % mod;
	}
	return res % mod;
}
ll fac[N], inv[N];
void init() {
	fac[0] = 1;
	for(int i = 1; i < N; i++) {
		fac[i] = fac[i - 1] * i % mod;
	}
	inv[N - 1] = powmod(fac[N - 1], mod - 2);
	for(int i = N - 2; i >= 0; i--) {
		inv[i] = inv[i + 1] * (i + 1) % mod;
	}
}
ll c(ll n, ll m) { // 数据范围很大不够 
	if(m > n) {
		return 0;
	}
	if(m == 0) return 1;
	if(n < N) return fac[n] * inv[m] % mod * inv[n - m] % mod;
	//c(m,k) = m!/(k! * (m - k))= m-k+1~m/(k!)
	ll res = inv[m];
	for(int i = n - m + 1; i <= n; i++) {
		res = res * i % mod;
	}
	return res;
} 
```

### Lucas(n, m 较大， mod较小且为素数 )

```c++
ll lucas(ll n, ll m) {
	if(m == 0) {
		return 1;
	}
	else {
		return c(n % mod, m % mod) * lucas(n / mod, m / mod) % mod;
	}
}
```

### 母函数

$$
\begin{aligned}
&母函数公式:
\\&组合问题:G(x)=\sum a_ix^i
\\&排列问腿:G(x)=\sum a_i\frac{x^i}{i!}

\\&G(x)=\frac{1}{1-x}=1+x+x^2+x^3+x^4+…
\\&G^n(x)=\displaystyle\sum_{k=0}^{\infty}C_{n+k-1}^k*x^k
\\&排列问题的第n项再乘上n！
\end{aligned}
$$

排列代码如下（需求解方程）：

```c++
		vector<double> res(m + 1);//res
		vector<int> h(n + 1);//shuju
		vector<double> tmp(m + 1);
		vector<double> st(m + 1);
		for(int i = 1; i <= n; i++) {
			scanf("%d", &h[i]);
			if(i == 1) {
				for(int j = 0;j <= min(h[i], m); j++) {
					res[j] = 1.0 / fac[j];
				}
				continue;
			}
			for(int j = 0; j <= m; j++) {
				for(int k = 0; k <= h[i] && j + k <= m; k++) {
					tmp[j + k] += res[j] / fac[k];
				}
			}
			res = tmp;
			tmp.clear();
			tmp = st; 
		}
		printf("%.0f\n", res[m] * fac[m]);
```

### 错排

$$
\\D(1)=0,D(2)=1
\\D(n) =(n-1)*(D(n-1)+D(n-2))
\\D(n)=n!*(\frac{1}{2!}-\frac{1}{3!}+\frac{1}{4!}-\frac{1}{5!}+……+(-1)^{n-1}*\frac{1}{(n-1)!}+(-1)^{n}*\frac{1}{n!})
$$



### 二项式反演

$$
f(n)=\sum(-1)^{i}*C_n^i*g(i)
\\g(n)=\sum(-1)^{i}*C_n^i*f(i)
\\常用：f(n)=\sum C_n^i*g(i)
\\	->g(n)=\sum(-1)^{n-i}*C_n^i*f(i)
$$

### 康托展开

​	康托展开可以用来求一个 $[1,n]$的任意排列的排名。

用树状数组统计** **当前有多少个小于它的数还没有出现****。

​	以$[2,5,3,4,1]$举例，排名为$1+4!+3*3!+2!+1=46$。第一个1为从第1名开始排列。

​	逆康托展开：

以删上面的46举例，$\lfloor\frac {45}{4!}\rfloor=1$为比第一位小的有几个数。$45-4！=21$,$\lfloor\frac {21}{3!}\rfloor=3$,说明有三个数小于它。依次类推得到数组$[1,3,1,1,0]$,在权值线段树上求即可，复杂度为$O(nlogn)$

### 各种数

#### 卡特兰数

​	在组合数学中，施罗德数用来描述从(0,0)到(n,n)的格路中，只能使用(1,0)、(0,1)两种移动方式，始终位于对角线下方且不越过对角线的路径数。
$$
\\卡特兰数前n项 :1\ 1\ 2\ 5\ 14\ 42\ 132\ 429\ 1430\ 4862
\\f(n)=f(0)*f(n-1)+...+f(n-1)*f(0) \ \ n \geqslant2
\\f(n)=\frac{4n-2}{n+1} f(n-1)
\\f(n)=\frac{1}{n+1} * C(2n,n)
\\f(n)=C(2n,n)-C(2n,n-1)
$$

#### 斯特林数

##### 第一类斯特林数

​	$a[n][k]$表示**n个两两不同的元素，划分为k个非空圆排列的方案数。**
$$
\begin{aligned}
&递推式：a[n][k]=a[n-1][k-1]+(n-1)*a[n-1][k]
\\&边界：a[n][0]=[n=0]
\end{aligned}
$$

##### 第二类斯特林数

​	$a[n][k]$表示**n个两两不同的元素，划分为k个非空子集的方案数**。
$$
\begin{aligned}
&递推式：a[n][k]=a[n-1][k-1]+k*a[n-1][k]
\\&边界：a[n][0]=[n=0]
\end{aligned}
$$


#### 贝尔数

数列如下(从第0项开始)：$B_n$的意义为**n个集合划分的数目**
$$
1,1,2,5,15,52,203，……
$$
可用贝尔三角形求解，

- 第一行第一项为 1（$a_{1,1}=1$） ；

- 对于$n>1$ ，第 $n$行第一项等于第 $n-1$行的末项 ($a_{n,1}=a_{n-1.n-1}$)；

- 对于 ${n,m>1}$，第$n$ 行的第$m$项等于它左边和左上角两个数之和($a_{n,m}=a_{n,m-1}+a_{n-1,m-1}$)

  部分如果如下：
  $$
  \begin{aligned} & 1 \\ & 1\quad\qquad 2 \\ & 2\quad\qquad 3\quad\qquad 5 \\ & 5\quad\qquad 7\quad\qquad 10\,\,\,\qquad 15 \\ & 15\,\,\,\qquad 20\,\,\,\qquad 27\,\,\,\qquad 37\,\,\,\qquad 52 \\ & 52\,\,\,\qquad 67\,\,\,\qquad 87\,\,\,\qquad 114\qquad 151\qquad 203\\ & 203\qquad 255\qquad 322\qquad 409\qquad 523\qquad 674\qquad 877 \\ \end{aligned}
  $$
  

#### 施罗德数

在组合数学中，施罗德数用来描述从(0,0)到(n,n)的格路中，只能使用(1,0)、(0,1)、(1,1)三种移动方式，始终位于对角线下方且不越过对角线的路径数。

前几项：
$$
1,2,6,22,90,394,1806,8558,41586,206098
$$
推导公式：
$$
S_n=S_{n-1}+\displaystyle\sum_{k=0}^{n-1}S_kS_{n-1-k}
$$
但是，这东西会TLE。所以有新的递推公式，如下
$$
\\F_0=F_1=1
\\(n+1)F_n=(6n-3)F_{n-1}-(n-2)F_{n-1}
\\F_i=2*F_i(i>0)
$$



# 几何

## 运算重载

```c++
struct point {
    double x, y;
    point(double x = 0, double y = 0) : x(x), y(y) {}
    point operator + (const point &t) const {
        return point(x + t.x, y + t.y);
    } //a + b
    point operator - (const point &t) const {
        return point(x - t.x, y - t.y);
    } //a - b
    double operator * (const point &t) const {
        return x * t.x + y * t.y;
    } //a * b
    double operator ^ (const point &t) const {
        return x * t.y - y * t.x;
    } //a X b
    double dis(const point &t) {
        return sqrt((x - t.x) * (x - t.x) + 
					(y - t.y) * (y - t.y));
    }
	point eotate(const point &o, double angle) {//绕p点逆时针转angle角度 
		return point(o.x + (x - o.x) * cos(angle) - (y - o.y) * sin(angle),
					o.y + (x - o.x) * sin(angle) + (y - o.y) * cos(angle));
	}
};
```
## 基本公式

### 外心

```c++
inline point waixin(const point& a, const point& b, const point& c) {
    double a1 = b.x - a.x, b1 = b.y - a.y, c1 = (a1 * a1 + b1 * b1) * 0.5;
    double a2 = c.x - a.x, b2 = c.y - a.y, c2 = (a2 * a2 + b2 * b2) * 0.5;
    double d = a1 * b2 - a2 * b1;
    point ans;
    ans.x = a.x + (c1 * b2 - c2 * b1) / d;
    ans.y = a.y + (a1 * c2 - a2 * c1) / d;
    return ans;
}

```

### 将a,b两个点向内移动距离d 

```c++
void reset(point a,point b,point &t1,point &t2,double d) {
	double db = a.dis(b); 
	double dx = (a.y - b.y) * d / db;
	t1.x = a.x + dx, t2.x = b.x + dx;
	double dy = (b.x - a.x) * d / db;
	t1.y = a.y + dy, t2.y = b.y + dy;
}
```

## 叉积

```c++
double cross(point a, point b, point c) {
	return (b - a) ^ (c - a);//ab X ac  >0逆时针, <0 顺时针 
}
```
### 多边形面积计算

```c++
double getarea(int n) {
    if (n < 3)
        return 0;
    int i;
    double res = 0;
    for (i = 2; i < n; i++) {
        res += fabs(cross(xp[s[0]], xp[s[i - 1]], xp[s[i]]) / 2.0);
    }
    return res;
}//小于0说明c在ab右侧
```

## 极角排序

### atan2函数计算（时间短，精度低） 

```c++
struct point {
    double x, y;
    double angle;
    bool operator < (const point &t) {
        return angle < t.angle;
    }
} p[N];
bool cmp(point a, point b) {
    if (a.angle == b.angle)
        return a.x < b.x;
    else {
        return a.angle < b.angle;
    }
}
for (int i = 1; i <= n; i++) {
    cin >> p[i].x >> p[i].y;
    p[i].angle = atan2(p[i].y, p[i].x);
}
sort(a + 1, a + 1 + n, cmp);

```

### 叉积计算极角（精度高，时间长）

```c++
 double cross(point a, point b, point c) {//计算极角 ab × ac
    return (b - a) ^ (c - a);
}
bool cmp(point a, point b) {
    double f = cross(p[pos], a, b);
    if (f == 0)
        return a.x - p[pos].x < b.x - p[pos].x;
    else if (f > 0)
        return true;
    else
        return false;
}
//如果取的点不是边角要先按照象限排序 
int Quadrant(point a) //象限排序，注意包含四个坐标轴
{
    if (a.x > 0 && a.y >= 0)
        return 1;
    if (a.x <= 0 && a.y > 0)
        return 2;
    if (a.x < 0 && a.y <= 0)
        return 3;
    if (a.x >= 0 && a.y < 0)
        return 4;
}
bool cmp2(point a, point b) //先象限后极角
{
    if (Quadrant(a) == Quadrant(b)) //返回值就是象限
        return cmp(a, b);
    else
        Quadrant(a) < Quadrant(b);
}
```

## pick定理

Pick 定理：给定顶点均为整点的简单多边形，皮克定理说明了其面积$A$和内部格点数目$i$ 、边上格点数目$b$的关系： $A=i+\frac{b}{2} - 1$。

面积由向量叉积求得。

以格子点为顶点的线段，覆盖的点的个数为$gcd(dx,dy)$，其中，$dx,dy$分别为线段横向占的点数和纵向占的点数。如果$dx$或$dy$为0，则覆盖的点数为$dy$或$dx$。

## 扫描线

```c++
#include <algorithm>
#include <cstdio>
#include <cstring>
#define maxn 300
using namespace std;

int lazy[maxn << 3];  // 标记了这条线段出现的次数
double s[maxn << 3];

struct node1 {
  double l, r;
  double sum;
} cl[maxn << 3];  // 线段树

struct node2 {
  double x, y1, y2;
  int flag;
} p[maxn << 3];  // 坐标

//定义sort比较
bool cmp(node2 a, node2 b) { return a.x < b.x; }

//上传
void pushup(int rt) {
  if (lazy[rt] > 0)
    cl[rt].sum = cl[rt].r - cl[rt].l;
  else
    cl[rt].sum = cl[rt * 2].sum + cl[rt * 2 + 1].sum;
}

//建树
void build(int rt, int l, int r) {
  if (r - l > 1) {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    build(rt * 2, l, (l + r) / 2);
    build(rt * 2 + 1, (l + r) / 2, r);
    pushup(rt);
  } else {
    cl[rt].l = s[l];
    cl[rt].r = s[r];
    cl[rt].sum = 0;
  }
  return;
}

//更新
void update(int rt, double y1, double y2, int flag) {
  if (cl[rt].l == y1 && cl[rt].r == y2) {
    lazy[rt] += flag;
    pushup(rt);
    return;
  } else {
    if (cl[rt * 2].r > y1) update(rt * 2, y1, min(cl[rt * 2].r, y2), flag);
    if (cl[rt * 2 + 1].l < y2)
      update(rt * 2 + 1, max(cl[rt * 2 + 1].l, y1), y2, flag);
    pushup(rt);
  }
}

int main() {
  int temp = 1, n;
  double x1, y1, x2, y2, ans;
  while (scanf("%d", &n) && n) {
    ans = 0;
    for (int i = 0; i < n; i++) {
      scanf("%lf %lf %lf %lf", &x1, &y1, &x2, &y2);
      p[i].x = x1;
      p[i].y1 = y1;
      p[i].y2 = y2;
      p[i].flag = 1;
      p[i + n].x = x2;
      p[i + n].y1 = y1;
      p[i + n].y2 = y2;
      p[i + n].flag = -1;
      s[i + 1] = y1;
      s[i + n + 1] = y2;
    }
    sort(s + 1, s + (2 * n + 1));  // 离散化
    sort(p, p + 2 * n, cmp);  // 把矩形的边的纵坐标从小到大排序
    build(1, 1, 2 * n);       // 建树
    memset(lazy, 0, sizeof(lazy));
    update(1, p[0].y1, p[0].y2, p[0].flag);
    for (int i = 1; i < 2 * n; i++) {
      ans += (p[i].x - p[i - 1].x) * cl[1].sum;
      update(1, p[i].y1, p[i].y2, p[i].flag);
    }
    printf("Test case #%d\nTotal explored area: %.2lf\n\n", temp++, ans);
  }
  return 0;
}
```



## 凸包

### 一般凸包

```c++
bool cmp(point a, point b) {
    double f = (a - xp[0]) ^ (b - xp[0]); //与左下边界点的极角
    if (fabs(f) < eps)
        return a.x - xp[0].x < b.x - xp[0].x; //相等按距离排序
    else if (f > 0)
        return true;
    else
        return false;
}
void graham() {
    for (int i = 0; i < pnum; i++) {//pnum为内部点的数目
        if (xp[i].y < xp[0].y || (xp[i].y == xp[0].y && xp[i].x < xp[0].x)) //找到左下方点
            swap(xp[0], xp[i]);
    }
    sort(xp + 1, xp + pnum, cmp);
    if (pnum == 1)
        stack[0] = 0, top = 0; //建栈 找凸包
    else if (pnum == 2)
        stack[0] = 0, stack[1] = 1, top = 1;
    else {//内树大于三个
        stack[0] = 0, stack[1] = 1;
        top = 1;
        for (int i = 2; i < pnum; i++) {
            while (top > 0 && ((xp[stack[top]] - xp[stack[top - 1]]) ^ (xp[i] - xp[stack[top - 1]])) <= 0) {//栈顶的点在当前点和前一个点的连线左侧
                top--;
            }
            stack[++top] = i;
        }
    }
} ///栈里为从左下开始的组成凸包的点

```

### 最大空凸包

```c++
#define N 105
struct point{
   
} p[N], xp[N], O;
int n, pnum;
double dp[N][N], ans;
bool cmp(const point &a, const point &b) {
    double f = (a - O) ^ (b - O); //与左下边界点的极角
    if (f == 0)
        return O.dis(a) < O.dis(b); //相等按距离排序
    else if (f > 0)
        return true;
    else
        return false;
}
void solve() {
    memset(dp, 0, sizeof(dp));
    sort(xp + 1, xp + pnum + 1, cmp);
    for (int i = 1; i <= pnum; i++) {
        int j = i - 1;
        while (j && !((xp[i] - O) ^ (xp[j] - O)))
            j--;
        bool bz = (j == i - 1); //bz==0 为当前为边，==1为当前为顶点
        while (j) {
            int k = j - 1;
            while (k && ((xp[i] - xp[k]) ^ (xp[j] - xp[k])) > 0)
                k--;
            double area = fabs((xp[i] - O) ^ (xp[j] - O)) / 2.0;
            if (k)
                area += dp[j][k];
            if (bz)
                dp[i][j] = area;
            ans = max(ans, area), j = k;
        }
        if (bz) {
            for(int j = 1; j < i; j++)
                dp[i][j] = max(dp[i][j], dp[i][j - 1]);
        }
    }
}

int main() {
    int t;
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        ans = 0;
        for (int i = 1; i <= n; i++) {
            scanf("%lf %lf", &p[i].x, &p[i].y);
        }
        for(int i = 1; i <= n; i++) {
            O = p[i], pnum = 0;
            for (int j = 1; j <= n; j++) {
                if (p[j].y > p[i].y || (p[j].y == p[i].y && p[j].x > p[i].x)) {
                    xp[++pnum] = p[j];
                }
            }
            solve();
        }
        printf("%0.1f\n", ans);
    }
}

```

## 半平面交

### 存点

```c++
//可求最大内接圆，最大半平面交面积
struct point {
    
} p[N], xp[N];
struct line {
    point s, e;
    double k;
    line() {}
    line(point a, point b) { s = a, e = b, k = atan2(b.y - a.y, b.x - a.x); }
    point operator & (const line &b) const { //求两直线交点 
        point res = s;
        double t = ((s - b.s) ^ (b.s - b.e)) / ((s - e) ^ (b.s - b.e));
        res.x += (e.x - s.x) * t;
        res.y += (e.y - s.y) * t;
        return res;
    }
};
int n;
int ans_s; //相交点数
line L[N], q[N];
point ans[N]; //存点
bool cmp(line a, line b) {
    if (fabs(a.k - b.k) <= eps)
        return ((a.s - b.s) ^ (b.e - b.s)) < 0; //平行取下
    return a.k < b.k;
}
void Hpi() {//保证多边形逆时针建边
    int tot = 1;
    sort(L, L + n, cmp);
    for (int i = 1; i < n; i++) {
        if (fabs(L[i].k - L[i - 1].k) > eps) {
            L[tot++] = L[i];
        } //因为平行的时候，左边的线段先判断，所以可以去除无效判定
    }
    int l = 0, r = 1;
    q[0] = L[0];
    q[1] = L[1]; //模拟双端 ，每条线取左删右（顺时针建边取右删左）
    for (int i = 2; i < tot; i++) {
        if (fabs((q[r].e - q[r].s) ^ (q[r - 1].e - q[r - 1].s)) <= eps ||
            fabs((q[l].e - q[l].s) ^ (q[l + 1].e - q[l + 1].s)) <= eps)
            return;               //半平面交不存在
        while (l < r && (((q[r] & q[r - 1]) - L[i].s) ^ (L[i].e - L[i].s)) > eps) 
            //上一个交点在下一条线的右侧，不在半平面交上
            r--;
        while (l < r && (((q[l] & q[l + 1]) - L[i].s) ^ (L[i].e - L[i].s)) > eps) // 同上
            l++;
        q[++r] = L[i]; //加入新边
    }
    while (l < r && (((q[r] & q[r - 1]) - L[l].s) ^ (L[l].e - L[l].s)) > eps)
        r--;
    while (l < r && (((q[l] & q[l - 1]) - L[r].s) ^ (L[r].e - L[r].s)) > eps)
        l++;
    if (r <= l + 1)
        return; //如果只有2个或以下的点，构不成平面
    for (int i = l; i < r; i++) {
        ans[ans_s++] = q[i] & q[i + 1];
    } //ans里存交点
    ans[ans_s++] = q[l] & q[r];
}

```

### 判是否有解

```c++
#define N 110
#define eps 1e-8
#define inf 0x3f3f3f3f3f3f
struct node {
    double u, v, w;
} k[N];
struct point {
    
} p[N];
double dist(point a, point b) {
    return sqrt((a - b) * (a - b));
}
int n, pnum;
point q[N];
int top = 0;
point cross_p(point x, point y, double a, double b, double c) {
//求两个点x,y和该线的交点
    point ans;
    double a2 = y.y - x.y;
    double b2 = x.x - y.x;
    double c2 = x.y * y.x - y.y * x.x; //连接x,y的线段的a,b,c
    ans.y = (a * c2 - a2 * c) / (a2 * b - a * b2);
    ans.x = (b * c2 - b2 * c) / (b2 * a - b * a2);
    return ans;
}
void Hpi(double a, double b, double c) {
    top = 0;
    for (int i = 1; i <= pnum; i++) {
        if (a * p[i].x + b * p[i].y + c <= eps) {//如果上一个边界点满足，则记录
            q[++top] = p[i];
        }
        else {
            if (a * p[i - 1].x + b * p[i - 1].y + c <= eps) {
                //该节点不满足，但上一节点满足
                q[++top] = cross_p(p[i - 1], p[i], a, b, c); 
                //加入两个节点的连线与该线的交点
            }
            if (a * p[i + 1].x + b * p[i + 1].y + c <= eps) {
                //该节点不满足，但下一节点满足    
                q[++top] = cross_p(p[i], p[i + 1], a, b, c);
            }
        }
    }
    for (int i = 1; i <= top; i++)
        p[i] = q[i]; //将更新好的点集返回p
    p[top + 1] = p[1], p[0] = p[top];
    pnum = top;
}
bool solve(int id) {
    p[1] = point(0, 0);
    p[2] = point(inf, 0);
    p[3] = point(inf, inf);
    p[4] = point(0, inf);
    p[0] = p[4], p[5] = p[1];
    pnum = 4; //初始边界为第一象限四个边界点，所以起始点为4个
    double a, b, c;
    for (int i = 1; i <= n; i++) {
        if (i != id && k[id].u <= k[i].u && k[id].v <= k[i].v && k[id].w <= k[i].w)
            return 0; //如果有人3项多比他强，肯定达不到
        if (i == id)
            continue;
        a = (k[i].u - k[id].u) / (k[id].u * k[i].u);
        b = (k[i].v - k[id].v) / (k[id].v * k[i].v);
        c = (k[i].w - k[id].w) / (k[id].w * k[i].w); //得出ax+by=c
        Hpi(a, b, c);
        if (pnum < 3)
            return 0; //如果最后交点数<3，即无法构成平面
    }
    return pnum >= 3;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%lf%lf%lf", &k[i].u, &k[i].v, &k[i].w);
    for (int i = 1; i <= n; i++) {
        if (solve(i))
            printf("Yes\n");
        else
            printf("No\n");
    }
}
```



## 圆的反演

给定反演中心点$O$和反演半径R。点$P$的反演点在射线$OP$上，$|OP| \cdot |OP'| = R^2$。$P$和$P'$互为反演点。

<img src="https://oi-wiki.org/geometry/images/inverse1.png" alt="Inv1" style="zoom:50%;" />

### 性质

1、经过反演中心的圆的直线反演后仍然是直线。

2、经过圆心的圆反演后是反演圆外的一条直线。

3、反演圆上的点反演后仍然是圆上的点。

4、反演圆内的点   圆反演后是圆外的点  圆。

5、相切的性质不会改变

### 公式

记圆$A$半径为$r_1$,其反演图形圆$B$半径为$r_2$,则有：
$$
r_2 = \frac{1}{2}\left(\frac{1}{|OA| - r_1} - \frac{1}{|OA| + r_1}\right) R^2
$$
记点$O$坐标为$(x_0,y_0)$，点A坐标为$(x_1,y_1)$,点B坐标为$(x_2,y_2)$,则有：
$$
x_2 = x_0 + \frac{|OB|}{|OA|} (x_1 - x_0) \\ y_2 = y_0 + \frac{|OB|}{|OA|} (y_1 - y_0)
$$
TIP：当两圆相切时，以相切点为圆心建系。

<img src="C:\Users\29615\AppData\Roaming\Typora\typora-user-images\image-20200915095440546.png" alt="image-20200915095440546" style="zoom:50%;" />

# 动态规划

## 多重背包

```c++
#include <bits/stdc++.h>
using namespace std;
int dp[100100];
int n, m;
//  总物品数，背包容量量
//  01背包
void zodp(int w, int v) {
    for (int j = m; j >= w; j--) {

        dp[j] = max(dp[j], dp[j - w] + v);
    }
}
//  完全背包
void alldp(int w, int v) {
    for (int j = w; j <= m; j++) {
        dp[j] = max(dp[j], dp[j - w] + v);
    }
}
//  多重背包
void muldp(int w, int v, int num) {
    if (w * num >= m) {
        alldp(w, v);
    } else {
        int k = 1;
        while (k <= num) { //倍增放
            zodp(k * w, k * v);
            num -= k;
            k <<= 1; 
        }
        zodp(num * w, num * v);//全部放完
    }
}
struct point {
    int v;//这里v，w等价
    int num;
} a[110];
int main() {
    while (~scanf("%d%d", &n, &m), n + m) {
        for (int i = 1; i <= n; i++) {
            scanf("%d", &a[i].v);
        }
        for (int i = 1; i <= n; i++) {
            scanf("%d", &a[i].num);
        }
        memset(dp, 0, sizeof(dp));
        for (int i = 1; i <= n; i++) {
            muldp(a[i].v, a[i].v, a[i].num);
        }
        int res = 0;
        for (int i = 1; i <= m; i++) {
            if (dp[i] == i)
                res++;
        }
        printf("%d\n", res);
    }
}
```



## 差值数位dp

```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll dp[32][3][3][2][2][2];
int k, w, a, b;
ll dfs(int pos, int dx, int dy, int fw, int lx, int ly) {
//    cout << pos << " " << dx << " " << dy << " " << fw << " " << lx << " " << ly << '\n';
    if(pos < 0) return (dx >= 0 && dy >= 0);
    //dx取值为[-1，1]
	if(dp[pos][dx + 1][dy + 1][fw][lx][ly] != -1) return dp[pos][dx + 1][dy + 1][fw][lx][ly];
    int topx = lx ? ((a >> pos) & 1) : 1;
    int topy = ly ? ((b >> pos) & 1) : 1;
    ll res = 0;
    int dk = (k >> pos) & 1;
    int dw = (w >> pos) & 1;
    for(int i = 0; i <= topx; i++) {
        for(int j = 0; j <= topy; j++) {
            //处理x^y <= w 
            //从高位往下等于或小于 
			if(fw == 0 && ((i ^ j) > dw)) continue;//前面都是等于 这一位不让大于 
            int nxfw = fw || ((i ^ j) < dw);
            
			//处理|x-y| <= k 
            int ndx = dx * 2 + i - j + dk;
            int ndy = dy * 2 + j - i + dk;
            if(ndx <= -2 || ndy <= -2) continue;//-2加不回来了 十进制下应该为-10 
            //dx >= 1时，dx * 2 + i - j + dk >= 1 恒成立 同理  十进制下应该为9 
			ndx = min(1, ndx);
            ndy = min(1, ndy);
            res = res + dfs(pos - 1, ndx, ndy, nxfw, lx && (i == topx), ly && (j == topy));
        }
    }
    return dp[pos][dx + 1][dy + 1][fw][lx][ly] = res;
}
void init() {
    memset(dp, -1, sizeof(dp));
}
int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        init();
        scanf("%d%d%d%d", &a, &b, &k, &w);
        printf("%lld\n", dfs(31, 0, 0, 0, 1, 1));
    }
}

```



# 数据结构

# （一丢丢）

## 分块

```c++
int block, belong[N], num, l[N], r[N], n, q;
ll a[N], lazy[N];
ll v[N];
/*
block:块的大小
belong ： 属于哪一块
num：块的数量
l，r 左右边界 
*/
void build() {
	memset(lazy, 0, sizeof(lazy));
	memset(belong, 0, sizeof(belong));
	block = sqrt(n);
	num = (n + block - 1) / block;
	for(int i = 1; i <= num ; i++) {
		l[i] = (i - 1) * block + 1;
		r[i] = i * block;
	}
	r[num] = n;
	for(int i = 1; i <= n; i++) {
		belong[i] = (i - 1) / block + 1;
		v[belong[i]] += a[i];
	}
}
void update(int x, int y, ll c) {
	if(belong[x] == belong[y]) {
		for(int i = x; i <= y; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
	}
	else {
		for(int i = x; i <= r[belong[x]]; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
		for(int i = belong[x] + 1; i < belong[y]; i++) {
			lazy[i] += c;
		}
		for(int i = l[belong[y]]; i <= y; i++) {
			a[i] += c;
			v[belong[i]] += c;
		}
	}
}
ll ask(int x, int y, ll c) {
	int res = 0;
	if(belong[x] == belong[y]) {
		for(int i = x; i <= y; i++) {
			res = (res + a[i] + lazy[belong[x]]) % (c + 1);
		}
		return res % (c + 1);
	}
	else {
		for(int i = x; i <= r[belong[x]]; i++) {
			res = (res + a[i] + lazy[belong[i]]) % (c + 1);
		}
		for(int i = belong[x] + 1; i < belong[y]; i++) {
			res = (res + v[i] + lazy[i] * block % (c + 1)) % (c + 1);
		}
		for(int i = l[belong[y]]; i <= y; i++) {
			res = (res + a[i] + lazy[belong[i]]) % (c + 1);
		}
		return res;
	}
}
```

