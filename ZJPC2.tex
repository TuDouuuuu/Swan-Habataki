%==============================常用宏包、环境==============================%
\documentclass[twoside,a4paper]{article}
\usepackage{xeCJK} % For Chinese characters
\usepackage{amsmath, amsthm}
\usepackage{listings,xcolor}
\usepackage{geometry} % 设置页边距
\usepackage{fontspec}
\usepackage{graphicx}
\usepackage{fancyhdr} % 自定义页眉页脚
\usepackage{makecell}
\usepackage[breaklinks,colorlinks,linkcolor=black,citecolor=black,urlcolor=black]{hyperref}
\setsansfont{Consolas} % 设置英文字体
\setmonofont[Mapping={}]{Consolas} % 英文引号之类的正常显示，相当于设置英文字体
\geometry{left=1.8cm,right=1cm,top=1.5cm,bottom=0.5cm} % 页边距
% \setlength{\columnsep}{15pt}
% \setlength\columnseprule{0.4pt} % 分割线

\usepackage{xunicode, xltxtra} 
\setmainfont{Microsoft YaHei} 
\usepackage{setspace}
\usepackage{ctex} 
\usepackage[Glenn]{fncychap}
\usepackage{color}
\usepackage{verbatim}
\usepackage{titlesec}
\usepackage{markdown}
 

%==============================常用宏包、环境==============================%
\newfontfamily\monaco{Monaco}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

%==============================页眉、页脚、代码格式设置==============================%
% 页眉、页脚设置

\pagestyle{fancy}
\fancyhead{} %clear all fields
\fancyhead[RO]{\CJKfamily{hei} 第 \thepage 页} %奇数页眉的右边
\fancyhead[LE]{\CJKfamily{hei} 第 \thepage 页} %奇数页眉的右边
% \lhead{CUMTB}
% \lhead{\CJKfamily{hei} Standard Code Library}
% \chead{}
% \rhead{Page \thepage}
% \rhead{\CJKfamily{hei} 第 \thepage 页}
% \lfoot{} 
% \cfoot{}
% \rfoot{\CJKfamily{hei} 第 \thepage 页}
\renewcommand{\headrulewidth}{0.4pt} 
\renewcommand{\footrulewidth}{0.4pt}

% \lstset{
%     language    = c++,
%     numbers     = left,
%     numberstyle = \tiny,
%     breaklines  = true,
%     captionpos  = b,
%     tabsize     = 4,
%     frame       = simple,
%     columns     = fullflexible,
%     commentstyle = \color{gray},
%     keywordstyle = \bfseries\monaco,
%     basicstyle   = \monaco,
%     stringstyle  = \color[RGB]{148,0,209}\ttfamily,
%     rulesepcolor = \color{red!20!green!20!blue!20},
%     showstringspaces = false,
% }

\lstset{
    frame = simple,
    language = c++,
    aboveskip = 3mm,
    belowskip = 3mm,
    showstringspaces = false,
    basicstyle = \monaco,
    numbers = left,
    numberstyle = \tiny\color{gray},
    keywordstyle = \bfseries\monaco,%\fontspec{monaco Bold}\bfseries,
    commentstyle = \color{gray},
    stringstyle = \color{mauve},
    breaklines = true,
    breakatwhitespace = true,
    tabsize = 4
}

%==============================页眉、页脚、代码格式设置==============================%

%==============================标题和目录==============================%
% \title{\CJKfamily{hei} \bfseries Standard Code Library}
% \author{Xavier\_Cai}
% \renewcommand{\today}{\number\year 年 \number\month 月 \number\day 日}

\begin{document}\small
% \begin{titlepage}
% \maketitle
% \end{titlepage}

\newpage
\pagestyle{empty}
\renewcommand{\contentsname}{目录}
\tableofcontents
\newpage\clearpage
\newpage
\pagestyle{fancy}
\setcounter{page}{1}   %new page

%==============================基本操作=============================%
\section{基本操作}

\subsection{快读fread}
\lstinputlisting{杂项/fread.cpp}

\subsection{朝鲜人快读}
\lstinputlisting{基本操作/朝鲜人快读.cpp}

\subsection{\_\_int128}
\lstinputlisting{其它/__int128.cpp}

\subsection{二维离散化}
\lstinputlisting{基本操作/离散化/二维点离散化.cpp}

\subsection{矩阵快速幂}
\lstinputlisting{基本操作/矩阵.cpp}

\subsection{状态压缩}
\lstinputlisting{基本操作/状态压缩.cpp}

\subsection{二进制枚举}
\lstinputlisting{基本操作/二进制枚举.cpp}

\subsection{bitset}
\lstinputlisting{基本操作/bitset.cpp}

\subsection{高效位运算 \_\_builtin\_ 函数}
\lstinputlisting{基本操作/高效位运算.cpp}

\subsection{散列处理异或碰撞}
常用于处理判断出现偶数次（HDU6291），重排后为值域上的连续一段（洛谷P3792、YNOI）。
\lstinputlisting{其它/散列处理异或碰撞.cpp}

\subsection{对拍}
\lstinputlisting{其它/对拍.cpp}


%==============================STL=============================%
\section{STL}

\subsection{unordered\_map对pii进行哈希}
\lstinputlisting{STL/unordered_map对pii进行哈希.cpp}

\subsection{pb\_ds实现平衡树}
\lstinputlisting{STL/pb_ds实现平衡树.cpp}

\subsection{rope}
写一种数据结构，支持任意位置插入、删除和修改
\lstinputlisting{STL/rope.cpp}


%==============================数论=============================%
\section{数论}

\subsection{中国剩余定理}
$\left\{\begin{matrix} x \equiv a_{1} (\mod m_{1})\\ x \equiv a_{2} (\mod m_{2})\\  x \equiv a_{3} (\mod m_{3})\\  x \equiv a_{4} (\mod m_{4})\end{matrix}\right.$ \par
其中，$m_1,m_2,...,m_k$为两两互质的整数
\lstinputlisting{yx数论/中国剩余定理.cpp}

\subsection{二次剩余}
求解 $x^{2} \equiv n (\mod p)$
\lstinputlisting{yx数论/中国剩余定理.cpp}

\subsection{蔡勒公式（1582之后）}
\lstinputlisting{数学/蔡勒公式（1582之后）.cpp}


\subsection{FFT}
\lstinputlisting{yx数论/FFT.cpp}

\subsection{NTT}
\subsubsection{原根}
\lstinputlisting{yx数论/原根.cpp}
\subsubsection{NTT基础}
\lstinputlisting{yx数论/NTT.cpp}
\subsubsection{多项式乘法逆}
\lstinputlisting{yx数论/NTT乘法逆.cpp}
\subsubsection{多项式开方}
\lstinputlisting{yx数论/多项式开根.cpp}
\subsubsection{多项式开方（加强版）}
\lstinputlisting{yx数论/多项式开根_加强版.cpp}
\subsubsection{多项式除法}
\lstinputlisting{yx数论/多项式除法.cpp}
\subsubsection{多项式对数函数}
\lstinputlisting{yx数论/多项式对数函数.cpp}
\subsubsection{多项式指数函数}
\lstinputlisting{yx数论/多项式指数函数.cpp}
\subsubsection{多项式快速幂$O(n \log n)$}
\lstinputlisting{yx数论/多项式快速幂_数学.cpp}
\subsubsection{多项式快速幂$O(n \log ^{2} n)$}
\lstinputlisting{yx数论/多项式快速幂_倍增.cpp}
\subsubsection{多项式快速幂加强版}
\lstinputlisting{yx数论/多项式快速幂_加强版.cpp}
\subsubsection{VI超大常数NTT}
\lstinputlisting{yx数论/VI超大常数NTT.cpp}

\subsection{FWT}
$C_{i} = \sum_{j \bigoplus k = i} A_{j} * B_{k}$ \par
当 $\bigoplus$ 是or, and, xor求$C$
\lstinputlisting{yx数论/FWT.cpp}


%==============================字符串=============================%
\section{字符串}

\subsection{字符串哈希}
\subsubsection{区间一维哈希}
\lstinputlisting{字符串/Hash/Hash.cpp}
\subsubsection{二维哈希}
\lstinputlisting{字符串/Hash/二维Hash.cpp}



\subsection{Next函数}

\subsubsection{求next函数}
\lstinputlisting{字符串/Next函数/求next函数.cpp}

\subsubsection{求出每个循环节的数量和终点位置（HDU1358）}
\lstinputlisting{字符串/Next函数/求出每个循环节的数量和终点位置（HDU1358）.cpp}

\subsubsection{求同时是前缀和后缀的串长（POJ2752）}
\lstinputlisting{字符串/Next函数/求同时是前缀和后缀的串长（POJ2752）.cpp}

\subsubsection{求字符串每个前缀和串匹配成功的次数和（HDU3336）}
\lstinputlisting{字符串/Next函数/求字符串每个前缀和串匹配成功的次数和（HDU3336）.cpp}

\subsubsection{求循环节数量（POJ2406）}
\lstinputlisting{字符串/Next函数/求循环节数量（POJ2406）.cpp}

\subsubsection{求第一个串的前缀和第二个串的后缀的最大匹配（HDU2594）}
\lstinputlisting{字符串/Next函数/求第一个串的前缀和第二个串的后缀的最大匹配（HDU2594）.cpp}

\subsubsection{求补上最少字母数量使得这是个循环串（HDU3746）}
\lstinputlisting{字符串/Next函数/求补上最少字母数量使得这是个循环串（HDU3746）.cpp}

\subsubsection{习题整理}
\textbf{[NOI2014]动物园}\par
对于字符串$S$的前i个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作$num[i]$.\par
$res$为$(num[i]+1)$的乘积.\par
时间复杂度：$O(n).$
\lstinputlisting{字符串/Next函数/习题整理.cpp}

\subsection{KMP}

\subsubsection{统计模式串出现次数，出现位置，前缀border长度}
\lstinputlisting{字符串/KMP/统计模式串出现次数，出现位置，前缀border长度.cpp}

\subsubsection{矩阵加速KMP,求长度为n的不包含长度为m的子串的串个数（[HNOI2008]GT考试）}
$$\sum_{k=0}^{m-1}f[i-1][k]\ast g[k][j]$$\par
$f[i][j]$ 为长串匹配到第$i$位，短串最多可以匹配到第$j$位的方案数\par
$g[j][k]$ 为了计算长度为$j$的已经匹配好了的串可以用多少种数字变为$k$，枚举一个数字，看它在短串中最长可以匹配到最多多长的前缀\par
\lstinputlisting{字符串/KMP/矩阵加速KMP（[HNOI2008]GT考试）.cpp}

\subsection{EXKMP}

\subsubsection{求z函数和LCP}
$LCP$：最长公共前缀\par
$z$函数数组$z$：串$b$与$b$的每一个后缀的$LCP$长度。\par
$extend$数组：串$b$与串$a$的每一个后缀的$LCP$长度。
总时间复杂度：$O(|a|+|b|)$.
\lstinputlisting{字符串/EXKMP/求z函数和LCP.cpp}

\subsubsection{循环位移有多少数比原数大小相等，去重（HDU4333）}
包含对获得的串进行去重。\par
总时间复杂度：$O(n)$
\lstinputlisting{字符串/EXKMP/循环位移有多少数比原数大小相等，去重（HDU4333）.cpp}

\subsubsection{选出$n × n$对并把每一对连接成一个单词求回文对数（POJ3376）}
\lstinputlisting{字符串/EXKMP/例题.cpp}


\subsection{AC自动机}

\subsubsection{标准的AC自动机}
\lstinputlisting{字符串/AC自动机.cpp}

\subsubsection{AC自动机上检查无限长循环串（[POI2000]病毒）}
\lstinputlisting{字符串/AC自动机上检查无限长循环串（[POI2000]病毒）.cpp}

\subsubsection{AC自动机+矩阵快速幂}
有 $m$ 种DNA序列是致病的，问长为 $n$ 且不包含致病序列的DNA有多少种\par
设 $dp[i][j]$ 为走了$j$ 步到达节点 $i$ 的方案数，显然 $dp[0][0]=1$，当 $i \neq 0$ 时，$dp[i][0]=0$。\par
设 $a[i][j]$ 为从节点 $i$ 到达节点 $j$ 是否存在边。\par
最终得 $dp[i][j] = \sum_{x=0}^{N} a[x][i] * dp[x][j-1]$\par
\lstinputlisting{字符串/AC自动机_矩阵快速幂.cpp}

\subsubsection{ac自动机离线}
给你若干个字符串（输入方式奇特），求一个字符串在另一个字符串中出现了几次。\par
1. 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。\par
2. 按一下印有 B 的按键，打字机凹槽中最后一个字母会消失。\par
3. 按一下印有 P 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。\par
询问打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。
\lstinputlisting{字符串/打字机.cpp}


\subsection{字典树/Trie树}
\lstinputlisting{字符串/Trie字典树.cpp}

\subsection{后缀数组SA}

\subsubsection{获取SA和rank数组}
\lstinputlisting{字符串/后缀数组/get_SA.cpp}

\subsubsection{后缀数组+ST表求lcp}
\lstinputlisting{字符串/后缀数组/后缀数组+ST表求lcp.cpp}

\subsubsection{后缀链接字典序最小（arc050\_d）}
\lstinputlisting{字符串/后缀数组/习题整理/后缀连接字典序最小(arc050_d).cpp}

\subsubsection{连续着出现次数最多的字串（SPOJ\_REPEATS)}
\lstinputlisting{字符串/后缀数组/习题整理/连续着出现次数最多的字串（SPOJ_REPEATS).cpp}

\subsection{后缀自动机SAM}

\subsubsection{后缀自动机板子}
\textbf{应用1：不同子串个数}\par
给一个字符串$S$，计算不同子串的个数。\par
解法：利用后缀自动机的树形结构。每个节点对应的不同子串数量(不同位置算作同一个)是$maxlen[i]-maxlen[link[i]]$。\par
总时间复杂度：$O(|S|)$.\par
\textbf{应用2：所有不同子串的总长度}\par
给定一个字符串$S$，计算所有不同子串的总长度。
解法：利用上述后缀自动机的树形结构。每个节点对应的所有后缀长度是$\frac{maxlen[i]\ast (maxlen[i]+1)}{2}$，减去其$linke$节点的对应值$\frac{maxlen[link[i]]\ast (maxlen[link[i]]+1)}{2}$就是该节点的净贡献
\lstinputlisting{字符串/后缀自动机SAM/后缀自动机SAM.cpp}

\subsubsection{每个子串在多少个主串中出现过（SPOJ8093）}
暴力跳Link链.\par
时间复杂度：$均摊O(\sum |S|\sqrt{\sum |S|})$
\lstinputlisting{字符串/后缀自动机SAM/每个子串在多少个主串中出现过（SPOJ8093）.cpp}

\subsubsection{第k小字串}
\lstinputlisting{字符串/后缀自动机SAM/第k小字串（不同位置的相同子串算作一个&多个）（[TJOI2015]弦论）.cpp}

\subsubsection{字典树建后缀自动机}
\lstinputlisting{字符串/后缀自动机SAM/字典树建后缀自动机.cpp}

\subsubsection{暴力在线统计出现次数为k次的字符串个数（HDU4641）}
\lstinputlisting{字符串/后缀自动机SAM/暴力在线统计出现次数为k次的字符串个数（HDU4641）.cpp}


\subsection{Manacher}
\lstinputlisting{字符串/带条件的马拉车.cpp}

\subsection{回文自动机PAM}

\subsubsection{回文自动机PAM}
\lstinputlisting{字符串/回文自动机/回文自动机PAM.cpp}

\subsubsection{前向星PAM}
给定一个长度为n的小写字母串。问你有多少对相交的回文子串（包含也算相交）。
\lstinputlisting{字符串/回文自动机/前向星PAM.cpp}

\subsubsection{前后插入PAM}
\lstinputlisting{字符串/回文自动机/前后插入PAM.cpp}

\subsection{序列自动机（[HEOI2015]最短不公共子串）}
时间复杂度：$O(n|\sum|)$，其中$|\sum|$为字符集大小
\lstinputlisting{字符串/序列自动机.cpp}

\subsection{最小表示法}
时间复杂度：$O(n)$
\lstinputlisting{字符串/最小表示法.cpp}

\subsection{Lyndon分解}
将字符串分成若干部分$s = s_{1}s_{2}s_{3}...s_{m}$，使得每个$s_{i}$都是$Lyndon Word$。\par
$Lyndon Word$：当且仅当$s$是其所有后缀中最小字符串。
\lstinputlisting{字符串/Lyndon分解.cpp}

\subsection{RUNS}
定义一个字符串 $|S|$ 里的一个 run，指其内部一段两侧都不能扩展的周期子串，且周期至少完整出现两次。\par
严格地说，一个 run 是一个 三元组 $(i,j,p)$，满足 $p$ 是 $S[i..j]$ 的最小周期，$j-i+1 \ge 2p$，且满足如下两个条件：\par
1. 要么 $i=1$，要么 $S[i-1]\ne S[i-1+p]$\par
2. 要么 $j=n$，要么 $S[j+1] \ne S[j+1-p]$\par
给定字符串 $S$，求他的所有 $runs$。
\lstinputlisting{字符串/runs.cpp}



%==============================数据结构=============================%

\section{数据结构}

\subsection{ST表}
\lstinputlisting{数据结构/ST表.cpp}


\subsection{树状数组}

\subsubsection{lowbit之和}
\lstinputlisting{数据结构/树状数组/lowbit之和.cpp}

\subsubsection{区间加减+区间和查询}
\lstinputlisting{数据结构/树状数组/区间加减&区间和查询.cpp}

\subsubsection{统计前后顺序不同数字对个数（三维偏序问题）}
\lstinputlisting{数据结构/树状数组/统计前后顺序不同数字对个数（三维偏序问题）.cpp}


\subsection{二维树状数组}

\subsubsection{单点修改+区间查询}
\lstinputlisting{数据结构/二维树状数组/单点修改+区间查询.cpp}

\subsubsection{区间修改+单点查询}
\lstinputlisting{数据结构/二维树状数组/区间修改+单点查询.cpp}

\subsubsection{区间修改+区间查询}
\lstinputlisting{数据结构/二维树状数组/区间修改+区间查询.cpp}


\subsection{线段树}

\subsubsection{单点修改+区间查询}
\lstinputlisting{数据结构/线段树/普通线段树/单点修改&区间查询.cpp}

\subsubsection{区间修改+区间查询}
\lstinputlisting{数据结构/线段树/普通线段树/区间修改&区间查询.cpp}

\subsubsection{区间染色}
\lstinputlisting{数据结构/线段树/普通线段树/区间染色.cpp}

\subsubsection{区间修改+区间查询：矩阵}
\lstinputlisting{数据结构/线段树/普通线段树/区间修改&区间查询_矩阵ver.cpp}

\subsubsection{区间中所有元素都严格出现三次的区间个数（CF1418G）}
\lstinputlisting{数据结构/线段树/普通线段树/区间中所有元素都严格出现三次的区间个数(CF1418G).cpp}

\subsubsection{线段树分裂合并}
\lstinputlisting{数据结构/线段树/普通线段树/线段树分裂合并.cpp}

\subsubsection{单点修改+单点最大连通数（HDU1540）}
\lstinputlisting{数据结构/线段树/普通线段树/单点修改单点最大连通个数.cpp}

\subsubsection{找到最前的长度为k的序列}
\lstinputlisting{数据结构/线段树/普通线段树/区间第一次出现长度为k位置.cpp}

\subsubsection{加乘赋值线段树}
\textbf{1 x y c} $a_{i} = a_{i} + c (x \leq i \leq y)$\par
\textbf{2 x y c} $a_{i} = a_{i} * c (x \leq i \leq y)$\par
\textbf{3 x y c} $a_{i} = c $\par
\textbf{4 x y p} 打印 $a_{x}^{p} + a_{x+1}^{p} + ... +a_{y}^{p}$，$1 \leq p \leq 3$.
\lstinputlisting{数据结构/线段树/普通线段树/加乘赋值线段树.cpp}

\subsection{二维线段树}
\lstinputlisting{数据结构/二维线段树/单点修改+区间查询.cpp}

\subsection{ZKW线段树}

\subsubsection{开局}
\lstinputlisting{数据结构/线段树/ZKW线段树/开局.cpp}

\subsubsection{单点修改+区间查询}
\lstinputlisting{数据结构/线段树/ZKW线段树/单点修改+区间查询.cpp}

\subsubsection{单点修改+区间查询最大字段和}
\lstinputlisting{数据结构/线段树/ZKW线段树/单点修改+区间查询最大子段和.cpp}

\subsubsection{区间加减+单点查询}
\lstinputlisting{数据结构/线段树/ZKW线段树/区间加减+单点查询.cpp}

\subsubsection{区间加减+区间最值查询（lazy标记）}
\lstinputlisting{数据结构/线段树/ZKW线段树/区间加减+区间最值查询(lazy标记).cpp}


\subsection{吉司机线段树}

\subsubsection{区间取$min$+区间查询$O(m \log n)$}
\lstinputlisting{数据结构/JLS树/区间求min区间查询.cpp}

\subsubsection{支持区间加（BZOJ4695 最假女选手）$O(m \log ^{2}n)$}
\lstinputlisting{数据结构/JLS树/区间加.cpp}

\subsubsection{维护区间最值操作与区间历史最值（洛谷 线段树$3$）$O(m \log ^{2}n)$}
给出一个长度为 $n$ 的数列 $A$，同时定义一个辅助数组 $B$，$B$ 开始与 $A$ 完全相同。接下来进行了 $m$ 次操作，操作有五种类型，按以下格式给出：\par
\textbf{1 l r k} 对于所有的 $i\in[l,r]$，将 $A_i$ 加上 $k$（$k$ 可以为负数）。\par
\textbf{2 l r v} 对于所有的 $i\in[l,r]$，将 $A_i$ 变成 $\min(A_i,v)$。\par
\textbf{3 l r} 求 $\sum_{i=l}^{r}A_i$。\par
\textbf{4 l r} 对于所有的 $i\in[l,r]$，求 $A_i$ 的最大值。\par
\textbf{5 l r} 对于所有的 $i\in[l,r]$，求 $B_i$ 的最大值。\par
在每一次操作后，我们都进行一次更新，让 $B_i\gets\max(B_i,A_i)$。\par
\lstinputlisting{数据结构/JLS树/区间最值操作与区间历史最值.cpp}

\subsection{李超线段树}
\subsubsection{函数定点最值（[HEOI2013]Segment）}
\lstinputlisting{数据结构/李超线段树/函数定点最值（[HEOI2013]Segment）.cpp}

\subsubsection{李超上树（[SDOI2016]游戏）$O(m \log ^{3}n)$}
有时，$Alice$ 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 $Alice$ 在点 $r$ 上添加的数字是 $a\times dis + b$。\par
有时，$Bob$ 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。\par
$Bob$ 选择的数字越小越好，但大量的数字让 $Bob$ 眼花缭乱。$Bob$ 需要你帮他找出他能够选择的最小的数字。
\lstinputlisting{数据结构/李超线段树/李超上树.cpp}

\subsection{扫描线}

\subsubsection{矩形并面积}
\lstinputlisting{数据结构/扫描线/矩形并算面积.cpp}

\subsubsection{矩形并周长}
\lstinputlisting{数据结构/扫描线/矩形并周长.cpp}

\subsubsection{矩阵求和最值（POJ-2482）}
不含边框注意！
\begin{table}[h]
    \begin{tabular}{ll}
        \hline
        \thead[l]{input} & \thead[l]{output} \\
        \hline
        2 & \\
        3 5 4 & 5\\
        1 2 3 & \\
        2 3 2 & \\
        6 3 1 & \\
        3 5 4 & 6 \\
        1 2 3 & \\
        2 3 2 & \\
        5 3 1 & \\
        \hline       
    \end{tabular}
    \label{bs}
\end{table}
\lstinputlisting{数据结构/扫描线/矩阵求和最值（POJ-2482）.cpp}

\subsubsection{旋转扫描线}
含边框注意！
\begin{figure}[htb]
\center{\includegraphics[width=6cm]  {数据结构/扫描线/旋转扫描线pic.jpg}}
\end{figure}
\lstinputlisting{数据结构/扫描线/旋转扫描线.cpp}

\subsubsection{三维求面积交}
\lstinputlisting{数据结构/扫描线/三维求面积交.cpp}


\subsection{可持久化线段树（主席树）}

\subsubsection{静态区间第K小}
\lstinputlisting{数据结构/主席树/静态区间第K小.cpp}

\subsubsection{区间内不同数个数}
\lstinputlisting{数据结构/主席树/区间内不同数个数.cpp}

\subsubsection{树上路径点权第K大}
\lstinputlisting{数据结构/主席树/树上路径点权第K大.cpp}

\subsubsection{区间MEX}
\lstinputlisting{数据结构/主席树/区间MEX.cpp}

\subsection{有旋Treap}
\subsubsection{普通平衡树Treap}
\lstinputlisting{数据结构/有旋Treap/普通平衡树Treap.cpp}

\subsubsection{并查集+启发式合并（HDU3726）}
\lstinputlisting{数据结构/有旋Treap/并查集+启发式合并（HDU3726）.cpp}


\subsection{无旋Treap（FHQ Treap）}
\subsubsection{区间翻转}
\lstinputlisting{数据结构/无旋Treap/fhq_treap.cpp}

\subsubsection{可持久化FHQ}
第一行包含一个正整数$n$，表示操作的总数。\par
接下来$n$行，每行包含三个整数，第$i$行记为${v}_{i}$, ${opt}_i$, $x_i$。\par
$v_i$表示基于的过去版本号，${opt}_i$表示操作的序号，$x_i$表示参与操作的数值。
\lstinputlisting{数据结构/无旋Treap/可持久化FHQ.cpp}


\subsection{树套树}

\subsubsection{带修主席树}
\lstinputlisting{数据结构/树套树/带修主席树.cpp}

\subsubsection{区间修改区间查询第K大（[ZJOI2013]K大数查询）}
\lstinputlisting{数据结构/树套树/区间修改区间查询第K大（[ZJOI2013]K大数查询）.cpp}

\subsection{笛卡尔树}
\subsubsection{建树}
\lstinputlisting{数据结构/笛卡尔树/建树.cpp}


\subsection{动态树LCT}

\subsubsection{lct连链、断链、更改点权、查询链上点权异或和}
\lstinputlisting{数据结构/LCT/lct.cpp}

\subsubsection{树上路径染色（[SDOI2011]染色）}
\lstinputlisting{数据结构/LCT/树上路径染色（[SDOI2011]染色）.cpp}

\subsubsection{SAM+线段树+LCT离线统计区间本质不同字串个数}
时间复杂度：$O(n\log^{2}n+q\log n)$.
\lstinputlisting{数据结构/LCT/SAM+线段树+LCT离线统计区间本质不同字串个数.cpp}

\subsubsection{主席树+LCT在线查询区间连通块个数}
\lstinputlisting{数据结构/LCT/主席树+LCT在线查询区间连通块个数.cpp}

\subsection{KD树}

\subsubsection{平面最近点对}
时间复杂度：单次查询最近点的时间复杂度$O(n).$
\lstinputlisting{数据结构/KD树/平面最近点对.cpp}

\subsubsection{K远点对([CQOI2016])}
已知平面内$N$个点的坐标，求欧氏距离下的第$K$远点对。\par
两个点的欧氏距离为$\sqrt{(x_1-x_2)^{2}+(y_1-y_2)^{2}}$\par
原题数据范围：$N\leq 1e5, 1\leq K\leq 100$\par
时间复杂度：$O(kn\log{n}).$
\lstinputlisting{数据结构/KD树/K远点对.cpp}

\subsubsection{高维空间上的操作}
在一个初始值全为$0$的$n\times n$的二维矩阵上，进行若干次操作，每次操作为以下两种之一：\par
\textbf{1 x y A} 将坐标$(x,y)$上的数加上$A$。\par
\textbf{2 x1 y1 x2 y2} 输出以$(x1, y1)$为左下角，$(x2, y2$为右上角的矩形内（包括矩形边界）的数字和。\par
原题数据范围：$1\leq n \leq 5e5, 1\leq q \leq 2e5$\par
时间复杂度：单次查询时间最优$O(\log{n})$， 最坏$O(\sqrt{n})$。将结论扩展至$k$维，最坏复杂度$O(n^{1-\frac{1}{k}})$
\lstinputlisting{数据结构/KD树/高维空间上的操作.cpp}


\subsection{珂朵莉树/老司机树/ODT}
\subsubsection{set实现珂朵莉树}
\textbf{1 l r x} 将$[l,r]$区间所有数加上$x$\par
\textbf{2 l r x} 将$[l,r]$区间所有数改成$x$\par
\textbf{3 l r x} 输出将$[l,r]$区间从小到大排序后的第$x$个数是的多少(即区间第$x$小，数字大小相同算多次，保证$1\leq x \leq r-l+1$)\par
\textbf{4 l r x y} 输出$[l,r]$区间每个数字的$x$次方的和模$y$的值(即$\sum ^ {r}_{i=l} a_i^x \% y$)\par
时间复杂度：用set实现$O(n\log \log {n})$\par
如果要保证复杂度正确，必须保证数据随机。\par
\lstinputlisting{数据结构/ODT/set实现珂朵莉树.cpp}


\subsection{01字典树}

\subsubsection{路径为点权异或值求最小生成树（CF888G）}
\begin{table}[h]
    \begin{tabular}{ll}
        \hline
        \thead[l]{input} & \thead[l]{output} \\
        \hline
        4  \\ 1 2 3 4 &  8 \\
        \hline       
    \end{tabular}
    \label{bs}
\end{table}
\lstinputlisting{数据结构/01字典树/路径为点权异或值求最小生成树（CF888G）.cpp}

\subsubsection{可持久化01字典树}
初始有$n$个数，有$m$个操作:\par
\textbf{1 A x} 添加操作，表示在序列末尾添加一个数 $x$ ，序列的长度 $n+1$\par
\textbf{Q l r x} 询问操作，你需要找到一个位置 $p$ ，满足$l \le p \le r$，使得：$ a[p] \oplus a[p+1] \oplus ... \oplus a[N] \oplus x$最大，输出最大是多少。
\lstinputlisting{数据结构/01字典树/可持久化01字典树.cpp}



\subsection{左偏树（可并堆）}

\subsubsection{左偏树$O(\log n)$}
\lstinputlisting{数据结构/左偏树/LT.cpp}

\subsubsection{带push\_down操作的左偏树子树节点合并（[JLOI2015]城池攻占）}
小铭铭最近获得了一副新的桌游，游戏中需要用 m 个骑士攻占 n 个城池。这 n 个城池用 1 到 n 的整数表示。除 1 号城池外，城池 i 会受到另一座城池 fi 的管辖，其中 fi <i。也就是说，所有城池构成了一棵有根树。这 m 个骑士用 1 到 m 的整数表示，其中第 i 个骑士的初始战斗力为 si，第一个攻击的城池为 ci。\par
每个城池有一个防御值 hi，如果一个骑士的战斗力大于等于城池的生命值，那么骑士就可以占领这座城池；否则占领失败，骑士将在这座城池牺牲。占领一个城池以后，骑士的战斗力将发生变化，然后继续攻击管辖这座城池的城池，直到占领 1 号城池，或牺牲为止。\par
除 1 号城池外，每个城池 i 会给出一个战斗力变化参数 ai;vi。若 ai =0，攻占城池 i 以后骑士战斗力会增加 vi；若 ai =1，攻占城池 i 以后，战斗力会乘以 vi。注意每个骑士是单独计算的。也就是说一个骑士攻击一座城池，不管结果如何，均不会影响其他骑士攻击这座城池的结果。\par
现在的问题是，对于每个城池，输出有多少个骑士在这里牺牲；对于每个骑士，输出他攻占的城池数量。\par
\lstinputlisting{数据结构/左偏树/带push_down操作的左偏树子树节点合并（[JLOI2015]城池攻占）.cpp}

%================================分块================================%
\section{分块}

\subsection{区间加法求和}
\lstinputlisting{分块/区间加法求和.cpp}

\subsection{询问区间内小于某个值的元素个数}
\lstinputlisting{分块/询问区间内小于某个值的元素个数.cpp}

\subsection{询问区间内某个值的前驱}
\lstinputlisting{分块/询问区间内某个值的前驱.cpp}

\subsection{区间寻找某个数并赋值}
\lstinputlisting{分块/区间寻找某个数并赋值.cpp}

\subsection{区间最小众数}
\lstinputlisting{分块/区间最小众数.cpp}

\subsection{莫队}

\subsubsection{区间查询，统计两个相同概率}
\lstinputlisting{分块/莫队算法/区间查询，统计两个相同概率.cpp}
\subsubsection{时间戳+统计有多少个不同的数}
\lstinputlisting{分块/莫队算法/时间戳+统计有多少个不同的数.cpp}
\subsubsection{树状数组维护区间两数之差}
\lstinputlisting{分块/莫队算法/树状数组维护区间两数之差.cpp}
\subsubsection{统计有多少个不同的数}
\lstinputlisting{分块/莫队算法/统计有多少个不同的数.cpp}
\subsubsection{回滚莫队}
\lstinputlisting{分块/莫队算法/回滚莫队.cpp}
\subsubsection{普通莫队代替回滚莫队（AT1219）}
IOI 国历史研究的第一人——JOI 教授，最近获得了一份被认为是古代 IOI 国的住民写下的日记。JOI 教授为了通过这份日记来研究古代 IOI 国的生活，开始着手调查日记中记载的事件。\par
日记中记录了连续 NN 天发生的时间，大约每天发生一件。
事件有种类之分。第 ii 天发生的事件的种类用一个整数 $X_i$ 表示，$X_i$ 越大，事件的规模就越大。\par
JOI 教授决定用如下的方法分析这些日记：\par
1. 选择日记中连续的几天 $[L,R]$ 作为分析的时间段；定义事件 $A$ 的重要度 $W_A$​ 为 A× $T_{A}$，其中 $T_A$ 为该事件在区间 $[L,R]$中出现的次数。\par
2. 现在，您需要帮助教授求出所有事件中重要度最大的事件是哪个，并输出其重要度。
\lstinputlisting{分块/莫队算法/普通莫队代替回滚莫队（AT1219）.cpp}

%================================杂项================================%
\section{杂项}

\subsection{数列归纳}

$f(n) = \frac{(2*n + 1)!}{(n + 1)}$\par
1, 3, 40, 1260, 72576, \par
6652800, 889574400, 163459296000, 39520825344000, 12164510040883200, \par
4644631106519040000, 2154334728240414720000, 1193170003333152768000000, 777776389315596582912000000\par

~\\

$f(n) = \sum_{i=1}^{n} p, p \in prime$\par
转$min_25筛$\par
0, 2, 5, 10, 17, 28, 41, 58, 77, 100, \par
129, 160, 197, 238, 281, 328, 381, 440, 501, 568, \par
639, 712, 791, 874, 963, 1060, 1161, 1264, 1371, 1480, \par
1593, 1720, 1851, 1988, 2127, 2276, 2427, 2584, 2747, 2914, \par
3087, 3266, 3447, 3638, 3831, 4028, 4227, 4438, 4661, 4888\par
\par

~\\

卡特兰数\par
1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452...


\subsection{CDQ}
\subsubsection{三位偏序$O(n \log n \log k)$}
$n$：元素的数量，$k$：最大属性值。\par
有$n$个元素，第$i$个元素有$a_i$,$b_i$,$c_i$三个属性，设$f(i)$表示满足$a_j \leq a_i$且$b_j \leq b_i$且$c_j \leq c_i$且$j \ne i$的$j$的数量。\par
对于$d\in [0, n)$，求$f(i)=d$的数量。
\lstinputlisting{杂项/CDQ/三位偏序.cpp}

\subsection{LCA}
\lstinputlisting{杂项/LCA.cpp}

\subsection{全1矩阵个数（51nod1291）}
\begin{table}[h]
    \begin{tabular}{ll}
        \hline
        \thead[l]{input} & \thead[l]{output} \\
        \hline
        3 3 & \\
        011 & 6 3 0\\
        110 & 3 1 0\\
        100 & 1 0 0\\
        \hline       
    \end{tabular}
    \label{bs}
\end{table}
\lstinputlisting{杂项/全1矩阵个数（51nod1291）.cpp}

\subsection{华容道}
\lstinputlisting{其它/华容道.cpp}

\subsection{希尔伯特曲线}
\begin{figure}[htb] 
 \center{\includegraphics[width=15cm]  {其它/希尔伯特曲线_pic.png}} 
 \end{figure}
\lstinputlisting{其它/希尔伯特曲线.cpp}

\subsection{非整数希尔伯特曲线}
\lstinputlisting{其它/非整数希尔伯特曲线.cpp}

\subsection{约瑟夫环}
\subsubsection{一般方法}
\lstinputlisting{其它/约瑟夫环/一般方法.cpp}
\subsubsection{函数图像解}
\lstinputlisting{其它/约瑟夫环/函数图像解.cpp}

%=============================计算几何==============================%
\section{计算几何}

\subsection{长方体在三维空间中运动离目标点最近距离（2017ICPC青岛H）}
\lstinputlisting{yx计算几何/长方体在空间中运动离目标点最近距离（2017ICPC青岛H）.cpp}

\subsection{最小球覆盖（模拟退火）}
\lstinputlisting{yx计算几何/最小球覆盖.cpp}

\subsection{求n个点的带权类费马点（模拟退火）}
\lstinputlisting{yx计算几何/求n个点的带权类费马点.cpp}

%=============================动态规划==============================%
\section{动态规划}

\subsection{\#2 字符串T在字符串S子序列出现的次数}
\lstinputlisting{动态规划/2_字符串T在字符串S子序列出现的次数.cpp}

\subsection{\#3 N种长度为1元素填充L}
\lstinputlisting{动态规划/3_N种长度为1元素填充L.cpp}

\subsection{\#4 分割数组}
\lstinputlisting{动态规划/4_分割数组.cpp}

\subsection{\#5 划分为K个相等的子集}
\lstinputlisting{动态规划/5_划分为K个相等的子集.cpp}


%==============================JAVA&PYTHON==============================%
\section{Java \& Python}
eclipse下ALT+/，自动补全代码。

\subsection{Java}
\lstinputlisting[language=java]{xaveir/javaBasic.txt}
\lstinputlisting[language=java]{xaveir/javaExcrt.txt}

\subsection{Python}
\subsubsection{python}
\lstinputlisting[language=python]{xaveir/python.txt}
\subsubsection{计算表达式}
\lstinputlisting[language=python]{python/计算表达式.py}
\subsubsection{正则表达式}
\lstinputlisting[language=python]{python/正则表达式.py}

%==============================YNOI==============================%

\section{YNOI}
\subsection{带修查询能否连续重排为值域连续的序列（线段树+散列异或）（洛谷P3792）}
\textbf{1 x y} 修改$x$位置的值为$y$\par
\textbf{2 l r} 查询区间$[l,r]$是否可以重排为值域上连续的一段\par
\lstinputlisting {数据结构/YNOI系列/带修查询能否连续重排为值域连续的序列（线段树+散列异或）（洛谷P3792）.cpp}

%==============================习题整理==============================%
\section{习题整理}

\subsection{可重边集的点能否和当前询问边构成三角形（20牛客2H）（动态点开线段树）}
\begin{table}[h]
    \begin{tabular}{ll}
        \hline
        \thead[l]{input} & \thead[l]{output} \\
        \hline
        8   & \\
        1 1 & \\
        3 1 & No \\
        1 1 & \\
        3 2 & No \\
        3 1 & Yes \\
        1 2 & \\
        2 1 & \\
        3 1 & No \\
        \hline       
    \end{tabular}
    \label{bs}
\end{table}
\lstinputlisting{习题整理/可重边集的点能否和当前询问边构成三角形（20牛客2H）（动态点开线段树）.cpp}

\subsection{左偏树离线处理查询成立最多数（HDU5575）}
$0$代表没有水，$1$代表有水\par
\begin{table}[h]
    \begin{tabular}{ll}
        \hline
        \thead[l]{input} & \thead[l]{output} \\
        \hline
        3 4   & 3 \\
        3 4 & \\
        1 3 1 & \\
        2 1 0 & \\
        2 2 0 & \\
        3 3 1 & \\
        \hline       
    \end{tabular}
    \label{bs}
\end{table}
\lstinputlisting{习题整理/左偏树离线处理查询成立最多数（HDU5575）.cpp}


\subsection{图上加边最多最少连通块（线段树二分贪心）（ZOJ4100）}
时间复杂度：$O(q \log ^ {2} n)$.
\lstinputlisting{习题整理/图上加边最多最少连通块（线段树二分贪心）.cpp}

\subsection{错排后字典序最小（ZOJ4102）}
时间复杂度：$O(n \log n)$.
\lstinputlisting{习题整理/错排后字典序最小（ZOJ4102）.cpp}

\subsection{若干个区间选数字使相与之和最小（ZOJ4135）}
\lstinputlisting{习题整理/若干个区间选数字使相与之和最小（ZOJ4135）.cpp}

\subsection{2019徐州L}
给一颗字符串树，1为根，求从哪个结点向上L长度的字符串共有多少种本质不同的字符串
\lstinputlisting{习题整理/2019徐州L.cpp}

\subsection{双哈希（2019CCPC哈尔滨L）}
给定一个$n$个数的数字序列，第$i$个数为$a[i]$，每次操作会将$a[i]$插入或移到最前端：\par
1.若$a[i]$已经在序列中出现过，则将其移到最前端，并删除原出现位置\par
2.若$a[i]$未出现过，则直接将其插入到最前端\par
\lstinputlisting{习题整理/双哈希（2019CCPC哈尔滨L）.cpp}


\subsection{最短的涵盖从1到i的线段（线段树）}
给定$n$个数的序列，对于每一个$m$，求最短的涵盖从$1$到$i$的线段的长度。\par
$R_{i,l}$代表以$l$为线段左端点，包含数从$1$~$i$中所有数字的最近右端点。\par
对于$i+1$来说，其所在的位置为$p_{1},p_{2},p_{3},...,p_{k}$。这些数将长度为$n$的区间划分为若干部分，如下所示：\par
[1, $p_{1}$]，[$p_{1}+1$, $p_{2}$]，...，[$p_{k}+1$,$n$]
对于每一个区间，其内部所有的 $l$ 在从 $R_{i,l}$ 转移至 $R_{i+1,l}$ 时，式子为$R_{i+1,l}$ = $max(R_{i,l}, \ p_{k})$\par
其中，$p_{k}$代表其所在区间的右端点。\par
特别的，当所在的 $l$ 位于最后一个线段中，不可能构成包含数从 $1$~$i$ 中所有数字的线段，此时应将 $R_{i+1,l}$ 置为无穷大，也就是取不到\par
显然在任何情况下 $R_{i,l}$ 是**单调递增**的。最后，将问题转移成了对于每一个区间，找到 $R_{i,l} < p_{k}$ 的一段数并将其值赋为 $p_{k}$ 。这个操作可以利用线段树进行维护。
\lstinputlisting{习题整理/最短的涵盖从1到i的线段（线段树）.cpp}

\subsection{二分线段树DP（成电多校HDU6606）}
给定 $n$ 个数，在不改变数的排序状态的情况下，取前 $x$ 个数，将这 $x$个数分为 $k$ 段，要求每段的和的最大值最小，问这个值是多少。\par
考虑对二分后的值进行check，需要在二分后中的check中进行DP操作。\par
题解给出了一个DP转移式子：$dp[i] = max(dp[j]) + 1$ ，其中 $dp[j]$ 要求满足：$sum[i] - sum[j] \leq x$ （ $sum[i]$ 代表第$i$位的前缀和，$x$ 为枚举的 $mid$ ）并且 $i \leq j$ 。\par
将 $sum[i] - sum[j] ≤ x$ 转化 $sum[j] ≥ sum[i] - x$ 。\par
将 $sum[i]$ 离散化后作为线段树下标进行维护，维护的值为 $dp[i]$ 。那么就是在区间 $[val2id(sum[i] - x), m]$ 中找到最大的值，其中 $val2id(sum[i] - x)$ 是离散化后的 $sum[i] - x$ 的值，$m$ 为离散化后的数字数目。
\lstinputlisting{习题整理/二分线段树DP（成电多校HDU6606）.cpp}

\subsection{CRT+线段树乱搞（HDU5238）}
给出 $n$ 个操作，只含有加、乘、次方计算。有两种操作：\par
1. 询问一个数 $x$，将这个 $x$ 把所有给出需要的计算式来计算一遍。\par
2. 将其中某一步计算修改。\par
\lstinputlisting{习题整理/CRT+线段树乱搞（HDU5238）.cpp}

\subsection{曼哈顿距离转切比雪夫距离+大力分类讨论线段树（2018ICPC沈阳E）}
在无限宽广的二维平面上，分布着 $n$ 个忍者，他们各自的派别，有 $m$ 个操作，共 $3$ 种：\par
1. 将编号为 $k$ 的忍者的位置变为 $(x'+x, y'+y)$。\par
2. 将编号为 $k$ 的忍者的派别变为 $c$。\par
3. 询问编号在 $[l,r]$ 之间的忍者中，派别不同的最大的曼哈顿距离。\par
\lstinputlisting{习题整理/曼哈顿距离转切比雪夫距离+大力分类讨论线段树（2018ICPC沈阳E）.cpp}

\subsection{只选一个区间听课（CF1452E）}
给定 $m$ 个人，他们感兴趣的区间在 $[1,n]$ 的区间内，有两个老师进行授课，老师们的授课区间长度为 $k$，每个人只能听一个老师授课，求所有人听到课的长度总和最大。\par
对于一个老师和一个同学，当老师区间从左向右移动时，同学能听到的课的长度为0->最大->0，因此贪心地想能够在中点处达到最大。\par
对每个同学的中点位置进行排序，将中点位置小的排在前面，重点位置大的排在后面，从后往前扫，每次记录 $[j,m]$ 位同学能够达到的和的最大值，用这个作为第二个老师授课的根据。\par
再枚举第一个老师的授课位置，枚举听第一个老师授课的同学数量，再加上之前记录的听第二个授课老师的 $[j,m]$ 位同学能够达到的和的最大值，求最大值。\par
\lstinputlisting{习题整理/只选一个区间听课（CF1452E）.cpp}

\subsection{图上倍增+后缀数组（2017ICPC沈阳）}
给定一张图有 $N$ 个点，编号为 $0,...,N-1$，每个点都从自身有一条到点 $i^{2}+1$ 的边（有向），点上有点权，点权为 $0,...,9$，走过一条路径最终获得的字符串为点权字符串拼起来。问走 $N$ 步，能得到的最大字符串为多少。
\lstinputlisting{习题整理/图上倍增+后缀数组（2017ICPC沈阳）.cpp}

\subsection{寻找一个半字串\_式子转换+马拉车+主席树（2017CCPC哈尔滨A）}
1234543212345 是按照5和1对称的，那么在保证5和1是回文串的状态下，要能够之间相互覆盖。\par
设5的位置为 $i$，1的位置为 $j$, 要求 $i \leq j$，则可得公式\par
$
\left\{\begin{matrix}
j-i \leq len[i] \\
j-i \leq len[j] \\
\end{matrix}\right.
$\par
移动式子，可得\par
$
\left\{\begin{matrix}
j \leq i+len[i] \\
j-len[j] \leq i \\
\end{matrix}\right.
$\par
将其转化为区间 $[i+1, i+len[i]]$ 内求有多少个数，使得 $j-len[j] \leq i$。
\lstinputlisting{习题整理/式子转换+马拉车+主席树（2017CCPC哈尔滨A）.cpp}

\subsection{区间子集和的MEX}
给定一个序列，有以下几种操作：\par
1. 将第 $x$ 位置的数修改为 $y$。\par
2. 询问区间 $[L, R]$，问其子集之和的 MEX。\par
首先有一个性质：先看看是否存在 $1$。若没有 $1$，则表明必然无法凑出 $1$，那么答案就是 $1$。\par
然后假设上一次求出来的和的值为 $x$，表明 $[1,x]$ 都可以通过子集表示出来。再求 $[1,x+1]$ 的和，若和 $[1,x]$ 求和的值相等，则表示 $x+1$ 不能被表示。\par
最坏情况为斐波那契数列。
\lstinputlisting{习题整理/区间子集和的MEX.cpp}

\subsection{询问中位数区间（[国家集训队]middle）}
一个长度为 $n$ 的序列 $a$，设其排过序之后为 $b$，其中位数定义为 $b_{n/2}$，其中 $a,b$ 从 $0$ 开始标号,除法取下整。\par
给你一个长度为 $n$ 的序列 $s$。\par
回答 $Q$ 个这样的询问：$s$ 的左端点在 $[a,b]$ 之间，右端点在 $[c,d]$ 之间的子区间中，最大的中位数。\par
其中 $a<b<c<d$。\par
位置也从 $0$ 开始标号。\par
我会使用一些方式强制你在线。\par
\lstinputlisting{习题整理/询问中位数区间.cpp}

\subsection{双线段树根据最终状态判断}
n只猴子坐在椅子上，有m次区间更新（笑话）， 没听过这个笑话的猴子会掉到地上，原来听过这个笑话的猴子会做到椅子上。问你最后有几只猴子坐在椅子上\par
猴子最后的状态其实只与他最后听到的那个笑话有关
\lstinputlisting{习题整理/双线段树根据最终状态判断.cpp}

\subsection{围墙算容积}
\includegraphics[width=15cm]{习题整理/围墙算容积.jpg}
\lstinputlisting{习题整理/围墙算容积.cpp}

\subsection{推格子（HDU多校FHQ）}
\includegraphics[width=15cm]{习题整理/推格子.jpg}
\lstinputlisting{习题整理/推格子（HDU多校FHQ）.cpp}

\subsection{询问$T$有多少本质不同的字串在$S$的$[l,r]$区间中没有出现过（[NOI2018]你的名字）}
\lstinputlisting{习题整理/你的名字.cpp}


\subsection{多个循环串有多少本质不同的公共子串}
结论：两个无限循环串的 LCS 的循环节不超过长串循环节的三倍
\lstinputlisting{习题整理/牛客8kuangbin结论.cpp}

\subsection{选三个数构成三角形的概率}
\lstinputlisting{习题整理/选三个数构成三角形的概率.cpp}

\subsection{NIM博弈+吉老师线段树（2020南京）}
给定一串石子堆$b_{i}$，有如下两种操作：\par
1. 将区间 $[l,r]$ 中的石子堆中的石子数量变为 $max(b_{i}, x)$。\par
2. 取出区间 $[l,r]$ 中的石子堆，新增第 $r-l+2$ 个石子堆，其中石子数量为 $x$。询问有多少种方法拿石子使得转变为必胜态。\par
\par
Nim博弈中，必胜态为异或和为0，将题意转成有多少种方法拿石子使得最后的异或和为0。\par
1. 若当前 $r-l+1$ 个石子堆的异或和为 $0$，则不能够移动石子，输出 $0$。\par
2. 若当前 $r-l+1$ 个石子堆的异或和不为 $0$。设当前异或和为 $sum$，需要操作的石子堆个数为 $y$，则需要拿走 $y-sum \bigoplus y$ 个才能成立。然后开始参考出题人题解。先求前 $r-l+1$ 个数字的 $sum$ 的最高为 $1$的位为 $1$，再求 $x$ 能否满足要求。\par
在 \textbf{push\_up} 操作时，维护一个最小值次小值、二进制当前区间在这个位是1的个数之和。\par
在 \textbf{push\_tag} 操作时，对于异或和，根据最小值的数量的奇偶性来判断是否变化。如果是最小值的数量是奇数，则需要异或上 $tg \bigoplus fi\_min$ 才行。（$fi\min$ 是区间最小值），转化过程为：设要异或上的值为 $z$，则得到 $fi\_min \bigoplus z = tg$，通过移项可得 $z = tg \bigoplus fi\_min$；如果最小值的数量为偶数，则什么都不做。然后修改二进制当前区间在这个位是1的个数之和的值。再是吉老师线段树 \textbf{push\_tag} 的常规操作。
\lstinputlisting{习题整理/2020南京.cpp}

\subsection{01字典树上大力分类讨论（2020济南）}
MianKing has a sequence $a_{1...n}$  and he wants to answer $Q$ queries about it.\par
Let $f(a,S,K)$ denote the K-th smallest number of sequence $b_{1...n}$ which satisfies that $\forall i \in [1,n]$, $b_i=a_i~xor~S$\par
Now for each query, give you $L,R,K$ you need to answer $Min_{S=L}^{R}f(a,S,K)$
\lstinputlisting{习题整理/2020济南.cpp}

\subsection{区间LCM}
$1 \leq a_{i} \leq 2e5$\par
\lstinputlisting{习题整理/区间LCM.cpp}

\subsection{区间不超过x的最大字串和（Gym102920I）}
\lstinputlisting{习题整理/区间不超过x的最大字串和.cpp}

%==============================st1vdy计算几何==============================%
\section{他人计算几何}
\subsection{st1vdy}
\lstinputlisting{st1vdy.cpp}
\subsection{forever97}
\lstinputlisting{forver97.cpp}

\end{document}