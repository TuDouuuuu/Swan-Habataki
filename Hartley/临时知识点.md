[TOC]



## 并查集-路径压缩

```c++
int pre[MAXN];
int find(int x) {
    while(x != pre[x])
        x = pre[x] = pre[pre[x]];
    return x;
}
void init() {
    for(int i = 1; i < MAXN; i++)
        pre[i] = i;
}
```



## 并查集-按秩合并

```c++
const int MAXN = 10005;
int pre[MAXN], deep[MAXN];
void init() {
    for(int i = 0; i < MAXN; i++) {
        pre[i] = i;
        deep[i] = 1;
    }
}
int find(int now) {
    while(now != pre[now])
        now = pre[now];
    return now;
}
bool AZunion(int u, int v) {
    int r1 = find(u);
    int r2 = find(v);
    if(r1 == r2)
        return false;
    if(deep[r1] > deep[r2])
        swap(r1, r2);
    pre[r1] = r2;
    if(deep[r1] == deep[r2])
        deep[r2]++;
    return true;
}
```

## 最小生成树

## prim堆优化：$O(mlog^n)$

```C++
// 前向星
//---------------------------------------------
int dis[MAXN];
int vis[MAXN];
int prim(int n, int m) {
    memset(dis, INF, sizeof dis);
    priority_queue<pii, vector<pii>, greater<pii> >q;
    dis[1] = 0;
    q.push(mp(0, 1));
    int sum = 0, cnt = 0;
    while(!q.empty() && cnt < n) {
        int d = q.top().fi, u = q.top().se;
        q.pop();
        if(vis[u])
            continue;
        vis[u] = 1;
        cnt ++;
        sum += d;
        for(int i = head[u]; i; i = e[i].next)
            if(e[i].w < dis[e[i].to]) {
                dis[e[i].to] = e[i].w;
                q.push(mp(e[i].w, e[i].to));
            }
    }
    return sum;
}
```

## kruskal：$O(mlog^m)$

```C++
struct edge {
    int u, v, w;
} e[MAXM];
//--------------------------------------------
// 并查集
//---------------------------------------------
int kruskal(int n, int m) {
    for(int i = 1; i <= n; i++)
        pre[i] = i;
    auto cmp = [&](edge a, edge b) {
        return a.w < b.w;
    };
    sort(e + 1, e + m + 1, cmp);
    int sum = 0, cnt = 0;
    for(int i = 1; i <= m; i++) {
        int r1 = find(e[i].u);
        int r2 = find(e[i].v);
        if(r1 == r2)
            continue;
        pre[r1] = r2;
        sum += e[i].w;
        if(++cnt == n - 1)
            break;
    }
    return sum;
}
```

## boruvka：$O((n+m)log^n)$

```C++
struct edge {
    int u, v, w, f = 0;
} e[MAXM];
//--------------------------------------------
// 并查集
//---------------------------------------------
int minn[MAXN];
void check(int u, int id) {
    if(!minn[u]) {
        minn[u] = id;
        return;
    }
    int x = minn[u];
    if(e[id].w < e[x].w || e[id].w == e[x].w && id < x)
        minn[u] = id;
}
int boruvka(int n, int m) {
    for(int i = 1; i <= n; i++)
        pre[i] = i;
    int sum = 0;
    int update = 1;
    while(update) { // 最多更新logn次
        update = 0;
        memset(minn, 0, sizeof minn);
        for(int i = 1; i <= m; i++) {
            int r1 = find(e[i].u);
            int r2 = find(e[i].v);
            if(e[i].f || r1 == r2)
                continue;
            check(r1, i);
            check(r2, i);
        }
        for(int i = 1; i <= n; i++) {
            int id = minn[i];
            if(id != 0 && !e[id].f) {
                update = 1;
                e[id].f = 1;
                int r1 = find(e[id].u);
                int r2 = find(e[id].v);
                pre[r1] = r2;
                sum += e[id].w;
            }
        }
    }
    return sum;
}
```

## kruskal重构树

![](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\无标题.jpg)



原树中的点为重构树中的叶节点，原树中n-1条边变成重构树中新的n-1个点。

性质：

1. 原树中两点路径上的边权最大值为重构树上两点LCA的权值
2. 按最小生成树建立的话，重构树是一个大根堆

```c++
// 结构体数组
// 前向星
//---------------------------------------------
int val[MAXN];// MAXN要开2倍
int ex_kruskal(int n, int m) {
    for(int i = 1; i < 2 * n; i++)
        pre[i] = i;
    auto cmp = [&](edge a, edge b) { 
        return a.w < b.w;
    };
    sort(e + 1, e + m + 1, cmp); // 结构体数组
    int ind = n;
    for(int i = 1; i <= m; i++) {
        int r1 = find(e[i].u);
        int r2 = find(e[i].v);
        if(r1 == r2)
            continue;
        pre[r1] = pre[r2] = ++ind;
        val[ind] = e[i].w;
        add_edge(ind, r1, e1[i].w); // 前向星
        add_edge(ind, r2, e1[i].w);
        if(ind == 2 * n - 1)
            break;
    }
    return ind;
}
```



## 最近公共祖先

### 倍增求LCA：$O(nlog^n )$

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e4 + 5;
const int MAXM = 1e4 + 5;
//并查集----------------------
int pre[MAXN], deep[MAXN];
int find(int now) {
    while(now != pre[now])
        now = pre[now];
    return now;
}
bool AZunion(int u, int v) {
    int r1 = find(u);
    int r2 = find(v);
    if(r1 == r2)
        return false;
    if(deep[r1] > deep[r2])
        swap(r1, r2);
    pre[r1] = r2;
    if(deep[r1] == deep[r2])
        deep[r2]++;
    return true;
}
//前向星----------------------
struct edge {
    int to, next, w;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v, int w) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].w = w;
    head[u] = cnt;
}
//LCA--------------------------
int dep[MAXN], f[MAXN][25];
int dis[MAXN][25];
void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for(int i = 1; (1 << i) <= dep[u]; i++) {
        f[u][i] = f[f[u][i - 1]][i - 1];
        dis[u][i] = dis[u][i - 1] + dis[f[u][i - 1]][i - 1];
    }
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)//去掉双向边
            continue;
        dis[v][0] = e[i].w;
        dfs(v, u);
    }
}
int lca(int x, int y) {
    int ans = 0;
    if(dep[x] < dep[y])
        swap(x, y);
    for(int i = 20; i >= 0; i--) {
        if(dep[f[x][i]] >= dep[y]) {
            ans += dis[x][i];
            x = f[x][i];
        }
        if(x == y)
            return ans;
    }
    for(int i = 20; i >= 0; i--)
        if(f[x][i] != f[y][i]) {
            ans += dis[x][i] + dis[y][i];
            x = f[x][i];
            y = f[y][i];
        }
    ans += dis[x][0] + dis[y][0];
    return ans;
}
void init() {
    for(int i = 0; i < MAXN; i++) {
        pre[i] = i;
        deep[i] = 1;
    }
    cnt = 0;
    memset(head, 0, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(f, 0, sizeof f);
    memset(dis, 0, sizeof dis);
}
int main() {
    int n, m, c;
    while(~scanf("%d%d%d", &n, &m, &c)) {
        init();
        for(int i = 0; i < m; i++) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            AZunion(u, v);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        set<int>root;
        for(int i = 1; i <= n; i++)
            root.insert(find(i));
        for(auto i = root.begin(); i != root.end(); i++)
            dfs(*i, 0);
        for(int i = 0; i < c; i++) {
            int x, y;
            scanf("%d%d", &x, &y);
            int r1 = find(x), r2 = find(y);
            if(r1 != r2)
                printf("Not connected\n");
            else
                printf("%d\n", lca(x, y));
        }
    }
}
```

### 基于rmq求LCA：$O(nlog^n)，常数较大$

按照dfs序把节点存入数组，总共存入$2n-1$个数。

求2个节点第一次出现的区间内深度最小的点，即为LCA。

```c++
pii a[MAXN * 2];
pii dp[MAXN * 2][25];
inline void init_rmq(int n) {
    for(int i = 1; i <= n; i++)
        dp[i][0] = a[i];
    for(int j = 1; (1 << j) <= n; j++)
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 << j - 1)][j - 1]);
}
int pos[MAXN]; // 节点第一次出现的位置
inline int LCA(int x, int y) {
    int L = min(pos[x], pos[y]);
    int R = max(pos[x], pos[y]);
    int k = log(R - L + 1) / log(2);
    return min(dp[L][k], dp[R - (1 << k) + 1][k]).se;
}
int dep[MAXN], len = 0;
void dfs(int u, int fa) {
    pos[u] = ++len;
    dep[u] = dep[fa] + 1;
    a[len] = mp(dep[u], u);
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        dfs(v, u);
        a[++len] = mp(dep[u], u);
    }
}
void init(){
    len = 0;
}
int main() {
    //...
    init();
    dfs(r, 0);
    init_rmq(len);
    //...
}
```



## 求组合数

```c++
double C[305][305];
void getComb() {
    memset(C, 0, sizeof C);
    for(int i = 0; i <= 300; i++) {
        C[i][0] = C[i][i] = 1.0;
        for(int j = 1; j < i; j++)
            C[i][j] = C[i - 1][j] + C[i - 1][j - 1];
    }
}
```

## 求卡特兰数

```c++
ll qpow(ll a, ll b) {
    ll ans = 1;
    while(b) {
        if(b & 1)
            ans = ans * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}
ll Inv[MAXN];
ll inv(ll a) { //mod为素数
    return qpow(a, mod - 2);
}
ll ktl[MAXN];
void init() {
    for(int i = 0; i < MAXN; i++)
        Inv[i] = inv(i);
    ktl[1] = 1;
    for(int i = 2; i < MAXN; i++)
        ktl[i] = 1ll * (ktl[i - 1] * (4 * i - 2) % mod) * Inv[i + 1] % mod;
}
```



## 主席树

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 5;
int ls[MAXN << 5], rs[MAXN << 5], sum[MAXN << 5], rt[MAXN];
int cnt = 0;
int build(int l, int r) {
    int root = ++cnt;
    sum[root] = 0;
    if(l < r) {
        int mid = (l + r) >> 1;
        ls[root] = build(l, mid);
        rs[root] = build(mid + 1, r);
    }
    return root;
}
int update(int ori, int l, int r, int pos) { //覆盖更新ori节点
    int now = ++cnt;
    ls[now] = ls[ori];
    rs[now] = rs[ori];
    sum[now] = sum[ori] + 1;//个数+1
    if(l < r) {
        int mid = (l + r) >> 1;
        if(mid >= pos)//判断更新左节点还是右节点
            ls[now] = update(ls[now], l, mid, pos);
        else
            rs[now] = update(rs[now], mid + 1, r, pos);
    }
    return now;
}
int query(int u, int v, int l, int r, int k) {//返回区间第k小的标号
    if(l == r)
        return l;
    int mid = (l + r) >> 1;
    int x = sum[ls[v]] - sum[ls[u]];
    if(x >= k)
        return query(ls[u], ls[v], l, mid, k);
    else
        return query(rs[u], rs[v], mid + 1, r, k - x);
}
int a[MAXN], b[MAXN], ulen;
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", a + i);
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    ulen = unique(b + 1, b + n + 1) - b - 1;
    rt[0] = build(1, ulen);
    for(int i = 1; i <= n; i++) {
        int pos = lower_bound(b + 1, b + ulen + 1, a[i]) - b;
        rt[i] = update(rt[i - 1], 1, ulen, pos);
    }
    while(m--) {
        int L, R, k;
        scanf("%d%d%d", &L, &R, &k);
        int ans = query(rt[L - 1], rt[R], 1, ulen, k);
        printf("%d\n", b[ans]);
    }
}
```

## 静态树上第k大

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;
const int MAXM = MAXN;
//主席树----------------------------------------------------------------
int a[MAXN], b[MAXN], ulen;
int ls[MAXN << 5], rs[MAXN << 5], sum[MAXN << 5], rt[MAXN];
int cnt1 = 0;
int build(int l, int r) {
    int root = ++cnt1;
    sum[root] = 0;
    if(l < r) {
        int mid = (l + r) >> 1;
        ls[root] = build(l, mid);
        rs[root] = build(mid + 1, r);
    }
    return root;
}
int update(int ori, int l, int r, int pos) { //覆盖更新ori节点
    int now = ++cnt1;
    ls[now] = ls[ori];
    rs[now] = rs[ori];
    sum[now] = sum[ori] + 1;//个数+1
    if(l < r) {
        int mid = (l + r) >> 1;
        if(mid >= pos)//判断更新左节点还是右节点
            ls[now] = update(ls[now], l, mid, pos);
        else
            rs[now] = update(rs[now], mid + 1, r, pos);
    }
    return now;
}
int query(int u, int v, int LCA, int lca_fa, int l, int r, int k) { //返回区间第k小的标号
    if(l == r)
        return l;
    int mid = (l + r) >> 1;
    int x = sum[ls[u]] + sum[ls[v]] - sum[ls[LCA]] - sum[ls[lca_fa]];
    if(x >= k)
        return query(ls[u], ls[v], ls[LCA], ls[lca_fa], l, mid, k);
    else
        return query(rs[u], rs[v], rs[LCA], rs[lca_fa], mid + 1, r, k - x);
}
//前向星--------------------------------------------------------------------
struct edge {
    int to, next;
} e[MAXM * 2]; //双倍内存
int cnt2 = 0;
int head[MAXN];
void add_edge(int u, int v) { //从1开始存
    e[++cnt2].to = v;
    e[cnt2].next = head[u];
    head[u] = cnt2;
}
//LCA----------------------------------------------------------------------
int dep[MAXN], f[MAXN][25];
void dfs(int u, int fa) {
    //dfs序建主席树
    int pos = lower_bound(b + 1, b + ulen + 1, a[u]) - b;
    rt[u] = update(rt[fa], 1, ulen, pos);
    //处理f数组
    dep[u] = dep[fa] + 1;
    for(int i = 1; (1 << i) <= dep[u]; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)//去掉双向边
            continue;
        f[v][0] = u;
        dfs(v, u);
    }
}
int lca(int x, int y) {
    if(dep[x] < dep[y])
        swap(x, y);
    for(int i = 20; i >= 0; i--) {
        if(dep[f[x][i]] >= dep[y])
            x = f[x][i];
        if(x == y)
            return x;
    }
    for(int i = 20; i >= 0; i--)
        if(f[x][i] != f[y][i]) {
            x = f[x][i];
            y = f[y][i];
        }
    return f[x][0];
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", a + i);
        b[i] = a[i];
    }
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }
    sort(b + 1, b + n + 1);
    ulen = unique(b + 1, b + n + 1) - b - 1;
    rt[0] = build(1, ulen);
    dfs(1, 0);
    while(m--) {
        int u, v, k;
        scanf("%d%d%d", &u, &v, &k);
        int LCA = lca(u, v);
        int lca_fa = f[LCA][0];
        int ans = query(rt[u], rt[v], rt[LCA], rt[lca_fa], 1, ulen, k);
        printf("%d\n", b[ans]);
    }
}
```



## LCA离线做法：tarjan $O(n+q)$

eg：遍历到6时，5已被访问，由5向上找到最深的未回溯节点1作为LCA

![图片描述](https://segmentfault.com/img/bVbbH3W?w=635&h=350)

```c++
//并查集----------------------
//前向星----------------------
vector<pii> ask[MAXN];
int vis[MAXN], ans[MAXN];
void tarjan(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        tarjan(v, u);
        pre[v] = u; // v回溯
    }
    for(int i = 0; i < SZ(ask[u]); i++) {
        int v = ask[u][i].fi;
        int id = ask[u][i].se;
        if(vis[v]) // 已经访问到
            ans[id] = find(v); // 最深的未回溯节点
    }
    vis[u] = 1;
}
void init(int n) {
    for(int i = 0; i <= n; i++) {
        pre[i] = i;
        ask[i].clear();
    }
    cnt = 0;
    memset(head, 0, sizeof head);
    memset(vis, 0, sizeof vis);
    memset(ans, 0, sizeof ans);
}
int main() {
    int n, q, r;
    scanf("%d%d%d", &n, &q, &r);
    init(n);
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }
    for(int i = 0; i < q; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        ask[u].pb(mp(v, i));
        ask[v].pb(mp(u, i));
    }
    tarjan(r, 0);
    for(int i = 0; i < q; i++)
        printf("%d\n", ans[i]);
}
```



## 重链剖分

**性质：一个节点到根的路径上的轻边不会超过$log^n$条。**

**第一遍dfs，预处理f、dep、stree、Son数组。**

![img](https://images2018.cnblogs.com/blog/1397737/201805/1397737-20180510124458843-1858715148.png)



**第二遍dfs，预处理top、id、rk数组。**

![img](https://images2018.cnblogs.com/blog/1397737/201805/1397737-20180510124617970-666005311.png)

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int mod;
const int MAXN = 1e5 + 5;
const int MAXM = 1e5 + 5;
int val[MAXN];//各节点值
//前向星-----------------------------
struct edge {
    int to, next;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
//重链剖分---------------------------------------
int dep[MAXN], f[MAXN][25], stree[MAXN], Son[MAXN];
void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    stree[u] = 1;
    f[u][0] = fa;
    for(int i = 1; (1 << i) <= dep[u]; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)//去掉双向边
            continue;
        dfs(v, u);
        stree[u] += stree[v];
        if(stree[v] > stree[Son[u]])//重儿子更新
            Son[u] = v;
    }
}
int top[MAXN];//重链顶端
int id[MAXN];//点标号->dfs序号
int rk[MAXN];//dfs序号->点标号
int cnt2 = 0;
void dfs2(int u, int t) { //连接重链
    top[u] = t;
    id[u] = ++cnt2;
    rk[cnt2] = u;
    if(!Son[u])
        return;
    dfs2(Son[u], t);
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v != Son[u] && v != f[u][0]) //排除两条边
            dfs2(v, v);
    }
}
//线段树------------------------------------
struct node { //线段树节点
    int l, r;
    ll w, f;
} tree[4 * MAXN]; //四倍空间
void build(int k, int nl, int nr) {
    tree[k].l = nl;
    tree[k].r = nr;
    if(tree[k].l == tree[k].r) {
        tree[k].w = val[rk[tree[k].l]];
        return;
    }
    int m = (nl + nr) / 2;
    build(2 * k, nl, m);
    build(2 * k + 1, m + 1, nr);
    tree[k].w = (tree[2 * k].w + tree[2 * k + 1].w) % mod;
}
void down(int k) { //懒标记下传
    tree[2 * k].f += tree[k].f;
    tree[2 * k + 1].f += tree[k].f;
    tree[2 * k].w += 1ll * tree[k].f * (tree[2 * k].r - tree[2 * k].l + 1) % mod;
    tree[2 * k].w %= mod;
    tree[2 * k + 1].w += 1ll * tree[k].f * (tree[2 * k + 1].r - tree[2 * k + 1].l + 1) % mod;
    tree[2 * k + 1].w %= mod;
    tree[k].f = 0;
}
ll query(int k, int x, int y) { //区间求和
    if(x == tree[k].l && y == tree[k].r)
        return tree[k].w;
    if(tree[k].f)
        down(k);
    int m = (tree[k].l + tree[k].r) >> 1;
    if(y <= m)
        return query(k << 1, x, y);
    else if(x > m)
        return query(k << 1 | 1, x, y);
    else
        return (query(k << 1, x, m) + query(k << 1 | 1, m + 1, y)) % mod;
}
void change_interval(int k, int a, int b, int x) { //区间修改
    if(a <= tree[k].l && b >= tree[k].r) {
        tree[k].w += 1ll * (tree[k].r - tree[k].l + 1) * x % mod;
        tree[k].w %= mod;
        tree[k].f += x;
        return;
    }
    if(tree[k].f)
        down(k);
    int m = (tree[k].l + tree[k].r) / 2;
    if(a <= m)
        change_interval(2 * k, a, b, x);
    if(b > m)
        change_interval(2 * k + 1, a, b, x);
    tree[k].w = (tree[2 * k].w + tree[2 * k + 1].w) % mod;
}
void add_path(int x, int y, int z) {
    int tx = top[x], ty = top[y];
    while(tx != ty) {
        if(dep[tx] >= dep[ty]) {
            change_interval(1, id[tx], id[x], z);
            x = f[tx][0];
            tx = top[x];
        } else {
            change_interval(1, id[ty], id[y], z);
            y = f[ty][0];
            ty = top[y];
        }
    }
    int L = min(id[x], id[y]), R = max(id[x], id[y]);
    change_interval(1, L, R, z);
}
ll sum_path(int x, int y) {
    ll ans = 0;
    int tx = top[x], ty = top[y];
    while(tx != ty) {
        if(dep[tx] >= dep[ty]) {
            ans = (ans + query(1, id[tx], id[x])) % mod;
            x = f[tx][0];
            tx = top[x];
        } else {
            ans = (ans + query(1, id[ty], id[y])) % mod;
            y = f[ty][0];
            ty = top[y];
        }
    }
    int L = min(id[x], id[y]), R = max(id[x], id[y]);
    ans = (ans + query(1, L, R)) % mod;
    return (ans % mod + mod) % mod;
}
void add_tree(int root, int z) {
    int max_id = id[root] + stree[root] - 1;
    change_interval(1, id[root], max_id, z);
}
ll sum_tree(int root) {
    int max_id = id[root] + stree[root] - 1;
    return query(1, id[root], max_id);
}
int main() {
    int n, m, root;
    scanf("%d%d%d%d", &n, &m, &root, &mod);
    for(int i = 1; i <= n; i++)
        scanf("%d", val + i);
    for(int i = 0; i < n - 1; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add_edge(u, v);
        add_edge(v, u);
    }
    dfs(root, 0);
    dfs2(root, 0);
    build(1, 1, n);
    while(m--) {
        int op;
        scanf("%d", &op);
        if(op == 1) {
            int x, y, z;
            scanf("%d%d%d", &x, &y, &z);
            add_path(x, y, z);
        } else if(op == 2) {
            int x, y;
            scanf("%d%d", &x, &y);
            printf("%lld\n", sum_path(x, y));
        } else if(op == 3) {
            int x, z;
            scanf("%d%d", &x, &z);
            add_tree(x, z);
        } else {
            int x;
            scanf("%d", &x);
            printf("%lld\n", sum_tree(x));
        }
    }
}
```

## 长链剖分

![img](https://cdn.luogu.com.cn/upload/pic/73806.png)

**性质：**

1. **一个节点到根的路径上的短边不会超过$O(\sqrt n)$条。**

2. **一个节点的 k 级祖先所在的长链长大于等于 k。**

3. **可以做到$O(nlog^n)$预处理，$O(1)$单次查询k级祖先。**

   每条长链的顶点 $x$ 存向上 $len[x]$ 个祖先和向下 $len[x]$ 个长链上的点

   令 $w=⌊log_2^k⌋$，先跳到 $2^w$ 级祖先 $tmp$ ，还要向上走 $k'=k-2^w$ 步

   ∵ $len[tmp]≥2^w>k'$

   ∴ 剩下的 $k'$ 步可以由 $tmp$ 所在长链的顶点的向上或向下数组直接得到 
   
   ```C++
   // 长链剖分----------------------------
   int len[MAXN];// 这里表示链长
   int lson[MAXN];
   int dep[MAXN];
   int f[MAXN][25];
   void dfs(int u, int fa) {
       len[u] = 0;
       dep[u] = dep[fa] + 1;
       f[u][0] = fa;
       for(int i = 1; (1 << i) <= dep[u]; i++)
           f[u][i] = f[f[u][i - 1]][i - 1];
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa)
               continue;
           dfs(v, u);
           if(len[v] + 1 > len[u]) {
               len[u] = len[v] + 1;
               lson[u] = v;
           }
       }
   }
   // 求k级祖先----------------------------
   vi up[MAXN], down[MAXN];
   int ltop[MAXN];
   void dfs2(int u, int fa) {
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa)
               continue;
           dfs2(v, u);
       }
       if(u != lson[fa]) {
           int x = u;
           for(int i = 0; i <= len[u] && x != 0; i++) {
               up[u].pb(x);
               x = f[x][0];
           }
           x = u;
           for(int i = 0; i <= len[u] && x != 0; i++) {
               down[u].pb(x);
               ltop[x] = u;
               x = lson[x];
           }
       }
   }
   int find_k(int u, int k) {
       if(k == 0)
           return u;
       int w = log(k) / log(2);
       k = k - (1 << w);
       u = f[u][w];
       if(dep[u] - dep[ltop[u]] >= k)
           return down[ltop[u]][dep[u] - dep[ltop[u]] - k];
       return up[ltop[u]][k - dep[u] + dep[ltop[u]]];
   }
   ```
   
4. **树由所有长链组成，当需要维护长度相关的信息时，可以用指针（方便访问）存在一维数组中**

   比如tmp[4]即表示到f[2]代表的节点距离为2的信息，也表示到f[1]代表的节点距离为3的信息。先遍历长儿子，再遍历短儿子，复杂度为$O(n)$。

   ![image-20200325185514848](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200325185514848.png)

   | 下标 |     [0]      | **[1]** | **[2]** | **[3]** |   **[4]**    |   **[5]**    |   **[6]**    | **[7]** | **[8]** |    **[9]**    |   **[10]**   | **[11]** |
   | :--: | :----------: | :-----: | :-----: | :-----: | :----------: | :----------: | :----------: | :-----: | :-----: | :-----------: | :----------: | :------: |
   | tmp1 |      1       |    3    |    4    |    4    |      1       |      1       |      1       |    1    |    2    |       1       |      1       |    1     |
   | f[i] | <u>**1**</u> |    2    |    5    |    6    | <u>**7**</u> | <u>**8**</u> | <u>**3**</u> |    9    |   10    | <u>**11**</u> | <u>**4**</u> |    12    |
   

   
| 下标 |  0   |  1   | **2** |    **3**     |  +4  |    **7**     |    **8**     | **9** | **10** |      11      | +3   | 14            |  15  |      16      |  +2  | 18   |
| :--: | :--: | :--: | :---: | :----------: | :--: | :----------: | :----------: | :---: | :----: | :----------: | ---- | ------------- | :--: | :----------: | :--: | ---- |
| tmp2 |      |      |       |              |      |              |              |       |        |              |      |               |      |              |      |      |
| g[i] |  6   |  5   |   2   | **<u>1</u>** |      | **<u>7</u>** | **<u>8</u>** |  10   |   9    | **<u>3</u>** |      | **<u>11</u>** |  12  | **<u>4</u>** |      |      |

   ```C++
   // 类似 f[u][j+1] += f[v][j] 递推
   ll tmp1[MAXN], *f[MAXN], *p1 = tmp1;
   // 类似 g[u][j] += g[v][j+1] 递推
   ll tmp2[MAXN * 2], *g[MAXN], *p2 = tmp2;
   void dfs2(int u, int fa) {
       if(u != lson[fa]) {
           f[u] = p1;
           p1 += len[u];
   
           p2 += len[u] - 1;// 需要2倍空间存
           g[u] = p2;
           p2 += len[u] ;
       }
       // 初始化
       if(lson[u]) {
           f[lson[u]] = f[u] + 1;// lson 在右
           g[lson[u]] = g[u] - 1;// lson 在左
           dfs2(lson[u], u);
           // 更新
       }
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa || v == lson[u])
               continue;
           dfs2(v, u);
           // 更新
       }
   }
   ```



## DSU on tree：$O(nlog^n)$

对于节点i：

- 递归解决所有的轻儿子，同时消除递归产生的影响
- 递归重儿子，不消除递归的影响
- 统计所有轻儿子对答案的影响
- 更新该节点的答案
- 删除所有轻儿子对答案的影响

```c++
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
#define pii pair<int,int>
#define vi vector<int>
#define SZ(x) (int)x.size()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int MAXN = 5e5 + 5;
const int MAXM = 5e5 + 5;
//前向星----------------------
struct edge {
    int to, next, w;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v, int w) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].w = w;
    head[u] = cnt;
}
void init() {//多组输入一定要初始化
    cnt = 0;
    memset(head, 0, sizeof head);
}
//树链剖分---------------------------------------
int dep[MAXN], f[MAXN][25], stree[MAXN], Son[MAXN];
int dis[MAXN];
int val[MAXN];
void dfs(int u, int fa) {
    dis[u] = dis[fa] ^ val[u];
    dep[u] = dep[fa] + 1;
    stree[u] = 1;
    f[u][0] = fa;
    for(int i = 1; (1 << i) <= dep[u]; i++)
        f[u][i] = f[f[u][i - 1]][i - 1];
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)//去掉双向边
            continue;
        val[v] = e[i].w;
        dfs(v, u);
        stree[u] += stree[v];
        if(stree[v] > stree[Son[u]])//重儿子更新
            Son[u] = v;
    }
}
//dsu on tree-----------------------------------------
int maxdep[1 << 22];
int ans[MAXN];
void cal(int u, int fa, int rt) {
    int x = dis[u];
    ans[rt] = max(ans[rt], maxdep[x] + dep[u] - 2 * dep[rt]);
    for(int i = 0; i < 22; i++)
        ans[rt] = max(ans[rt], maxdep[x ^ (1 << i)] + dep[u] - 2 * dep[rt]);
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        cal(v, u, rt);
    }
}
void add(int u, int fa) {
    int x = dis[u];
    maxdep[x] = max(maxdep[x], dep[u]);
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        add(v, u);
    }
}
void del(int u, int fa) {
    int x = dis[u];
    maxdep[x] = -INF;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        del(v, u);
    }
}
void dsu(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa || v == Son[u])
            continue;
        dsu(v, u);
        ans[u] = max(ans[u], ans[v]);
    }
    if(Son[u] != 0) {
        dsu(Son[u], u);
        ans[u] = max(ans[u], ans[Son[u]]);
    }
    //重儿子子树到u的直链
    int x = dis[u];
    ans[u] = max(ans[u], maxdep[x] - dep[u]);
    for(int i = 0; i < 22; i++)
        ans[u] = max(ans[u], maxdep[x ^ (1 << i)] - dep[u]);
    //加入u
    maxdep[x] = max(maxdep[x], dep[u]);
    //遍历轻儿子子树
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa || v == Son[u])
            continue;
        //更新
        cal(v, u, u);
        //加入
        add(v, u);
    }
    //去除轻儿子子树的影响
    if(u != Son[fa])
        del(u, fa);
}
//----------------------------------------------------
int main() {
    memset(maxdep, -INF, sizeof maxdep);
    init();
    int n;
    scanf("%d", &n);
    for(int i = 2; i <= n; i++) {
        int v;
        char c;
        scanf(" %d %c", &v, &c);
        //add_edge(i, v, 1 << (c - 'a'));
        add_edge(v, i, 1 << (c - 'a'));
    }
    dfs(1, 0);
    dsu(1, 0);
    for(int i = 1; i <= n; i++)
        printf("%d ", ans[i]);
}
```



## 网络流:

性质：

最大流最小割定理：最大流 = 最小割

二分图匹配 = 最大流

一般图：

- 对于连通图，|最大匹配|+|最小边覆盖|=|V|
- |最大独立集|+|最小顶点覆盖|=|V| 

二分图：

- |最大匹配|=|最小顶点覆盖|

### 最大流：

#### Edmonds-Karp算法$O(nm^2)$

```c++
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<queue>
#define ll long long
using namespace std;
const int MAXN = 205;
int n, m;
int g[MAXN][MAXN];
int pre[MAXN];
int bfs(int s, int e) {
    memset(pre, -1, sizeof pre);
    vector<int>flow(MAXN);
    flow[s] = 0x3f3f3f3f;
    queue<int>q;
    q.push(s);
    while(!q.empty()) {
        int x = q.front();
        q.pop();
        if(x == e) //每次找一条
            break;
        for(int i = 1; i <= n; i++)
            if(g[x][i] > 0 && pre[i] == -1) {
                pre[i] = x;
                flow[i] = min(flow[x], g[x][i]);
                q.push(i);
            }
    }
    return flow[e];
}
int EK(int s, int e) {
    int ans = 0;
    while(true) {
        int tmp = bfs(s, e);
        if(tmp == 0)
            break;
        ans += tmp;
        for(int i = e; i != s;) {
            int last = pre[i];
            g[last][i] -= tmp;
            g[i][last] += tmp;
            i = last;
        }
    }
    return ans;
}
int main() {
    while(~scanf("%d%d", &m, &n)) {
        memset(g, 0, sizeof g);
        for(int i = 0; i < m; i++) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            g[u][v] += w;
        }
        printf("%d\n", EK(1, n));
    }
}
```

#### dinic算法

一般情况$O(n^2m)$，二分图$O(\sqrt{n}m)$

```c++
#include<iostream>
#include<stdio.h>
#include<vector>
#include<algorithm>
#define SZ(x) (int)x.size()
using namespace std;
const int MAXN = 1005;
const int MAXM = 1e5 + 5;
const int INF = 1e9 + 5;
namespace maxflow {
struct Edge {
    int v, rev, f;
};
int n, s, t;
int cur[MAXM], dep[MAXN], gap[MAXN];
int flow;
vector<Edge> G[MAXN];
void add_edge(int u, int v, int f) {
    G[u].push_back({v, SZ(G[v]), f});
    G[v].push_back({u, SZ(G[u]) - 1, 0});
}
int dfs(int u, int lim) {
    if(u == t)
        return lim;
    int num = 0, f;
    for(int &i = cur[u], v; i < SZ(G[u]); ++i) {
        if(dep[v = G[u][i].v] == dep[u] - 1 && (f = G[u][i].f))
            if(G[u][i].f -= (f = dfs(v, std::min(lim - num, f))),
                    G[v][G[u][i].rev].f += f, (num += f) == lim)
                return num;
    }
    if(!--gap[dep[u]++])
        dep[s] = n + 1;
    return ++gap[dep[u]], cur[u] = 0, num;
}
void init(int _n) {
    n = _n;
    for(int i = 0; i < n; ++i)
        G[i].clear();
}
void solve(int _s, int _t) {
    s = _s, t = _t, flow = 0;
    for(int i = 0; i <= n; ++i)
        cur[i] = dep[i] = gap[i] = 0;
    for(gap[0] = n; dep[s] <= n; flow += dfs(s, INF));
}
}
int main() {
    // 这个板子 0 点不能用，下标必须从 1 开始
    int n, m;
    scanf("%d%d", &n, &m);
    maxflow::init(n * 2 + 2);
    for(int i = 0; i < m; i++) {
        int x, y;
        scanf("%d%d", &x, &y);
        maxflow::add_edge(x, y + n, 1);
    }
    int s = n * 2 + 1, t = n * 2 + 2;
    for(int i = 1; i <= n; i++) {
        maxflow::add_edge(s, i, 1);
        maxflow::add_edge(i + n, t, 1);
    }
    maxflow::solve(s, t);
    printf("%d\n", maxflow::flow);
}

```

### 最大权闭合图：

如下建图跑最大流，此时最小割（最大流）具有唯一性

$ans=\sum_{i为正权点}val(i)-maxflow$

![image-20200504191859153](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200504191859153.png)![image-20200504191924400](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200504191924400.png)



### 最大密度子图：

待补QAQ

### 二维平面图网络流:

平面图最大流 = 平面图最小割 = 对偶图最短路

![img](https://cdn.luogu.com.cn/upload/pic/11942.png)

![img](https://cdn.luogu.com.cn/upload/pic/53360.png)

![img](https://cdn.luogu.com.cn/upload/pic/53361.png)



### 最小费最大流：

对于负权边：

把负权边改为如下建边。

$mf=mf+\sum_{负权边e}c(e)$

$mc=mc+\sum_{负权边e}c(e)*d(e)$

![image-20200503230445019](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200503230445019.png)

#### 类Dinic算法$O(nmf)$

```c++
namespace MCMF {
int n, tot;
int mf, mc, sum;
vi G[MAXN];
int cap[MAXM * 2], cost[MAXM * 2], edge[MAXM * 2];
void add(int u, int v, int Cap, int Cost) {
    G[u].push_back(++tot);
    edge[tot] = v;
    cap[tot] = Cap;
    cost[tot] = Cost;
}
void add_edge(int u, int v, int Cap, int Cost) {
    add(u, v, Cap, Cost);
    add(v, u, 0, -Cost);
}
int dis[MAXN];
bool augment(int s, int t) {
    priority_queue<pii, vector<pii>, greater<pii> > q;
    fill(dis, dis + n + 1, INF);
    q.push({ dis[t] = 0, t });
    while(!q.empty()) {
        pii x = q.top();
        q.pop();
        if(dis[x.se] != x.fi)
            continue;
        int &u = x.se, dt, v;
        for(int it : G[u])
            if(cap[it ^ 1] && (dt = dis[u] - cost[it]) < dis[v = edge[it]])
                q.push({ dis[v] = dt, v });
    }
    sum += dis[s];
    for(int i = 0; i <= n; ++i)
        for(int it : G[i])
            cost[it] += dis[edge[it]] - dis[i];
    return dis[s] != INF;
}
bool vis[MAXN];
int dfs(int u, int t, int limit) {
    if(!limit)
        return 0;
    if(u == t) {
        mc += limit * sum;
        return limit;
    }
    int fee = 0, v;
    vis[u] = true;
    for(auto it : G[u]) {
        if(cost[it] || !cap[it] || vis[v = edge[it]])
            continue;
        int water = dfs(v, t, min(limit - fee, cap[it]));
        cap[it] -= water;
        cap[it ^ 1] += water;
        fee += water;
        if(fee == limit)
            break;
    }
    if(fee == limit)
        vis[u] = false;
    return fee;
}
void init(int x) {
    n = x, tot = 1;
    for(int i = 0; i <= x; ++i)
        G[i].clear();
}
void solve(int s, int t) {
    int res;
    mf = mc = sum = 0;
    do {
        do {
            fill(vis, vis + n + 1, 0);
        } while(mf += (res = dfs(s, t, INF)), res > 0);
    } while(augment(s, t));
}
}
int main() {
    int n, m, s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    MCMF::init(n);
    for(int i = 0; i < m; i++) {
        int u, v, c, w;
        scanf("%d%d%d%d", &u, &v, &c, &w);
        MCMF::add_edge(u, v, c, w);
    }
    MCMF::solve(s, t);
    printf("%d %d\n", MCMF::mf, MCMF::mc);
}

```

#### ZKW算法$O(nmf)$

```C++
#include<bits/stdc++.h>

#define SZ(x) (int)x.size()
const int INF = 0x3f3f3f3f;
const int MAXN = 50005;
const int MAXM = 500005;
using namespace std;

namespace ZKW {
struct edge {
    int from, to, cap, cost;
} w[MAXM * 2];
vector<int> E[MAXN];
bool vis[MAXN];
int cnt, cost, flow, price;
void init() {
    cnt = 0;
    memset(E, 0, sizeof E);
    memset(vis, 0, sizeof vis);
}
void add_edge(int u, int v, int cap, int cost) {//双向边
    w[cnt] = (edge) {
        u, v, cap, cost
    };
    E[u].push_back(cnt++);
    w[cnt] = (edge) {
        v, u, 0, -cost
    };
    E[v].push_back(cnt++);
}
int aug(int u, int a, int T) {
    if(u == T)
        return cost += a * price, a;
    vis[u] = 1;
    int f = a;
    for(int i = 0; i < SZ(E[u]); i++) {
        edge e = w[E[u][i]];
        if(!e.cost && e.cap && !vis[e.to]) {
            int d = aug(e.to, min(f, e.cap), T);
            w[E[u][i]].cap -= d;
            w[E[u][i] ^ 1].cap += d;
            if(!(f -= d))
                return a;
        }
    }
    return a - f;
}
pair<int, int> calc(int S, int T) {
    flow = cost = price = 0;
    for(;;) {
        for(;;) {
            memset(vis, 0, sizeof(vis));
            int f = aug(S, INF, T);
            if(!f)
                break;
            flow += f;
        }
        int d = INF;
        for(int u = 0; u < MAXN; u++)
            if(vis[u])
                for(int i = 0; i < SZ(E[u]); i++) {
                    edge e = w[E[u][i]];
                    if(e.cap && !vis[e.to])
                        d = min(d, e.cost);
                }
        if(d == INF)
            return make_pair(flow, cost);
        for(int u = 0; u < MAXN; u++)
            if(vis[u])
                for(int i = 0; i < SZ(E[u]); i++)
                    w[E[u][i]].cost -= d, w[E[u][i] ^ 1].cost += d;
        price += d;
    }
}
}
int main() {
    //该板子无法求负边
    int n, m, s, t;
    scanf("%d%d%d%d", &n, &m, &s, &t);
    ZKW::init();
    for(int i = 0; i < m; i++) {
        int u, v, cap, cost;
        scanf("%d%d%d%d", &u, &v, &cap, &cost);
        ZKW::add_edge(u, v, cap, cost);
    }
    pair<int, int> ans = ZKW::calc(s, t);
    printf("%d %d\n", ans.first, ans.second);
}

```

## 无向图最小割-*Stoer-Wagner*算法 $O(n^3)$

```c++
#include<iostream>
#include<stdio.h>
#include<vector>
#include<algorithm>
#include<cstring>
#include<queue>
#include<set>
#include<map>

#define SZ(x) (int)x.size()
using namespace std;
const int INF = 0x3f3f3f3f;
const int MAXN = 605;
const int MAXM = 600005;

int edge[MAXN][MAXN];
int Mincut(int n) {
    int ans = INF;
    int node[600], dist[600];
    bool visit[600];
    int i, prev, maxj, j, k;
    for(i = 0; i < n; i++)
        node[i] = i;
    while(n > 1) {
        int maxj = 1;
        for(i = 1; i < n; i++) {  //初始化到已圈集合的割大小
            dist[node[i]] = edge[node[0]][node[i]];
            if(dist[node[i]] > dist[node[maxj]])
                maxj = i;
        }
        prev = 0;
        memset(visit, false, sizeof(visit));
        visit[node[0]] = true;
        for(i = 1; i < n; i++) {
            if(i == n - 1) {  //只剩最后一个没加入集合的点，更新最小割
                ans = min(ans, dist[node[maxj]]);
                for(k = 0; k < n; k++)  //合并最后一个点以及推出它的集合中的点
                    edge[node[k]][node[prev]] = (edge[node[prev]][node[k]] += edge[node[k]][node[maxj]]);
                node[maxj] = node[--n]; //缩点后的图
            }
            visit[node[maxj]] = true;
            prev = maxj;
            maxj = -1;
            for(j = 1; j < n; j++)
                if(!visit[node[j]]) {  //将上次求的maxj加入集合，合并与它相邻的边到割集
                    dist[node[j]] += edge[node[prev]][node[j]];
                    if(maxj == -1 || dist[node[maxj]] < dist[node[j]])
                        maxj = j;
                }
        }

    }
    return ans;
}
int main() {
    //从0-(n-1)记点
    int n, m;
    while(~scanf("%d%d", &n, &m)) {
        memset(edge, 0, sizeof edge);
        while(m--) {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            edge[a][b] += c;
            edge[b][a] += c;
        }
        printf("%d\n", Mincut(n));//总点数
    }
}
```

## 二分图匹配

### 最大匹配：匈牙利算法$O(nm)$

```c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 2005;
const int MAXM = 2e6 + 5;
struct edge {
    int to, next;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

int link[MAXN], vis[MAXN];
bool dfs(int x) {
    for(int i = head[x]; i; i = e[i].next) {
        int v = e[i].to;
        if(!vis[v]) {
            vis[v] = 1;
            if(link[v] == -1 || dfs(link[v])) {
                link[v] = x;
                return true;
            }
        }
    }
    return false;
}
int hungary(int n) { //匈牙利算法
    memset(link, -1, sizeof link);
    int ans = 0;
    for(int i = 1; i <= n; i++) {
        memset(vis, 0, sizeof vis);
        if(dfs(i))
            ans++;
    }
    return ans;
}
int main() {
    int n, m, e;
    scanf("%d%d%d", &n, &m, &e);
    while(e--) {
        int u, v;
        scanf("%d%d", &u, &v);
        if(u < 1 || u > n || v < 1 || v > m)
            continue;
        add_edge(u, v);//单向边
    }
    printf("%d", hungary(n));
}

```

### 最大权匹配：KM算法 $O(n^3)$ 或 $O( nm)$

求最小权：将边权取负，dis初始化为负无穷。

```c++
int dis[MAXN][MAXN], slack[MAXN];
int visx[MAXN], linkx[MAXN], wx[MAXN];
int visy[MAXN], linky[MAXN], wy[MAXN];
bool dfs(int u, int cnty) { //匈牙利算法找增广路径
    visx[u] = 1;
    for(int v = 1; v <= cnty; v++) {
        if(visy[v])
            continue;
        int x = wx[u] + wy[v] - dis[u][v];
        if(x == 0) {
            visy[v] = 1;
            if(!linky[v] || dfs(linky[v], cnty)) {
                linkx[u] = v;
                linky[v] = u;
                return true;
            }
        } else
            slack[v] = min(slack[v], x);
    }
    return false;
}
int KM(int cntx, int cnty) {
    fill(wx, wx + cntx + 1, 0);
    fill(wy, wy + cnty + 1, 0);
    for(int i = 1; i <= cntx; i++)
        for(int j = 1; j <= cnty; j++)
            wx[i] = max(wx[i], dis[i][j]);
    fill(linkx, linkx + cntx + 1, 0);
    fill(linky, linky + cnty + 1, 0);
    for(int i = 1; i <= cntx; i++) {
        fill(slack, slack + cnty + 1, INF);
        while(true) {
            fill(visx, visx + cntx + 1, 0);
            fill(visy, visy + cnty + 1, 0);
            if(dfs(i, cnty))
                break;
            int minz = INF;
            for(int j = 1; j <= cnty; j++)
                if(!visy[j])
                    minz = min(minz, slack[j]);
            for(int j = 1; j <= cntx; j++)
                if(visx[j])
                    wx[j] -= minz;
            for(int j = 1; j <= cnty; j++)
                if(visy[j])
                    wy[j] += minz;
            if(minz == INF) // 无法匹配
                break;
        }
    }
    int ans = 0;
    for(int i = 1; i <= cntx; i++)
        ans += dis[i][linkx[i]];
    return ans;
}
void init(int cntx, int cnty) {
    for(int i = 1; i <= cntx; i++)
        fill(dis[i], dis[i] + cnty + 1, 0);
}
```



## 多边形面积

$S=\frac 12\times[(x_1y_2-x_2y_1)+(x_2y_3-x_3y_2)+\cdots+(x_{n-1}y_n-x_ny_{n-1})+(x_ny_1-x_1y_n)]$



## 前向星存边

```c++
//前向星----------------------
struct edge {
    int to, next, w;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v, int w) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].w = w;
    head[u] = cnt;
}
void init() {//多组输入一定要初始化
    cnt = 0;
    memset(head, 0, sizeof head);
}
```

## 最短路问题

## Floyd

```c++
//可以处理负边,无法处理负环 
for(k = 1; k <= n; k++)
    for(i = 1; i <= n; i++)
        for(j = 1; j <= n; j++)
            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
```

## dijkstra堆优化($O(nlog^n)$)

```c++
int dis[MAXN];
int vis[MAXN];
priority_queue<pii, vector<pii>, greater<pii> >q;
void dijkstra(int s) {//不能处理负边
    //注意memset有些不能赋
    memset(dis, INF, sizeof dis);
    memset(vis, 0, sizeof vis);
    dis[s] = 0;
    q.push(make_pair(0, s));
    while(!q.empty()) {
        int x = q.top().second;
        q.pop();
        if(vis[x])//1个点只用来松弛1次
            continue;
        vis[x] = 1;
        for(int i = head[x]; i; i = e[i].next) {
            int v = e[i].to;
            if(dis[v] > dis[x] + e[i].w) {
                dis[v] = dis[x] + e[i].w;
                q.push(make_pair(dis[v], v));
            }
        }
    }
}
```

## bellman_ford($O(nm)$)

```c++
int u[MAXM * 2], v[MAXM * 2], w[MAXM * 2], cnt = 0;
void add_edge(int a, int b, int c) {
    u[++cnt] = a;
    v[cnt] = b;
    w[cnt] = c;
}
//----------------------------------------
int dis[MAXN];
int pre[MAXN];
int bellman_ford(int n, int s) {
    //可以到达负环的源点不存在最短路
    memset(dis, INF, sizeof dis);
    dis[s] = 0;
    for(int i = 0; i < n - 1; i++) {
        int update = 0;
        for(int j = 1; j <= cnt; j++) {
            int x = u[j], y = v[j];
            if(dis[x] + w[j] < dis[y]) {
                dis[y] = dis[x] + w[j];
                pre[y] = x;
                update = 1;
            }
        }
        if(!update)//没有更新了,剪枝
            break;
    }
    for(int j = 1; j <= cnt; j++) {
        int x = u[j], y = v[j];
        if(dis[x] + w[j] < dis[y])
            return x;//有负环
    }
    return 0;
}
int vis[MAXN];
vi get_path(int n, int s) { // 打印负环路径
    vi ans;
    int x = bellman_ford(n, s);
    if(!x)
        return ans;
    memset(vis, 0, sizeof vis);
    while(!vis[x]) { // 保证x回到负环上
        vis[x] = 1;
        x = pre[x];
    }
    int now = x;
    ans.pb(now); // 此处x作为环首存了2次
    do { // 遍历负环
        int y = pre[now];
        now = y;
        ans.pb(now);
    } while(now != x);
    reverse(ans.begin(), ans.end());
    return ans;
}
void init(){
    cnt = 0;
    memset(dis, INF, sizeof dis);
    memset(pre, 0, sizeof pre);
    memset(vis, 0, sizeof vis);
}
```

## spfa（$O(nm)$）

```c++
int vis[MAXN];
int dis[MAXN];
int qnum[MAXN]; // 入队次数
bool spfa(int n, int s) {
    memset(vis, 0, sizeof vis);
    memset(dis, INF, sizeof dis);
    memset(qnum, 0, sizeof qnum);
    dis[s] = 0;
    qnum[s] = 1;
    queue<int>q;
    q.push(s);
    vis[s] = 1;
    while(!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = 0;
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if(dis[u] + e[i].w < dis[v]) {
                dis[v] = dis[u] + e[i].w;
                if(!vis[v]) {
                    q.push(v);
                    vis[v] = 1;
                    if(++qnum[v] > n) //存在负环
                        return false;
                }
            }
        }
    }
    return true;
}
```

如果只求负环TLE了，两种玄学假算法

- 把存在负环条件改为   $(int)sqrt(1.0*n)$

- 用dfs跑（不加超级源点分别跑，和数据有关，最坏复杂度爆炸）

  ```c++
  int vis[MAXN];
  int dis[MAXN];
  bool dfs_spfa(int u) {
      vis[u] = 1;
      for(int i = head[u]; i; i = e[i].next) {
          int v = e[i].to, w = e[i].w;
          if(dis[u] + w < dis[v]) {
              dis[v] = dis[u] + w;
              if(vis[v] || !dfs_spfa(v))
                  return false; // 有负环
          }
      }
      vis[u] = 0;
      return true; // 无负环
  }
  void init() {
      memset(vis, 0, sizeof vis);
      memset(dis, INF, sizeof dis);
  }
  int main(){
      //...
      dis[s] = 0;
      dfs_spfa(s);
      //...
  }
  ```

  



## 点分治($O(nlog^nlog^n)$)

重心有一个很重要的性质，每一个子树的大小都不超过n/2。

对每个点：

1.计算所有经过u点的路径数。（红+蓝）

2.容斥，去掉不符合的路径。对这些路径，两个端点一定同时存在于某个v的子树内。（蓝）

3.对每个点的solve的复杂度不超过$xlog^x$，x为子树大小。

![image-20200316162906104](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200316162906104.png)

```c++
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<cstring>
#define ll long long
#define INF 0x3f3f3f3f
#define pii pair<int,int>
#define vi vector<int>
#define SZ(x) (int)x.size()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int MAXN = 1e5 + 5;
const int MAXM = 1e5 + 5;
int n, k;
//前向星----------------------
struct edge {
    int to, next, w;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v, int w) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    e[cnt].w = w;
    head[u] = cnt;
}
void init() {//多组输入一定要初始化
    cnt = 0;
    memset(head, 0, sizeof head);
}
//点分治--------------------------
int sz[MAXN];
int vis[MAXN];
int mima = INF;//最大子树的最小值
int root;
int sumsz;//当前树的大小
void getrt(int u, int fa) {//求重心
    sz[u] = 1;
    int maxson = 0;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa || vis[v])
            continue;
        getrt(v, u);
        sz[u] += sz[v];
        maxson = max(maxson, sz[v]);
    }
    maxson = max(maxson, sumsz - sz[u]);
    if(mima > maxson) {
        mima = maxson;
        root = u;
    }
}
//算贡献---------------------
int dis[MAXN], q[MAXN];
int cnt2 = 0;
void getdis(int u, int fa) {
    q[++cnt2] = dis[u];
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(vis[v] || v == fa)
            continue;
        dis[v] = dis[u] + e[i].w;
        getdis(v, u);
    }
}
int solve(int u, int w) {
    dis[u] = w;
    cnt2 = 0;
    getdis(u, 0);
    sort(q + 1, q + cnt2 + 1);
    int sum = 0;
    int L = 1, R = cnt2;
    while(L < R) {
        if(q[L] + q[R] <= k) {
            sum += R - L;
            L++;
        } else
            R--;
    }
    return sum;
}
//----------------------------
int ans = 0;
void divide(int u) {
    ans += solve(u, 0);//当前节点的贡献
    vis[u] = 1;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(vis[v])
            continue;
        ans -= solve(v, e[i].w);//容斥,去掉两端点在v子树内,至u折返的路径
        //分治子树
        mima = INF;
        sumsz = sz[v];
        getrt(v, 0);
        divide(root);
    }
}
void pd_init() {
    ans = 0;
    memset(vis, 0, sizeof vis);
}
//----------------------------------------------
int main() {
    while(~scanf("%d%d", &n, &k)) {
        init();
        pd_init();
        if(n == 0 && k == 0)
            break;
        for(int i = 0; i <  n - 1; i++) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            add_edge(u, v, w);
            add_edge(v, u, w);
        }
        sumsz = n;
        mima = INF;
        getrt(1, 0);
        divide(root);
        printf("%d\n", ans);
    }
}
```

## 归并树

建树$O(nlog^n )$，查询第k小$O(log^nlog^nlog^n)$

![img](https://img-blog.csdn.net/20160420201534101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20160420202824621?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

```c++
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f
#define pii pair<int,int>
#define vi vector<int>
#define SZ(x) (int)x.size()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int MAXN = 1e5 + 5;
int a[MAXN];
int Merge[30][MAXN];
void build(int deep, int l, int r) {
    if(l == r) {
        Merge[deep][l] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(deep + 1, l, mid);
    build(deep + 1, mid + 1, r);
    for(int i = l, j = mid + 1, k = l; i <= mid || j <= r;) { //归并排序构造当前节点
        if(j > r)
            Merge[deep][k++] = Merge[deep + 1][i++];
        else if(i > mid || Merge[deep + 1][i] > Merge[deep + 1][j])
            Merge[deep][k++] = Merge[deep + 1][j++];
        else
            Merge[deep][k++] = Merge[deep + 1][i++];
    }
}
//计算[L,R]交[l,r]中小于x的有多少个数
int calc(int deep, int L, int R, int l, int r, int x) {
    if(l <= L && R <= r)
        return lower_bound(Merge[deep] + L, Merge[deep] + R + 1, x) - Merge[deep] - L;
    int mid = (L + R) >> 1;
    int ans = 0;
    if(l <= mid)
        ans += calc(deep + 1, L, mid, l, r, x);
    if(mid < r)
        ans += calc(deep + 1, mid + 1, R, l, r, x);
    return ans;
}
//区间第k小值查询(1,...,k,...,n)
int query(int n, int l, int r, int k) {
    int L = 1, R = n;
    while(L < R) {//答案为cnt = k - 1的最大的数
        int mid = (L + R + 1) >> 1;
        int cnt = calc(0, 1, n, l, r, Merge[0][mid]);
        if(cnt <= k - 1)
            L = mid ;
        else
            R = mid - 1;
    }
    return Merge[0][L];
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++)
        scanf("%d", a + i);
    build(0, 1, n);
    while(m--) {
        int l, r, k;
        scanf("%d%d%d", &l, &r, &k);
        printf("%d\n", query(n, l, r, k));
    }
}
```

## 树上博弈(走到不能走为止)

1.注意停止条件包括叶子节点和==只有一个子结点的根==

2.注意状态转移顺序

3.注意答案是否会造成覆盖

```c++
#include<bits/stdc++.h>
#define ll long long
#define INF 0x3f3f3f3f3f3f3f3f
#define pii pair<int,int>
#define vi vector<int>
#define SZ(x) (int)x.size()
#define pb push_back
#define fi first
#define se second
using namespace std;
const int MAXN = 6e5 + 5;
const int MAXM = 6e5 + 5;
//前向星----------------------
struct edge {
    int to, next;
} e[MAXM * 2]; //双倍内存
int cnt = 0;
int head[MAXN];
void add_edge(int u, int v) { //从1开始存
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}
//-----------------------------
ll a[MAXN], b[MAXN];
ll dp[MAXN][2][3];
map<int, int>leaf;
void dfs1(int u, int fa) {//从上往下选
    for(int  i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        dfs1(v, u);

        dp[u][1][2] = a[u] - b[u] - dp[v][0][0];
        sort(dp[u][1], dp[u][1] + 3);

        dp[u][0][2] = b[u] - a[u] - dp[v][1][0];
        sort(dp[u][0], dp[u][0] + 3);
    }
    if(dp[u][1][0] == INF) {//叶子节点
        dp[u][1][0] = a[u] - b[u];
        dp[u][0][0] = b[u] - a[u];
        leaf[u] = 1;
    }
}
void dfs2(int u, int fa) {
    if(fa != 0) {
        dp[u][1][2] = a[u] - b[u] - dp[fa][0][0];

        if(dp[fa][0][0] == b[fa] - a[fa] - dp[u][1][0])
            dp[u][1][2] = a[u] - b[u] - dp[fa][0][1];

        sort(dp[u][1], dp[u][1] + 3);

        dp[u][0][2] = b[u] - a[u] - dp[fa][1][0];

        if(dp[fa][1][0] == a[fa] - b[fa] - dp[u][0][0])
            dp[u][0][2] = b[u] - a[u] - dp[fa][1][1];

        sort(dp[u][0], dp[u][0] + 3);
    }
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        dfs2(v, u);
    }
}
void init() {
    cnt = 0;
    memset(head, 0, sizeof head);
    memset(dp, INF, sizeof dp);
    leaf.clear();
}
int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        init();
        int n;
        scanf("%d", &n);
        for(int i = 1; i <= n; i++)
            scanf("%lld", a + i);
        for(int i = 1; i <= n; i++)
            scanf("%lld", b + i);
        for(int i = 0; i < n - 1; i++) {
            int u, v;
            scanf("%d%d", &u, &v);
            add_edge(u, v);
            add_edge(v, u);
        }
        dfs1(1, 0);
        ll ans = dp[1][1][0];//从根向下走的答案

        //如果根只有一个儿子,那么可以向上走到根停止
        //如果根不止一个儿子,那么向上走到根不能停止
        if(e[head[1]].next == 0) {
            dp[1][1][1] = a[1] - b[1];
            sort(dp[1][1], dp[1][1] + 3);
            dp[1][0][1] = b[1] - a[1];
            sort(dp[1][0], dp[1][0] + 3);
        }
        dfs2(1, 0);
        for(int i = 1; i <= n; i++) {
            if(!leaf.count(i))
                ans = max(ans, dp[i][1][0]);
            else {
                if(dp[i][1][0] == a[i] - b[i])
                    ans = max(ans, dp[i][1][1]);
                else
                    ans = max(ans, dp[i][1][0]);
            }
        }
        if(n == 1)
            ans = a[1] - b[1];
        printf("%lld\n", ans);
    }
}
```

## 树哈希

1. 有根树哈希

   判断有根树同构：对根哈希，通过根的哈希值判断。

   ```C++
   const int mod = 1e9 + 7;
   const int base = 311;
   int sz[MAXN], Hash[MAXN];
   void gethash1(int u, int fa) { // 得到每个点的子树的哈希值
       sz[u] = 1;
       Hash[u] = 0;
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa)
               continue;
           gethash1(v, u);
           Hash[u] = (Hash[u] + 1ll * sz[v] * Hash[v] % mod) % mod;
           sz[u] += sz[v];
       }
       Hash[u] ^= 1ll * sz[u] * base % mod;
   }
   ```

2. 无根树哈希

   判断无根树同构：先求出重心（最多2个），以重心为根哈希，用重心的哈希值即可判断。

   ```C++
vi zx; // 存重心
   int mima, sumsz;
void getzx(int u, int fa) { // 求重心
       sz[u] = 1;
       int maxson = 0;
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa)
               continue;
           getzx(v, u);
           sz[u] += sz[v];
           maxson = max(maxson, sz[v]);
       }
       maxson = max(maxson, sumsz - sz[u]);
       if(mima == maxson)
           zx.pb(u);
       if(mima > maxson) {
           mima = maxson;
           zx.clear();
           zx.pb(u);
    }
   }
   void init(int x) { // x为整棵树的大小
       sumsz = x;
       mima = INF;
       zx.clear();
   }
   int main() {
       init(n);
       getzx(1, 0);
       vi tmp;
       for(int i = 0; i < SZ(zx); i++) {
           int rt = zx[i];
           gethash(rt, 0); // 以重心为根哈希
           tmp.pb(Hash[rt]);
       }
       sort(tmp.begin(), tmp.end());
       // 同构树得到的tmp相同
   }
   ```
   
3. 树型dp求任意点为根的哈希值

   ```C++
   void gethash2(int u, int fa, int n) { // 得到所有点为根时的哈希
       int fh = Hash[fa];
       fh ^= 1ll * n * base % mod;
       fh = (fh - 1ll * Hash[u] * sz[u] % mod + mod) % mod;
       fh ^= 1ll * (n - sz[u]) * base % mod;
       Hash[u] ^= 1ll * sz[u] * base % mod;
       Hash[u] = (Hash[u] + 1ll * (n - sz[u]) * fh % mod) % mod;
       Hash[u] ^= 1ll * n * base % mod;
       for(int i = head[u]; i; i = e[i].next) {
           int v = e[i].to;
           if(v == fa)
               continue;
           gethash2(v, u, n);
       }
   }
   int main() {
       init(n);
       gethash1(1, 0);
       gethash2(1, 0, n);
       getzx(1, 0);
       vi tmp;
       for(int j = 0; j < SZ(zx); j++)
           tmp.pb(Hash[zx[j]]);
       sort(tmp.begin(), tmp.end());
       // 同构树得到的tmp相同
   }
   ```


## 字典树/Trie树（插入$O(len)$，查找$O(len )$）

![img](https://img2018.cnblogs.com/blog/1721190/201908/1721190-20190814164235494-951333548.png)

```C++
int trie[400005][26];
char ans[400005][15];
int cnt = 0;
void insert(char* s, char* t) {
    int p = 0;
    for(int i = 0; i < strlen(s); i++) {
        int x = s[i] - 'a';
        if(!trie[p][x])
            trie[p][x] = ++cnt;
        p = trie[p][x];
    }
    strcpy(ans[p], t);
}
void find(char* s) {
    int p = 0;
    for(int i = 0; i < strlen(s); i++) {
        int x = s[i] - 'a';
        if(!trie[p][x]) { // 无答案
            puts("eh");
            return;
        }
        p = trie[p][x];
    }
    printf("%s\n", ans[p]);
}
```

## tarjan算法（$O(n+m)$）

### 求极大强连通分量+缩点

性质：得到的SCC的标号序列满足逆拓扑序

![img](https://cdn.luogu.com.cn/upload/pic/33262.png)

```c++
int dfn[MAXN]; // 点的遍历序号
int low[MAXN];// 回边/横跨边能抵达的最小时间戳
int tim; // 时间戳
int stk[MAXN], top = 0; // 手写栈
int ins[MAXN];//是否在栈内
int col[MAXN], cnum; //染色
void tarjan(int u) {
    low[u] = dfn[u] = ++tim;
    stk[++top] = u; // 进栈
    ins[u] = 1;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(!dfn[v]) { // 树边
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if(ins[v])  // 回边/前向边/横跨边
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]) { // 是SCC的开头
        cnum++;
        while(stk[top + 1] != u) {
            col[stk[top]] = cnum; // 染色
            ins[stk[top--]] = 0; // 出栈
        }
    }
}
void init(int n) {
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(ins, 0, sizeof ins);
    memset(col, 0, sizeof col);
    top = 0;
    cnum = n;
}
```

### 求点双连通分量/割点

性质：若点双中存在奇环，则连通分量内所有点至少在一个奇环上。

```C++
int tim = 0, dfn[MAXN], low[MAXN];
int stk[MAXN], top = 0; 
void tarjan(int u) {
    stk[++top] = u;// 进栈
    low[u] = dfn[u] = ++tim;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(!dfn[v]) { // 树边
            tarjan(v);
            low[u] = min(low[u], low[v]);
            if(low[v] >= dfn[u]) { // u是割点或根
                vi tmp; // 点双
                int f = 1;
                while(f) { // v子树弹出
                    tmp.pb(stk[top]);
                    if(stk[top] == v)
                        f = 0;
                    stk[top--] = 0;
                }
                tmp.pb(u);
//                for(int i = 0; i < SZ(tmp); i++) // 打印BCC
//                    printf("%d ", tmp[i]);
//                printf("\n");
            }
        } else // 回边
            low[u] = min(low[u], dfn[v]);
    }
//    if(!head[u]) // 单点BCC
//        printf("%d\n", u);
}
void init() {
    top = 0;
    memset(stk, 0, sizeof stk);
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
}
int main(){
    //...
    init();
    for(int i = 1; i <= n; i++)
        if(!dfn[i])
            tarjan(i);
    //...
}
```

### 求边双连通分量/割边+缩点成树

```C++
int tim = 0, dfn[MAXN], low[MAXN];
int stk[MAXN], top = 0;
int cut[MAXM]; // 标记割边id
vector<pii>cute; // 存割边
void tarjan(int u, int fe) {
    stk[++top] = u;// 进栈
    low[u] = dfn[u] = ++tim;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(!dfn[v]) { // 树边
            tarjan(v, e[i].id);
            low[u] = min(low[u], low[v]);
            if(low[v] == dfn[v]) { // i是割边
                cut[e[i].id] = 1;
                cute.pb(mp(u, v));
            }
        } else if(e[i].id != fe) // 判断重边
            low[u] = min(low[u], dfn[v]);
    }
}
//--------------------------------------------
int cnum, col[MAXN];
void paint(int u, int cnow) { // 染色缩点
    col[u] = cnow;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(cut[e[i].id] || col[v])
            continue;
        paint(v, cnow);
    }
}
void init(int n) {
    top = 0;
    memset(stk, 0, sizeof stk);
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    cute.clear();
    memset(cut, 0, sizeof cut);
    cnum = n;
    memset(col, 0, sizeof col);
}
int main() {
    //...
    init(n);
    for(int  i = 1; i <= n; i++)
        if(!dfn[i])
            tarjan(i, 0);
    for(int i = 1; i <= n; i++) // 缩点
        if(!col[i])
            paint(i, ++cnum);
    for(int i = 0; i < SZ(cute); i++) { // 建树
        int u = col[cute[i].fi];
        int v = col[cute[i].se];
        add_edge(u, v, 0);
        add_edge(v, u, 0);
    }
    //...
}
```

## kosaraju算法求强连通分量

性质：得到的SCC的标号序列满足拓扑序

```C++
int vis[MAXN];
int lat[MAXN], top = 0;
void dfs1(int u) {
    vis[u] = 1;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(vis[v] || e[i].w < 0) // 跑原边
            continue;
        dfs1(v);
    }
    lat[++top] = u;
}
int col[MAXN], cnum = 0;
void dfs2(int u) {
    col[u] = cnum;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(col[v] || e[i].w > 0) // 跑反向边
            continue;
        dfs2(v);
    }
}
void kosaraju(int n) {
    top = 0;
    for(int i = 1; i <= n; i++)
        if(!vis[i])
            dfs1(i);
    for(int i = top; i; i--)
        if(!col[lat[i]]) {
            cnum++;
            dfs2(lat[i]);
        }
}
void init() {
    cnum = 0;
    memset(col, 0, sizeof col);
    memset(vis, 0, sizeof vis);
}

```

## 2-SAT问题

对于节点x，用x表示x=0，用x+n表示x=1，根据变量关系建图。

求SCC，若x=0和x=1位于同一个SCC中则无解。若没有这种情况，一定有解。

## 差分约束系统

==**注意节点之间的隐藏条件！**==

①A - B >= C	相当于：	B连向A，权为C的边

②A - B <= C	相当于：	B连向A，权为C的边

③A - B = C	  可转化为 ①+②

④A - B < C	  如果在整数域上，可转化为 A - B <= C - 1

1. 求两个未知数的**最大差值**：

   用形如②的不等式建图，两点的**最短路**即为最大差值

   此时若存在负环（无最短路），表示最大差值不存在（无限小）；若两点不连通，表示最大差值为无限大。

2. 求两个未知数的**最小差值**：

   用形如①的不等式建图，两点的**最长路**即为最小差值

   此时若存在正环，表示最小差值为无限大；若两点不连通，表示最小差值不存在（无限小）。

   

## 二分图判断(染色)

```c++
int col[MAXN];
bool dfs(int u, int color) { // 二分图染色
    col[u] = color;
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(!col[v] && !dfs(v, -color) || col[v] == col[u])
            return false;
    }
    return true;
}
```



## 最小瓶颈生成树（$O(m)$）

```C++
//存边数组e1------------------------------------
//前向星e2--------------------------------------
//并查集----------------------------------------
//缩点------------------------------------------
//求最小瓶颈生成树--------------------------------
int neck(int n, int m) {
    int L = 0, R = 1e6 + 5; // 注意取值范围
    while(L < R) {
        int mid = (L + R) / 2;
        int tot = n;
        init2(); // 并查集初始化
        for(int i = 1; i <= m; i++) { // 判断是否连通
            if(e1[i].w <= mid) {
                int r1 = find(e1[i].u);
                int r2 = find(e1[i].v);
                if(r1 != r2) {
                    pre[r1] = r2;
                    tot--;
                }
            }
        }
        if(tot == 1) {
            R = mid;
            int cntm = 0;
            for(int i = 1; i <= m; i++) { // 去掉大于mid的边
                if(e1[i].w > mid)
                    continue;
                e1[++cntm].u = e1[i].u;
                e1[cntm].v = e1[i].v;
                e1[cntm].w = e1[i].w;
            }
            m = cntm;
        } else {
            L = mid + 1;
            init1(); // 前向星初始化
            for(int i = 1; i <= m; i++)
                if(e1[i].w <= mid)
                    add_edge(e1[i].u, e1[i].v, e1[i].w);
            init3(); // tarjan初始化
            for(int i = 1; i <= n; i++)
                if(!dfn[i])
                    tarjan(i);
            int cntm = 0;
            for(int i = 1; i <= m; i++) { // 更新点和边
                int u = col[e1[i].u];
                int v = col[e1[i].v];
                if(u == v)
                    continue;
                e1[++cntm].u = u;
                e1[cntm].v = v;
                e1[cntm].w = e1[i].w;
            }
            n = cnum; 
            m = cntm;
        }
    }
    return L;
}
```

## cin/cout加速

```c++
ios::sync_with_stdio(false);
cin.tie(nullptr);
cout.tie(nullptr);
```

## 卡常读入优化

```C++
int read() {
    int ret = 0, f = 1;
    char gc = getchar();
    while(gc < '0' || gc > '9') {
        if(gc == '-')
            f = -f;
        gc = getchar();
    }
    while(gc >= '0' && gc <= '9')
        ret = ret * 10 + gc - '0', gc = getchar();
    return ret * f;
}
```

## 交互题写法

```c++
int main() {
    int L = -1e9, R = 1e9;
    while(L < R) {
        int mid = (L + R) / 2;
        printf("%d\n", mid);
        fflush(stdout);
        string s;
        cin >> s;
        if(s == "equal")
            return 0;
        if(s == "small")
            L = mid + 1;
        else
            R = mid - 1;
    }
    printf("%d", L);
}
```

## IDE手动加栈

```C++
#define _CRT_SECURE_NO_WARNINGS
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC target("sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native")
#pragma comment(linker, "/stack:200000000")
```

## 欧拉回路判断

```C++
//------------------------------
//并查集
//------------------------------
bool euler(int n, int m) {
    for(int i = 1; i <= n; i++)
        pre[i] = i;
    vi du(n + 1);
    int total = n;
    for(int i = 1; i <= m; i++) {
        du[u[i]]++;
        du[v[i]]++;
        int r1 = find(u[i]);
        int r2 = find(v[i]);
        if(r1 != r2) {
            pre[r1] = r2;
            total--;
        }
    }
    if(total > 1) // 不连通
        return false;
    for(int i = 1; i <= n; i++)
        if(du[i] % 2) // 度数为奇数
            return false;
    return true;
}
```

## 欧拉通路(回路)打印/套圈算法 $O(m^2)$

![image-20200418171155327](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200418171155327.png)

```C++
// 前向星从2开始存
void euler_print(int u) {
    for(int i = head[u]; i; i = e[i].next) {
        if(!e[i].f)
            continue;
        e[i].f = e[i ^ 1].f = 0; // 标记无向边
        int v = e[i].to;
        euler_print(v);
        printf("%d %d\n", v, u);
    }
}
```

## 求支配树：lengauer_tarjan算法

最近必经点：dfn最大的必经点

半必经点：满足能通过dfn>dfn(v)的路径（不包括u、v）到达v的u中dfn最小的点。半必经点不一定属于必经点

![image-20200420224106524](C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20200420224106524.png)

```C++
struct edge {
    vi e[MAXN];
    void add_edge(int u, int v) {
        e[u].pb(v);
    }
} a, b, c, d; // a为原边,b为反向边
int dfn[MAXN];
int id[MAXN]; // dfn的反数组
int fa[MAXN];
int tim = 0;
void get_dfn(int u) { // 得到dfn
    dfn[u] = ++tim;
    id[tim] = u;
    for(int i = 0; i < SZ(a.e[u]); i++) {
        int v = a.e[u][i];
        if(dfn[v])
            continue;
        fa[v] = u;
        get_dfn(v);
    }
}
int idom[MAXN]; // 支配点/最近必经点
int sdom[MAXN]; // 半必经点
int val[MAXN]; // 祖先链中最小的dfn
int pre[MAXN];
int find(int x) { // 计算x的sdom
    if(x == pre[x])
        return x;
    int root = find(pre[x]);
    if(dfn[sdom[val[pre[x]]]] < dfn[sdom[val[x]]])
        val[x] = val[pre[x]];
    return pre[x] = root;
}
void lengauer_tarjan(int root) {
    get_dfn(root);
    for(int i = tim; i > 1; i--) { // 计算sdom
        int u = id[i];
        for(int j = 0; j < SZ(b.e[u]); j++) { //反向边v->u
            int v = b.e[u][j];
            if(!dfn[v]) // 不在dfs树上
                continue;
            find(v);
            int a = val[v];
            if(dfn[sdom[a]] < dfn[sdom[u]]) // 更新
                sdom[u] = sdom[a];
        }
        c.add_edge(sdom[u], u);
        pre[u] = fa[u];
        u = fa[u];
        for(int j = 0; j < SZ(c.e[u]); j++) {
            int v = c.e[u][j];
            find(v);
            if(sdom[val[v]] == u)
                idom[v] = u;
            else
                idom[v] = val[v];
        }
    }
    for(int i = 2; i <= tim; i++) { // 修正
        int u = id[i];
        if(idom[u] != sdom[u])
            idom[u] = idom[idom[u]];
    }
}
void init(int n) {
    tim = 0;
    for(int i = 1; i <= n; i++) {
        sdom[i] = pre[i] = val[i] = i;
        a.e[i].clear();
        b.e[i].clear();
        c.e[i].clear();
        d.e[i].clear();
    }
    memset(idom, 0, sizeof idom);
    memset(dfn, 0, sizeof dfn);
    memset(id, 0, sizeof id);
    memset(fa, 0, sizeof fa);
}
int main() {
    //...
    init(n + 1);
    lengauer_tarjan(root); // 一般n+1做根
    for(int i = 1; i <= n; i++) // 建支配树
        d.add_edge(idom[i], i);
    //...
}
```

## 求最长上升子序列LIS（$O(nlog^n)$）

性质：b数组一定是单调递增的，因此可以二分

```C++
int LIS(vi a) {
    vi b;
    for(int i = 0; i < SZ(a); i++) {
        int p = lower_bound(b.begin(), b.end(), a[i]) - b.begin();
        if(p == SZ(b))
            b.pb(a[i]);
        else
            b[p] = a[i];
    }
    return SZ(b);
}
```

## 最小树形图：朱刘算法（$O(nm )$）

![img](https://cdn.luogu.com.cn/upload/pic/22858.png)

不定根最小树形图：

建超级源点连向所有点，边权为其余边的总和tot（必然只选一次），答案为 Ans - tot

```C++
struct edge {
    int u, v, w;
} e[MAXM];
int cnt = 0;
void add_edge(int a, int b, int c) {
    e[++cnt].u = a;
    e[cnt].v = b;
    e[cnt].w = c;
}
int in[MAXN], fa[MAXN]; // 最小入边
int vis[MAXN], id[MAXN];
int zhu_liu(int n, int m, int root) {
    int ans = 0;
    while(true) {
        for(int i = 1; i <= n; i++) // 初始化
            in[i] = INF;
        in[root] = 0;
        for(int i = 1; i <= m; i++) { // 找出最小边
            int u = e[i].u, v = e[i].v;
            if(u != v && e[i].w < in[v]) {
                in[v] = e[i].w;
                fa[v] = u;
            }
        }
        int cnt = 0;
        for(int i = 1; i <= n; i++)
            vis[i] = id[i] = 0;
        for(int i = 1; i <= n; i++) {
            if(in[i] == INF) // 无解
                return -1;
            ans += in[i];
            int v = i;
            while(vis[v] != i && v != root && !id[v]) { // 找环
                vis[v] = i;
                v = fa[v];
            }
            if(v != root && !id[v]) { // 把环标记
                id[v] = ++cnt;
                for(int u = fa[v]; u != v; u = fa[u])
                    id[u] = cnt;
            }
        }
        if(!cnt) // 无环
            break;
        for(int i = 1; i <= n; i++) // 没搜到的
            if(!id[i])
                id[i] = ++cnt;
        for(int i = 1; i <= m; i++) { // 缩点
            int u = e[i].u, v = e[i].v;
            e[i].u = id[u];
            e[i].v = id[v];
            if(id[u] != id[v])
                e[i].w -= in[v];
        }
        root = id[root];
        n = cnt;
    }
    return ans;
}
void init() {
    cnt = 0;
    memset(fa, 0, sizeof fa);
}
```

## 三分（$O(2log_3^n)$）

```C++
int L, R;
while(L < R) {
    int mid = (L + R) / 2;
    if(check(mid) > check(mid + 1)) // 凹函数,凸函数相反
        L = mid + 1;
    else
        R = mid;
}
```

## 求所有子树的重心（$O(n )$）

重心性质:

1. 最大子树的sz最小
2. 到树中其它点的距离（边权为1）和最小
3. 除了树只有一个点的情况，树的重心必然在重链上
4. 一棵树最多有2个重心，且相邻

根据性质3，对当前节点u，可以用u的重儿子子树的重心p，在重链上向上爬找到u子树的重心。

```c++
//-----------------------------
// 重链剖分
//-----------------------------
int ZX[MAXN][2];
int check(int u, int rt) {
    return max(SZ[rt] - SZ[u], SZ[Son[u]]);
}
void getZX(int u, int fa) {
    for(int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        if(v == fa)
            continue;
        getZX(v, u);
    }
    int p = ZX[Son[u]][0];
    if(!p) { // 叶子节点
        ZX[u][0] = u;
        return;
    }
    while(SZ[u] - SZ[p] > SZ[p] && p != u)
        p = f[p];
    ZX[u][0] = p;
    if(p != u && check(p, u) == check(f[p], u)) // 考虑第2个重心
        ZX[u][1] = f[p];
    if(ZX[u][1])
        sort(ZX[u], ZX[u] + 2);
}
```

## 树状数组

![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png)

原数组：$a[1]\cdots a[n]$

差值数组：$d[i]=a[i]-a[i-1]$

差值前缀和：$sum1[x]=\sum\limits_{i=1}^{x}d[i]$		$sum2[x]=\sum\limits_{i=1}^{x}i*d[i]$

前缀和：$\sum\limits_{i=1}^{x}a[i]=(x+1)*sum1[x]-sum2[x]$

```c++
int a[MAXN]; 
int sum1[MAXN];
int sum2[MAXN];
int lowbit(int x) {
    return x & (-x);
}
void update(int n, int L, int R, int k) {
    int x = L;
    while(L <= n) {
        sum1[L] += k;
        sum2[L] += k * x;
        L += lowbit(L);
    }
    R++, x = R;
    while(R <= n) {
        sum1[R] -= k;
        sum2[R] -= k * x;
        R += lowbit(R);
    }
}
int get_sum(int L, int R) {
    int ans = 0, x = R;
    while(R > 0) {
        ans += (x + 1) * sum1[R] - sum2[R];
        R -= lowbit(R);
    }
    L--, x = L;
    while(L > 0) {
        ans -= (x + 1) * sum1[L] - sum2[L];
        L -= lowbit(L);
    }
    return ans;
}
void init() {
    memset(sum1, 0, sizeof sum1);
    memset(sum2, 0, sizeof sum2);
}
int main() {
    init();
    for(int i = 1; i <= n; i++) {
        scanf("%d", a + i);
        update(n, i, n, a[i] - a[i - 1]);
    }
}
```

## RMQ问题：st表 $O(nlog^n )$

```c++
int a[MAXN];
int dp[MAXN][25];
void init_rmq(int n) {
    for(int i = 1; i <= n; i++)
        dp[i][0] = a[i];
    for(int j = 1; (1 << j) <= n; j++)
        for(int i = 1; i + (1 << j) - 1 <= n; i++)
            dp[i][j] = min(dp[i][j - 1], dp[i + (1 << j - 1)][j - 1]);
}
int rmq(int L, int R) {
    int k = log(R - L + 1) / log(2);
    return min(dp[L][k], dp[R - (1 << k) + 1][k]);
}
```

## 拓扑排序

```C++
int in[MAXN];
bool topo(int n, vi& ans) {
    queue<int>q;
    for(int i = 1; i <= n; i++)
        if(!in[i])
            q.push(i);
    while(!q.empty()) {
        int u = q.front();
        ans.pb(u);
        q.pop();
        for(int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if(--in[v] == 0)
                q.push(v);
        }
    }
    if(SZ(ans) != 0)
        return false;
    return true;
}
void init() {
    memset(in, 0, sizeof in);
}
```

## 最大团

性质：

最大独立集 = 补图的最大团

### Bron–Kerbosch算法（$O(3^{\frac n3})$）

#### 写法一：快速求最大团

```c++
int path[MAXN][MAXN];
int vis[MAXN]; // 当前极大团中的点
int siz[MAXN]; // 所在极大团的大小
int res, group[MAXN]; // 最大团
bool dfs(int n, int u, int num) {
    for(int i = u + 1; i <= n; i++) {
        if(siz[i] + num <= res) // 剪枝
            return false;
        if(path[u][i]) {
            int j = 0;
            for(; j < num; j++)
                if(!path[i][vis[j]])
                    break;
            if(j == num) { // 皆与i相连
                vis[num] = i;
                if(dfs(n, i, num + 1))
                    return true;
            }
        }
    }
    if(num > res) {
        for(int i = 0; i < num; i++)
            group[i] = vis[i];
        res = num;
        return true;
    }
    return false;
}
void bron_kerbosch(int n) {
    res = 0;
    for(int i = n; i > 0; i--) {
        vis[0] = i;
        dfs(n, i, 1);
        siz[i] = res;
    }
}
void init() {
    memset(path, 0, sizeof path);
}
```

#### 写法二：求所有极大团

```C++
bool path[MAXN][MAXN]; //表示结点之间的连接
int du[MAXN]; // 节点度数
int some[MAXN][MAXN]; // 待加入的点
int none[MAXN][MAXN]; // 已搜过的点
int all[MAXN][MAXN]; // 当前极大团中的点
int ans;
void dfs(int dep, int an, int sn, int nn) {
    if(!sn && !nn) // 是一个极大团
        ans = max(ans, an);
    int u = some[dep][0];  // 选取Pivot结点
    for(int j = 0; j < an; ++j)
        all[dep + 1][j] = all[dep][j];
    for(int i = 0; i < sn; ++i) {
        int v = some[dep][i];
        if(path[u][v]) // 相邻节点不考虑
            continue;
        all[dep + 1][an] = v; // 更新极大团
        int tsn = 0, tnn = 0;
        for(int j = 0; j < sn; ++j) // 更新待选点
            if(path[v][some[dep][j]])
                some[dep + 1][tsn++] = some[dep][j];
        for(int j = 0; j < nn; ++j) // 更新已搜点
            if(path[v][none[dep][j]])
                none[dep + 1][tnn++] = none[dep][j];
        dfs(dep + 1, an + 1, tsn, tnn);
        some[dep][i] = 0; // 去除v
        none[dep][nn++] = v; // 加入v
    }
}
void bron_kerbosch(int n) {
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            du[i] += path[i][j];
    for(int i = 0; i < n; i++)
        some[0][i] = i + 1;
    auto cmp = [&](int x, int y) {
        return du[x] > du[y];
    };
    sort(some[0], some[0] + n, cmp); // pivot选择优化
    dfs(0, 0, n, 0);
}
void init() {
    memset(path, 0, sizeof path);
    memset(du, 0, sizeof du);
    ans = 0;
}
```

